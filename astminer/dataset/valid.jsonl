{"commit_id":"205987001054463","func":"expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the number of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}","idx":4,"name":"expand_dynamic_string_token","project":"7461293048740","target":"False"}
{"commit_id":"38197852149195","func":"_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  const char *const start = name;\n  char *last_elem, *wp;\n\n  /* Now fill the result path.  While copying over the string we keep\n     track of the start of the last path element.  When we come accross\n     a DST we copy over the value or (if the value is not available)\n     leave the entire path element out.  */\n  last_elem = wp = result;\n\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\n      /* Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  */\n\t  if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure\n\t\t\t && ((name[len] != '\\0'\n\t\t\t      && (!is_path || name[len] != ':'))\n\t\t\t     || (name != start\n\t\t\t\t && (!is_path || name[-1] != ':')))\n\t\t\t ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot use this path element, the value of the\n\t\t     replacement is unknown.  */\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    /* No DST we recognize.  */\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n\n  *wp = '\\0';\n\n  return result;\n}","idx":5,"name":"_dl_dst_substitute","project":"7461293048740","target":"False"}
{"commit_id":"95809135839772","func":"_dl_dst_count (const char *name, int is_path)\n{\n  const char *const start = name;\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.\n\n\t Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  */\n      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0\n\t     && (!__libc_enable_secure\n\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))\n\t\t     && (name == start || (is_path && name[-1] == ':'))))\n\t     && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0\n\t\t   && (!__libc_enable_secure\n\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))\n\t\t\t   && (name == start || (is_path && name[-1] == ':'))))\n\t\t   && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}","idx":6,"name":"_dl_dst_count","project":"7461293048740","target":"False"}
{"commit_id":"185220062279716","func":"vsyslog(pri, fmt, ap)\n\tint pri;\n\tregister const char *fmt;\n\tva_list ap;\n{\n\tstruct tm now_tm;\n\ttime_t now;\n\tint fd;\n\tFILE *f;\n\tchar *buf = 0;\n\tsize_t bufsize = 0;\n\tsize_t prioff, msgoff;\n \tstruct sigaction action, oldaction;\n\tstruct sigaction *oldaction_ptr = NULL;\n \tint sigpipe;\n\tint saved_errno = errno;\n\n#define\tINTERNALLOG\tLOG_ERR|LOG_CONS|LOG_PERROR|LOG_PID\n\t/* Check for invalid bits. */\n\tif (pri & ~(LOG_PRIMASK|LOG_FACMASK)) {\n\t\tsyslog(INTERNALLOG,\n\t\t    \"syslog: unknown facility/priority: %x\", pri);\n\t\tpri &= LOG_PRIMASK|LOG_FACMASK;\n\t}\n\n\t/* Check priority against setlogmask values. */\n\tif ((LOG_MASK (LOG_PRI (pri)) & LogMask) == 0)\n\t\treturn;\n\n\t/* Set default facility if none specified. */\n\tif ((pri & LOG_FACMASK) == 0)\n\t\tpri |= LogFacility;\n\n\t/* Build the message in a memory-buffer stream.  */\n\tf = open_memstream (&buf, &bufsize);\n\tprioff = fprintf (f, \"<%d>\", pri);\n\t(void) time (&now);\n#ifdef USE_IN_LIBIO\n        f->_IO_write_ptr += strftime (f->_IO_write_ptr,\n                                      f->_IO_write_end - f->_IO_write_ptr,\n                                      \"%h %e %T \",\n\t\t\t\t      __localtime_r (&now, &now_tm));\n#else\n\tf->__bufp += strftime (f->__bufp, f->__put_limit - f->__bufp,\n\t\t\t       \"%h %e %T \", __localtime_r (&now, &now_tm));\n#endif\n\tmsgoff = ftell (f);\n\tif (LogTag == NULL)\n\t  LogTag = __progname;\n\tif (LogTag != NULL)\n\t  fputs_unlocked (LogTag, f);\n\tif (LogStat & LOG_PID)\n\t  fprintf (f, \"[%d]\", __getpid ());\n\tif (LogTag != NULL)\n\t  putc_unlocked (':', f), putc_unlocked (' ', f);\n\n\t/* Restore errno for %m format.  */\n\t__set_errno (saved_errno);\n\n\t/* We have the header.  Print the user's format into the buffer.  */\n\tvfprintf (f, fmt, ap);\n\n\t/* Close the memory stream; this will finalize the data\n\t   into a malloc'd buffer in BUF.  */\n\tfclose (f);\n\n\t/* Output to stderr if requested. */\n\tif (LogStat & LOG_PERROR) {\n\t\tstruct iovec iov[2];\n\t\tregister struct iovec *v = iov;\n\n\t\tv->iov_base = buf + msgoff;\n\t\tv->iov_len = bufsize - msgoff;\n\t\t/* Append a newline if necessary.  */\n\t\tif (buf[bufsize - 1] != '\\n')\n\t\t  {\n\t\t    ++v;\n\t\t    v->iov_base = (char *) \"\\n\";\n\t\t    v->iov_len = 1;\n\t\t  }\n\t\t(void)__writev(STDERR_FILENO, iov, v - iov + 1);\n\t}\n\n\t/* Prepare for multiple users.  We have to take care: open and\n\t   write are cancellation points.  */\n\t__libc_cleanup_region_start ((void (*) (void *)) cancel_handler,\n\t\t\t\t     &oldaction_ptr);\n\t__libc_lock_lock (syslog_lock);\n\n\t/* Prepare for a broken connection.  */\n \tmemset (&action, 0, sizeof (action));\n \taction.sa_handler = sigpipe_handler;\n \tsigemptyset (&action.sa_mask);\n \tsigpipe = __sigaction (SIGPIPE, &action, &oldaction);\n\tif (sigpipe == 0)\n\t  oldaction_ptr = &oldaction;\n\n\t/* Get connected, output the message to the local logger. */\n\tif (!connected)\n\t\topenlog_internal(LogTag, LogStat | LOG_NDELAY, 0);\n\n\t/* If we have a SOCK_STREAM connection, also send ASCII NUL as\n\t   a record terminator.  */\n\tif (LogType == SOCK_STREAM)\n\t  ++bufsize;\n\n\tif (!connected || __send(LogFile, buf, bufsize, 0) < 0)\n\t  {\n\t    closelog_internal ();\t/* attempt re-open next time */\n\t    /*\n\t     * Output the message to the console; don't worry about blocking,\n\t     * if console blocks everything will.  Make sure the error reported\n\t     * is the one from the syslogd failure.\n\t     */\n\t    if (LogStat & LOG_CONS &&\n\t\t(fd = __open(_PATH_CONSOLE, O_WRONLY|O_NOCTTY, 0)) >= 0)\n\t      {\n\t\tdprintf (fd, \"%s\\r\\n\", buf + msgoff);\n\t\t(void)__close(fd);\n\t      }\n\t  }\n\n\tif (sigpipe == 0)\n\t\t__sigaction (SIGPIPE, &oldaction, (struct sigaction *) NULL);\n\n\t/* End of critical section.  */\n\t__libc_cleanup_region_end (0);\n\t__libc_lock_unlock (syslog_lock);\n\n\tfree (buf);\n}","idx":8,"name":"vsyslog","project":"253444729592566","target":"False"}
{"commit_id":"254908387075772","func":"init_syntax_once ()\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 0; c < CHAR_SET_SIZE; ++c)\n     if (ISALNUM (c))\n\tre_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}","idx":10,"name":"init_syntax_once","project":"88393274694273","target":"False"}
{"commit_id":"78539342326652","func":"main (void)\n{\n  char *login;\n  int errors = 0;\n\n  login = getlogin ();\n  if (login == NULL)\n    puts (\"getlogin returned NULL, no further tests\");\n  else\n    {\n      char name[1024];\n      int ret;\n\n      printf (\"getlogin returned: `%s'\\n\", login);\n\n      ret = getlogin_r (name, sizeof (name));\n      if (ret == 0)\n\t{\n\t  printf (\"getlogin_r returned: `%s'\\n\", name);\n\t  if (strcmp (name, login) != 0)\n\t    {\n\t      puts (\"Error: getlogin and getlogin_r returned different names\");\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  printf (\"Error: getlogin_r returned: %d (%s)\\n\",\n\t\t  ret, strerror (ret));\n\t  ++errors;\n\t}\n    }\n\n  return errors != 0;\n}","idx":11,"name":"main","project":"55018883367054","target":"False"}
{"commit_id":"53173785472589","func":"getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  /* Get name of tty connected to fd 0.  Return if not a tty or\n     if fd 0 isn't open.  Note that a lot of documentation says that\n     getlogin() is based on the controlling terminal---what they\n     really mean is \"the terminal connected to standard input\".  The\n     getlogin() implementation of DEC Unix, SunOS, Solaris, HP-UX all\n     return NULL if fd 0 has been closed, so this is the compatible\n     thing to do.  Note that ttyname(open(\"/dev/tty\")) on those\n     systems returns /dev/tty, so that is not a possible solution for\n     getlogin().  */\n\n  result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));\n  \n  if (result != 0)\n    return result;\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t/* The caller expects ENOENT if nothing is found.  */\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_user) + 1;\n\n      if (needed > name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_user, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}","idx":13,"name":"getlogin_r","project":"156577410779052","target":"False"}
{"commit_id":"27593887882779","func":"void KPasswordDlg::keyPressed( QKeyEvent *e )\n{\n  static bool waitForAuthentication = false;\n  if (!waitForAuthentication) {\n\tswitch ( e->key() )\n\t{\n\t\tcase Key_Backspace:\n\t\t\t{\n\t\t\t\tint len = password.length();\n\t\t\t\tif ( len ) {\n\t\t\t\t\tpassword.truncate( len - 1 );\n\t\t\t\t\tif( stars )\n\t\t\t\t\t\tshowStars();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Key_Return:\n            timer.stop();\n\t\t\twaitForAuthentication = true;\n\t\t\tif ( tryPassword() )\n\t\t\t\temit passOk();\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel->setText( glocale->translate(\"Failed\") );\n\t\t\t\tpassword = \"\";\n\t\t\t\ttimerMode = 1;\n\t\t\t\ttimer.start( 1500, TRUE );\n\t\t\t}\n\t\t\twaitForAuthentication = false;\n\t\t\tbreak;\n\n\t\tcase Key_Escape:\n\t\t\temit passCancel();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ( password.length() < MAX_PASSWORD_LENGTH )\n\t\t\t{\n\t\t\t\tpassword += (char)e->ascii();\n\t\t\t\tif( stars )\n\t\t\t\t\tshowStars();\n\t\t\t\ttimer.changeInterval( 10000 );\n\t\t\t}\n\t}\n  }\n}","idx":14,"name":"KPasswordDlg::keyPressed","project":"174571154001437","target":"False"}
{"commit_id":"188827082806743","func":"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}","idx":16,"name":"check_1_6_dummy","project":"47598748964815","target":"False"}
{"commit_id":"64321645051779","func":"process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto bailout;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request length was inconsistent\",\n                sizeof(strresult));\n        goto bailout;\n    }\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n        numresult = KRB5_KPASSWD_BAD_VERSION;\n        snprintf(strresult, sizeof(strresult),\n                 \"Request contained unknown protocol version number %d\", vno);\n        goto bailout;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                sizeof(strresult));\n        goto bailout;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}","idx":18,"name":"process_chpw_request","project":"164057968633021","target":"False"}
{"commit_id":"152480056207824","func":"acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN == 0 || REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}","idx":21,"name":"acc_ctx_cont","project":"179231907027180","target":"False"}
{"commit_id":"64493146412465","func":"kadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd, n_new_keys;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        /* Return only the new keys added by krb5_dbe_crk. */\n        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);\n        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}","idx":23,"name":"kadm5_randkey_principal_3","project":"201249276304048","target":"False"}
{"commit_id":"225137396417931","func":"count_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}","idx":24,"name":"count_new_keys","project":"201249276304048","target":"False"}
{"commit_id":"28782051362152","func":"krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent == NULL) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n    st = populate_policy(context, ld, ent, pol_name, *policy);\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}","idx":26,"name":"krb5_ldap_get_password_policy_from_dn","project":"48691161838925","target":"False"}
{"commit_id":"51705496518136","func":"krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone_prinicipal=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone_prinicipal true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone_prinicipal = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_prependmsg(context, ost, st, _(\"'%s' not found\"),\n                                  xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone_prinicipal to TRUE\n         */\n        create_standalone_prinicipal = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone_prinicipal) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            for (j = 0; ber_tl_data[j] != NULL; j++) {\n                free(ber_tl_data[j]->bv_val);\n                free(ber_tl_data[j]);\n            }\n            free(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone_prinicipal == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}","idx":29,"name":"krb5_ldap_put_principal","project":"195215522746497","target":"False"}
{"commit_id":"76447080336512","func":"krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data = NULL;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; ret[i] != NULL; i++)\n                free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}","idx":30,"name":"krb5_encode_krbsecretkey","project":"195215522746497","target":"False"}
{"commit_id":"213457298310661","func":"krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}","idx":32,"name":"krb5_gss_context_time","project":"76920291214045","target":"False"}
{"commit_id":"79300881583288","func":"krb5_gss_export_sec_context(minor_status, context_handle, interprocess_token)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        *context_handle;\n    gss_buffer_t        interprocess_token;\n{\n    krb5_context        context = NULL;\n    krb5_error_code     kret;\n    OM_uint32           retval;\n    size_t              bufsize, blen;\n    krb5_gss_ctx_id_t   ctx;\n    krb5_octet          *obuffer, *obp;\n\n    /* Assume a tragic failure */\n    obuffer = (krb5_octet *) NULL;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n\n    ctx = (krb5_gss_ctx_id_t) *context_handle;\n    if (ctx->terminated) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return (GSS_S_NO_CONTEXT);\n    }\n\n    context = ctx->k5_context;\n    kret = krb5_gss_ser_init(context);\n    if (kret)\n        goto error_out;\n\n    /* Determine size needed for externalization of context */\n    bufsize = 0;\n    if ((kret = kg_ctx_size(context, (krb5_pointer) ctx,\n                            &bufsize)))\n        goto error_out;\n\n    /* Allocate the buffer */\n    if ((obuffer = gssalloc_malloc(bufsize)) == NULL) {\n        kret = ENOMEM;\n        goto error_out;\n    }\n\n    obp = obuffer;\n    blen = bufsize;\n    /* Externalize the context */\n    if ((kret = kg_ctx_externalize(context,\n                                   (krb5_pointer) ctx, &obp, &blen)))\n        goto error_out;\n\n    /* Success!  Return the buffer */\n    interprocess_token->length = bufsize - blen;\n    interprocess_token->value = obuffer;\n    *minor_status = 0;\n    retval = GSS_S_COMPLETE;\n\n    /* Now, clean up the context state */\n    (void)krb5_gss_delete_sec_context(minor_status, context_handle, NULL);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n\nerror_out:\n    if (retval != GSS_S_COMPLETE)\n        if (kret != 0 && context != 0)\n            save_error_info((OM_uint32)kret, context);\n    if (obuffer && bufsize) {\n        memset(obuffer, 0, bufsize);\n        xfree(obuffer);\n    }\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}","idx":33,"name":"krb5_gss_export_sec_context","project":"57809759647792","target":"False"}
{"commit_id":"154871248406465","func":"krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}","idx":35,"name":"krb5_gss_inquire_sec_context_by_oid","project":"151992082495004","target":"False"}
{"commit_id":"274619193505484","func":"krb5_gss_inquire_context(minor_status, context_handle, initiator_name,\n                         acceptor_name, lifetime_rec, mech_type, ret_flags,\n                         locally_initiated, opened)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_name_t *initiator_name;\n    gss_name_t *acceptor_name;\n    OM_uint32 *lifetime_rec;\n    gss_OID *mech_type;\n    OM_uint32 *ret_flags;\n    int *locally_initiated;\n    int *opened;\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_gss_name_t initiator, acceptor;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    if (initiator_name)\n        *initiator_name = (gss_name_t) NULL;\n    if (acceptor_name)\n        *acceptor_name = (gss_name_t) NULL;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    initiator = NULL;\n    acceptor = NULL;\n    context = ctx->k5_context;\n\n    if ((code = krb5_timeofday(context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) < 0)\n        lifetime = 0;\n\n    if (initiator_name) {\n        if ((code = kg_duplicate_name(context,\n                                      ctx->initiate ? ctx->here : ctx->there,\n                                      &initiator))) {\n            *minor_status = code;\n            save_error_info(*minor_status, context);\n            return(GSS_S_FAILURE);\n        }\n    }\n\n    if (acceptor_name) {\n        if ((code = kg_duplicate_name(context,\n                                      ctx->initiate ? ctx->there : ctx->here,\n                                      &acceptor))) {\n            if (initiator)\n                kg_release_name(context, &initiator);\n            *minor_status = code;\n            save_error_info(*minor_status, context);\n            return(GSS_S_FAILURE);\n        }\n    }\n\n    if (initiator_name)\n        *initiator_name = (gss_name_t) initiator;\n\n    if (acceptor_name)\n        *acceptor_name = (gss_name_t) acceptor;\n\n    if (lifetime_rec)\n        *lifetime_rec = lifetime;\n\n    if (mech_type)\n        *mech_type = (gss_OID) ctx->mech_used;\n\n    if (ret_flags)\n        *ret_flags = ctx->gss_flags;\n\n    if (locally_initiated)\n        *locally_initiated = ctx->initiate;\n\n    if (opened)\n        *opened = ctx->established;\n\n    *minor_status = 0;\n    return((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);\n}","idx":37,"name":"krb5_gss_inquire_context","project":"147023369416402","target":"False"}
{"commit_id":"258672200257141","func":"kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n\n    /* Only default qop or matching established cryptosystem is allowed.\n\n       There are NO EXTENSIONS to this set for AES and friends!  The\n       new spec says \"just use 0\".  The old spec plus extensions would\n       actually allow for certain non-zero values.  Fix this to handle\n       them later.  */\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   /* XXX */\n        break;\n    }\n\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n\n    if (conf_state)\n        *conf_state = conf_req_flag;\n\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}","idx":39,"name":"kg_seal","project":"198506424303793","target":"False"}
{"commit_id":"247471465384412","func":"kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        /* may be more sensible to return an error here */\n        conf_req_flag = FALSE;\n    }\n\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n\n    *minor_status = 0;\n\n    return GSS_S_COMPLETE;\n}","idx":41,"name":"kg_seal_iov","project":"122861386712099","target":"False"}
{"commit_id":"180488834397578","func":"kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}","idx":43,"name":"kg_unseal","project":"198654895410094","target":"False"}
{"commit_id":"171022484185995","func":"kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}","idx":45,"name":"kg_unseal_iov","project":"69888990910426","target":"False"}
{"commit_id":"199517742439930","func":"gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n\n    /* Assume failure */\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &version);\n    if (GSS_ERROR(retval))\n        return retval;\n\n    /* Externalize a structure of the right version */\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n\n    if (kret)\n        goto error_out;\n\n    rep.value = &lctx;\n    rep.length = sizeof(lctx);\n\n    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\n\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}","idx":46,"name":"gss_krb5int_export_lucid_sec_context","project":"178784926237334","target":"False"}
{"commit_id":"139782120106329","func":"krb5_gss_pseudo_random(OM_uint32 *minor_status,\n                       gss_ctx_id_t context,\n                       int prf_key,\n                       const gss_buffer_t prf_in,\n                       ssize_t desired_output_len,\n                       gss_buffer_t prf_out)\n{\n    krb5_error_code code;\n    krb5_key key = NULL;\n    krb5_gss_ctx_id_t ctx;\n    int i;\n    OM_uint32 minor;\n    size_t prflen;\n    krb5_data t, ns;\n    unsigned char *p;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    t.length = 0;\n    t.data = NULL;\n\n    ns.length = 0;\n    ns.data = NULL;\n\n    ctx = (krb5_gss_ctx_id_t)context;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    switch (prf_key) {\n    case GSS_C_PRF_KEY_FULL:\n        if (ctx->have_acceptor_subkey) {\n            key = ctx->acceptor_subkey;\n            break;\n        }\n        /* fallthrough */\n    case GSS_C_PRF_KEY_PARTIAL:\n        key = ctx->subkey;\n        break;\n    default:\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if (key == NULL) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    if (desired_output_len == 0)\n        return GSS_S_COMPLETE;\n\n    prf_out->value = k5alloc(desired_output_len, &code);\n    if (prf_out->value == NULL) {\n        code = KG_INPUT_TOO_LONG;\n        goto cleanup;\n    }\n    prf_out->length = desired_output_len;\n\n    code = krb5_c_prf_length(ctx->k5_context,\n                             krb5_k_key_enctype(ctx->k5_context, key),\n                             &prflen);\n    if (code != 0)\n        goto cleanup;\n\n    ns.length = 4 + prf_in->length;\n    ns.data = k5alloc(ns.length, &code);\n    if (ns.data == NULL) {\n        code = KG_INPUT_TOO_LONG;\n        goto cleanup;\n    }\n\n    t.length = prflen;\n    t.data = k5alloc(t.length, &code);\n    if (t.data == NULL)\n        goto cleanup;\n\n    memcpy(ns.data + 4, prf_in->value, prf_in->length);\n    i = 0;\n    p = (unsigned char *)prf_out->value;\n    while (desired_output_len > 0) {\n        store_32_be(i, ns.data);\n\n        code = krb5_k_prf(ctx->k5_context, key, &ns, &t);\n        if (code != 0)\n            goto cleanup;\n\n        memcpy(p, t.data, MIN(t.length, desired_output_len));\n\n        p += t.length;\n        desired_output_len -= t.length;\n        i++;\n    }\n\ncleanup:\n    if (code != 0)\n        gss_release_buffer(&minor, prf_out);\n    krb5_free_data_contents(ctx->k5_context, &ns);\n    krb5_free_data_contents(ctx->k5_context, &t);\n\n    *minor_status = (OM_uint32)code;\n    return (code == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}","idx":47,"name":"krb5_gss_pseudo_random","project":"53067322985547","target":"False"}
{"commit_id":"115509366190861","func":"krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* We only support context deletion tokens for now, and RFC 4121 does not\n     * define a context deletion token. */\n    if (ctx->proto) {\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n    }\n\n    /* \"unseal\" the token */\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n    /* Mark the context as terminated, but do not delete it (as that would\n     * leave the caller with a dangling context handle). */\n    ctx->terminated = 1;\n    return(GSS_S_COMPLETE);\n}","idx":49,"name":"krb5_gss_process_context_token","project":"94226547393645","target":"False"}
{"commit_id":"174611794660283","func":"krb5_gss_wrap_size_limit(minor_status, context_handle, conf_req_flag,\n                         qop_req, req_output_size, max_input_size)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    int                 conf_req_flag;\n    gss_qop_t           qop_req;\n    OM_uint32           req_output_size;\n    OM_uint32           *max_input_size;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32           data_size, conflen;\n    OM_uint32           ohlen;\n    int                 overhead;\n\n    /* only default qop is allowed */\n    if (qop_req != GSS_C_QOP_DEFAULT) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return(GSS_S_FAILURE);\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if (ctx->proto == 1) {\n        /* No pseudo-ASN.1 wrapper overhead, so no sequence length and\n           OID.  */\n        OM_uint32 sz = req_output_size;\n\n        /* Token header: 16 octets.  */\n        if (conf_req_flag) {\n            krb5_key key;\n            krb5_enctype enctype;\n\n            key = ctx->have_acceptor_subkey ? ctx->acceptor_subkey\n                : ctx->subkey;\n            enctype = key->keyblock.enctype;\n\n            while (sz > 0 && krb5_encrypt_size(sz, enctype) + 16 > req_output_size)\n                sz--;\n            /* Allow for encrypted copy of header.  */\n            if (sz > 16)\n                sz -= 16;\n            else\n                sz = 0;\n#ifdef CFX_EXERCISE\n            /* Allow for EC padding.  In the MIT implementation, only\n               added while testing.  */\n            if (sz > 65535)\n                sz -= 65535;\n            else\n                sz = 0;\n#endif\n        } else {\n            krb5_cksumtype cksumtype;\n            krb5_error_code err;\n            size_t cksumsize;\n\n            cksumtype = ctx->have_acceptor_subkey ? ctx->acceptor_subkey_cksumtype\n                : ctx->cksumtype;\n\n            err = krb5_c_checksum_length(ctx->k5_context, cksumtype, &cksumsize);\n            if (err) {\n                *minor_status = err;\n                return GSS_S_FAILURE;\n            }\n\n            /* Allow for token header and checksum.  */\n            if (sz < 16 + cksumsize)\n                sz = 0;\n            else\n                sz -= (16 + cksumsize);\n        }\n\n        *max_input_size = sz;\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    /* Calculate the token size and subtract that from the output size */\n    overhead = 7 + ctx->mech_used->length;\n    data_size = req_output_size;\n    conflen = kg_confounder_size(ctx->k5_context, ctx->enc->keyblock.enctype);\n    data_size = (conflen + data_size + 8) & (~(OM_uint32)7);\n    ohlen = g_token_size(ctx->mech_used,\n                         (unsigned int) (data_size + ctx->cksum_size + 14))\n        - req_output_size;\n\n    if (ohlen+overhead < req_output_size)\n        /*\n         * Cannot have trailer length that will cause us to pad over our\n         * length.\n         */\n        *max_input_size = (req_output_size - ohlen - overhead) & (~(OM_uint32)7);\n    else\n        *max_input_size = 0;\n\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}","idx":51,"name":"krb5_gss_wrap_size_limit","project":"27370316410071","target":"False"}
{"commit_id":"24144705174026","func":"main(int argc, char *argv[])\n{\n    OM_uint32 minor, major;\n    gss_ctx_id_t context;\n    gss_union_ctx_id_desc uctx;\n    krb5_gss_ctx_id_rec kgctx;\n    krb5_key k1, k2;\n    krb5_keyblock kb1, kb2;\n    gss_buffer_desc in, out;\n    unsigned char k1buf[32], k2buf[32], outbuf[44];\n    size_t i;\n\n    /*\n     * Fake up just enough of a krb5 GSS context to make gss_pseudo_random\n     * work, with chosen subkeys and acceptor subkeys.  If we implement\n     * gss_import_lucid_sec_context, we can rewrite this to use public\n     * interfaces and stop using private headers and internal knowledge of the\n     * implementation.\n     */\n    context = (gss_ctx_id_t)&uctx;\n    uctx.mech_type = &mech_krb5;\n    uctx.internal_ctx_id = (gss_ctx_id_t)&kgctx;\n    kgctx.k5_context = NULL;\n    kgctx.established = 1;\n    kgctx.have_acceptor_subkey = 1;\n    kb1.contents = k1buf;\n    kb2.contents = k2buf;\n    for (i = 0; i < sizeof(tests) / sizeof(*tests); i++) {\n        /* Set up the keys for this test. */\n        kb1.enctype = tests[i].enctype;\n        kb1.length = fromhex(tests[i].key1, k1buf);\n        check_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb1, &k1));\n        kgctx.subkey = k1;\n        kb2.enctype = tests[i].enctype;\n        kb2.length = fromhex(tests[i].key2, k2buf);\n        check_k5err(NULL, \"create_key\", krb5_k_create_key(NULL, &kb2, &k2));\n        kgctx.acceptor_subkey = k2;\n\n        /* Generate a PRF value with the subkey and an empty input, and compare\n         * it to the first expected output. */\n        in.length = 0;\n        in.value = NULL;\n        major = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_PARTIAL, &in,\n                                  44, &out);\n        check_gsserr(\"gss_pseudo_random\", major, minor);\n        (void)fromhex(tests[i].out1, outbuf);\n        assert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n        (void)gss_release_buffer(&minor, &out);\n\n        /* Generate a PRF value with the acceptor subkey and the 61-byte input\n         * string, and compare it to the second expected output. */\n        in.length = strlen(inputstr);\n        in.value = (char *)inputstr;\n        major = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 44,\n                                  &out);\n        check_gsserr(\"gss_pseudo_random\", major, minor);\n        (void)fromhex(tests[i].out2, outbuf);\n        assert(out.length == 44 && memcmp(out.value, outbuf, 44) == 0);\n        (void)gss_release_buffer(&minor, &out);\n\n        /* Also check that generating zero bytes of output works. */\n        major = gss_pseudo_random(&minor, context, GSS_C_PRF_KEY_FULL, &in, 0,\n                                  &out);\n        check_gsserr(\"gss_pseudo_random\", major, minor);\n        assert(out.length == 0);\n        (void)gss_release_buffer(&minor, &out);\n\n        krb5_k_free_key(NULL, k1);\n        krb5_k_free_key(NULL, k2);\n    }\n    return 0;\n}","idx":52,"name":"main","project":"23151462699928","target":"False"}
{"commit_id":"94369985347198","func":"xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n    /* using a static context here is ugly, but should work\n       ok, and the other solutions are even uglier */\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}","idx":53,"name":"xdr_krb5_principal","project":"212333665348677","target":"False"}
{"commit_id":"73669460116876","func":"bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}","idx":54,"name":"xdr_krb5_tl_data","project":"212333665348677","target":"False"}
{"commit_id":"246315469895427","func":"check_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n     size_t slen;\n     char *sdots;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, _(\"check_rpcsec_auth: failed \"\n\t\t\t\t      \"inquire_context, stat=%u\"), maj_stat);\n\t  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     slen = gss_str.length;\n     trunc_name(&slen, &sdots);\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     success = data_eq_string(*realm, handle->params.realm) &&\n\t     data_eq_string(*c1, \"kadmin\") && !data_eq_string(*c2, \"history\");\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, _(\"bad service principal %.*s%s\"),\n\t\t\t  (int) slen, (char *) gss_str.value, sdots);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}","idx":57,"name":"check_rpcsec_auth","project":"35933147970536","target":"False"}
{"commit_id":"57552749227200","func":"svcauth_gss_accept_sec_context(struct svc_req *rqst,\n\t\t\t       struct rpc_gss_init_res *gr)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tgss_buffer_desc\t\t recv_tok, seqbuf;\n\tgss_OID\t\t\t mech;\n\tOM_uint32\t\t maj_stat = 0, min_stat = 0, ret_flags, seq;\n\n\tlog_debug(\"in svcauth_gss_accept_context()\");\n\n\tgd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\tgc = (struct rpc_gss_cred *)rqst->rq_clntcred;\n\tmemset(gr, 0, sizeof(*gr));\n\n\t/* Deserialize arguments. */\n\tmemset(&recv_tok, 0, sizeof(recv_tok));\n\n\tif (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,\n\t\t\t (caddr_t)&recv_tok))\n\t\treturn (FALSE);\n\n\tgr->gr_major = gss_accept_sec_context(&gr->gr_minor,\n\t\t\t\t\t      &gd->ctx,\n\t\t\t\t\t      svcauth_gss_creds,\n\t\t\t\t\t      &recv_tok,\n\t\t\t\t\t      GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t      &gd->client_name,\n\t\t\t\t\t      &mech,\n\t\t\t\t\t      &gr->gr_token,\n\t\t\t\t\t      &ret_flags,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL);\n\n\tsvc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);\n\n\tlog_status(\"accept_sec_context\", gr->gr_major, gr->gr_minor);\n\tif (gr->gr_major != GSS_S_COMPLETE &&\n\t    gr->gr_major != GSS_S_CONTINUE_NEEDED) {\n\t\tbadauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);\n\t\tgd->ctx = GSS_C_NO_CONTEXT;\n\t\tgoto errout;\n\t}\n\tgr->gr_ctx.value = \"xxxx\";\n\tgr->gr_ctx.length = 4;\n\n\t/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n\tgr->gr_win = sizeof(gd->seqmask) * 8;\n\n\t/* Save client info. */\n\tgd->sec.mech = mech;\n\tgd->sec.qop = GSS_C_QOP_DEFAULT;\n\tgd->sec.svc = gc->gc_svc;\n\tgd->seq = gc->gc_seq;\n\tgd->win = gr->gr_win;\n\n\tif (gr->gr_major == GSS_S_COMPLETE) {\n#ifdef SPKM\n\t\t/* spkm3: no src_name (anonymous) */\n\t\tif(!g_OID_equal(gss_mech_spkm3, mech)) {\n#endif\n\t\t    maj_stat = gss_display_name(&min_stat, gd->client_name,\n\t\t\t\t\t    &gd->cname, &gd->sec.mech);\n#ifdef SPKM\n\t\t}\n#endif\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tlog_status(\"display_name\", maj_stat, min_stat);\n\t\t\tgoto errout;\n\t\t}\n#ifdef DEBUG\n#ifdef HAVE_HEIMDAL\n\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t  \"<mech {}, qop %d, svc %d>\",\n\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t  gd->sec.qop, gd->sec.svc);\n#else\n\t\t{\n\t\t\tgss_buffer_desc mechname;\n\n\t\t\tgss_oid_to_str(&min_stat, mech, &mechname);\n\n\t\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t\t  \"<mech %.*s, qop %d, svc %d>\",\n\t\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t\t  mechname.length, (char *)mechname.value,\n\t\t\t\t  gd->sec.qop, gd->sec.svc);\n\n\t\t\tgss_release_buffer(&min_stat, &mechname);\n\t\t}\n#endif\n#endif /* DEBUG */\n\t\tseq = htonl(gr->gr_win);\n\t\tseqbuf.value = &seq;\n\t\tseqbuf.length = sizeof(seq);\n\n\t\tgss_release_buffer(&min_stat, &gd->checksum);\n\t\tmaj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,\n\t\t\t\t    &seqbuf, &gd->checksum);\n\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tgoto errout;\n\t\t}\n\n\n\t\trqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;\n\t\trqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;\n\t\trqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;\n\t}\n\treturn (TRUE);\nerrout:\n\tgss_release_buffer(&min_stat, &gr->gr_token);\n\treturn (FALSE);\n}","idx":60,"name":"svcauth_gss_accept_sec_context","project":"55746502349949","target":"False"}
{"commit_id":"62582007298999","func":"int main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_data pname_data, tkt_data;\n    int sock = 0;\n    socklen_t l;\n    int retval;\n    struct sockaddr_in l_inaddr, f_inaddr;        /* local, foreign address */\n    krb5_creds creds, *new_creds;\n    krb5_ccache cc;\n    krb5_data msgtext, msg;\n    krb5_context context;\n    krb5_auth_context auth_context = NULL;\n\n#ifndef DEBUG\n    freopen(\"/tmp/uu-server.log\", \"w\", stderr);\n#endif\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n        exit(1);\n    }\n\n#ifdef DEBUG\n    {\n        int one = 1;\n        int acc;\n        struct servent *sp;\n        socklen_t namelen = sizeof(f_inaddr);\n\n        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n            com_err(\"uu-server\", errno, \"creating socket\");\n            exit(3);\n        }\n\n        l_inaddr.sin_family = AF_INET;\n        l_inaddr.sin_addr.s_addr = 0;\n        if (argc == 2) {\n            l_inaddr.sin_port = htons(atoi(argv[1]));\n        } else  {\n            if (!(sp = getservbyname(\"uu-sample\", \"tcp\"))) {\n                com_err(\"uu-server\", 0, \"can't find uu-sample/tcp service\");\n                exit(3);\n            }\n            l_inaddr.sin_port = sp->s_port;\n        }\n\n        (void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (one));\n        if (bind(sock, (struct sockaddr *)&l_inaddr, sizeof(l_inaddr))) {\n            com_err(\"uu-server\", errno, \"binding socket\");\n            exit(3);\n        }\n        if (listen(sock, 1) == -1) {\n            com_err(\"uu-server\", errno, \"listening\");\n            exit(3);\n        }\n\n        printf(\"Server started\\n\");\n        fflush(stdout);\n\n        if ((acc = accept(sock, (struct sockaddr *)&f_inaddr, &namelen)) == -1) {\n            com_err(\"uu-server\", errno, \"accepting\");\n            exit(3);\n        }\n        dup2(acc, 0);\n        close(sock);\n        sock = 0;\n    }\n#endif\n\n    /* principal name must be sent null-terminated. */\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);\n    if (retval || pname_data.length == 0 ||\n        pname_data.data[pname_data.length - 1] != '\\0') {\n        com_err (\"uu-server\", retval, \"reading pname\");\n        return 2;\n    }\n\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &tkt_data);\n    if (retval) {\n        com_err (\"uu-server\", retval, \"reading ticket data\");\n        return 2;\n    }\n\n    retval = krb5_cc_default(context, &cc);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting credentials cache\");\n        return 4;\n    }\n\n    memset (&creds, 0, sizeof(creds));\n    retval = krb5_cc_get_principal(context, cc, &creds.client);\n    if (retval) {\n        com_err(\"uu-client\", retval, \"getting principal name\");\n        return 6;\n    }\n\n    /* client sends it already null-terminated. */\n    printf (\"uu-server: client principal is \\\"%s\\\".\\n\", pname_data.data);\n\n    retval = krb5_parse_name(context, pname_data.data, &creds.server);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"parsing client name\");\n        return 3;\n    }\n\n    creds.second_ticket = tkt_data;\n    printf (\"uu-server: client ticket is %d bytes.\\n\",\n            creds.second_ticket.length);\n\n    retval = krb5_get_credentials(context, KRB5_GC_USER_USER, cc,\n                                  &creds, &new_creds);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting user-user ticket\");\n        return 5;\n    }\n\n#ifndef DEBUG\n    l = sizeof(f_inaddr);\n    if (getpeername(0, (struct sockaddr *)&f_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting client address\");\n        return 6;\n    }\n#endif\n    l = sizeof(l_inaddr);\n    if (getsockname(0, (struct sockaddr *)&l_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting local address\");\n        return 6;\n    }\n\n    /* send a ticket/authenticator to the other side, so it can get the key\n       we're using for the krb_safe below. */\n\n    retval = krb5_auth_con_init(context, &auth_context);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making auth_context\");\n        return 8;\n    }\n\n    retval = krb5_auth_con_setflags(context, auth_context,\n                                    KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"initializing the auth_context flags\");\n        return 8;\n    }\n\n    retval =\n        krb5_auth_con_genaddrs(context, auth_context, sock,\n                               KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR |\n                               KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"generating addrs for auth_context\");\n        return 9;\n    }\n\n#if 1\n    retval = krb5_mk_req_extended(context, &auth_context,\n                                  AP_OPTS_USE_SESSION_KEY,\n                                  NULL, new_creds, &msg);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making AP_REQ\");\n        return 8;\n    }\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n#else\n    retval = krb5_sendauth(context, &auth_context, (krb5_pointer)&sock, \"???\",\n                           0, 0,\n                           AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY,\n                           NULL, &creds, cc, NULL, NULL, NULL);\n#endif\n    if (retval)\n        goto cl_short_wrt;\n\n    free(msg.data);\n\n    msgtext.length = 32;\n    msgtext.data = \"Hello, other end of connection.\";\n\n    retval = krb5_mk_safe(context, auth_context, &msgtext, &msg, NULL);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"encoding message to client\");\n        return 6;\n    }\n\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n    if (retval) {\n    cl_short_wrt:\n        com_err(\"uu-server\", retval, \"writing message to client\");\n        return 7;\n    }\n\n\n    krb5_free_data_contents(context, &msg);\n    krb5_free_data_contents(context, &pname_data);\n    /* tkt_data freed with creds */\n    krb5_free_cred_contents(context, &creds);\n    krb5_free_creds(context, new_creds);\n    krb5_cc_close(context, cc);\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_context(context);\n    return 0;\n}","idx":62,"name":"main","project":"38219574549481","target":"False"}
{"commit_id":"237409378228951","func":"recvauth_common(krb5_context context,\n                krb5_auth_context * auth_context,\n                /* IN */\n                krb5_pointer fd,\n                char *appl_version,\n                krb5_principal server,\n                krb5_int32 flags,\n                krb5_keytab keytab,\n                /* OUT */\n                krb5_ticket ** ticket,\n                krb5_data *version)\n{\n    krb5_auth_context     new_auth_context;\n    krb5_flags            ap_option = 0;\n    krb5_error_code       retval, problem;\n    krb5_data             inbuf;\n    krb5_data             outbuf;\n    krb5_rcache           rcache = 0;\n    krb5_octet            response;\n    krb5_data             null_server;\n    krb5_data             d;\n    int                   need_error_free = 0;\n    int                   local_rcache = 0, local_authcon = 0;\n\n    /*\n     * Zero out problem variable.  If problem is set at the end of\n     * the intial version negotiation section, it means that we\n     * need to send an error code back to the client application\n     * and exit.\n     */\n    problem = 0;\n    response = 0;\n\n    if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {\n        /*\n         * First read the sendauth version string and check it.\n         */\n        if ((retval = krb5_read_message(context, fd, &inbuf)))\n            return(retval);\n        d = make_data((char *)sendauth_version, strlen(sendauth_version) + 1);\n        if (!data_eq(inbuf, d)) {\n            problem = KRB5_SENDAUTH_BADAUTHVERS;\n            response = 1;\n        }\n        free(inbuf.data);\n    }\n    if (flags & KRB5_RECVAUTH_BADAUTHVERS) {\n        problem = KRB5_SENDAUTH_BADAUTHVERS;\n        response = 1;\n    }\n\n    /*\n     * Do the same thing for the application version string.\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return(retval);\n    if (appl_version != NULL && !problem) {\n        d = make_data(appl_version, strlen(appl_version) + 1);\n        if (!data_eq(inbuf, d)) {\n            problem = KRB5_SENDAUTH_BADAPPLVERS;\n            response = 2;\n        }\n    }\n    if (version && !problem)\n        *version = inbuf;\n    else\n        free(inbuf.data);\n\n    /*\n     * Now we actually write the response.  If the response is non-zero,\n     * exit with a return value of problem\n     */\n    if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {\n        return(problem); /* We'll return the top-level problem */\n    }\n    if (problem)\n        return(problem);\n\n    /* We are clear of errors here */\n\n    /*\n     * Now, let's read the AP_REQ message and decode it\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return retval;\n\n    if (*auth_context == NULL) {\n        problem = krb5_auth_con_init(context, &new_auth_context);\n        *auth_context = new_auth_context;\n        local_authcon = 1;\n    }\n    krb5_auth_con_getrcache(context, *auth_context, &rcache);\n    if ((!problem) && rcache == NULL) {\n        /*\n         * Setup the replay cache.\n         */\n        if (server != NULL && server->length > 0) {\n            problem = krb5_get_server_rcache(context, &server->data[0],\n                                             &rcache);\n        } else {\n            null_server.length = 7;\n            null_server.data = \"default\";\n            problem = krb5_get_server_rcache(context, &null_server, &rcache);\n        }\n        if (!problem)\n            problem = krb5_auth_con_setrcache(context, *auth_context, rcache);\n        local_rcache = 1;\n    }\n    if (!problem) {\n        problem = krb5_rd_req(context, auth_context, &inbuf, server,\n                              keytab, &ap_option, ticket);\n        free(inbuf.data);\n    }\n\n    /*\n     * If there was a problem, send back a krb5_error message,\n     * preceeded by the length of the krb5_error message.  If\n     * everything's ok, send back 0 for the length.\n     */\n    if (problem) {\n        krb5_error      error;\n        const   char *message;\n\n        memset(&error, 0, sizeof(error));\n        krb5_us_timeofday(context, &error.stime, &error.susec);\n        if(server)\n            error.server = server;\n        else {\n            /* If this fails - ie. ENOMEM we are hosed\n               we cannot even send the error if we wanted to... */\n            (void) krb5_parse_name(context, \"????\", &error.server);\n            need_error_free = 1;\n        }\n\n        error.error = problem - ERROR_TABLE_BASE_krb5;\n        if (error.error > 127)\n            error.error = KRB_ERR_GENERIC;\n        message = error_message(problem);\n        error.text.length  = strlen(message) + 1;\n        error.text.data = strdup(message);\n        if (!error.text.data) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        if ((retval = krb5_mk_error(context, &error, &outbuf))) {\n            free(error.text.data);\n            goto cleanup;\n        }\n        free(error.text.data);\n        if(need_error_free)\n            krb5_free_principal(context, error.server);\n\n    } else {\n        outbuf.length = 0;\n        outbuf.data = 0;\n    }\n\n    retval = krb5_write_message(context, fd, &outbuf);\n    if (outbuf.data) {\n        free(outbuf.data);\n        /* We sent back an error, we need cleanup then return */\n        retval = problem;\n        goto cleanup;\n    }\n    if (retval)\n        goto cleanup;\n\n    /* Here lies the mutual authentication stuff... */\n    if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {\n        if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {\n            return(retval);\n        }\n        retval = krb5_write_message(context, fd, &outbuf);\n        free(outbuf.data);\n    }\n\ncleanup:;\n    if (retval) {\n        if (local_authcon) {\n            krb5_auth_con_free(context, *auth_context);\n        } else if (local_rcache && rcache != NULL) {\n            krb5_rc_close(context, rcache);\n            krb5_auth_con_setrcache(context, *auth_context, NULL);\n        }\n    }\n    return retval;\n}","idx":64,"name":"recvauth_common","project":"235879110642374","target":"False"}
{"commit_id":"185863281464811","func":"on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n\n    free(data);\n\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}","idx":66,"name":"on_response","project":"139763343306592","target":"False"}
{"commit_id":"186844552657926","func":"otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n           krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *pa,\n           krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n           krb5_kdcpreauth_moddata moddata,\n           krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_keyblock *armor_key = NULL;\n    krb5_pa_otp_req *req = NULL;\n    struct request_state *rs;\n    krb5_error_code retval;\n    krb5_data d, plaintext;\n    char *config;\n\n    /* Get the FAST armor key. */\n    armor_key = cb->fast_armor(context, rock);\n    if (armor_key == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        com_err(\"otp\", retval, \"No armor key found when verifying padata\");\n        goto error;\n    }\n\n    /* Decode the request. */\n    d = make_data(pa->contents, pa->length);\n    retval = decode_krb5_pa_otp_req(&d, &req);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to decode OTP request\");\n        goto error;\n    }\n\n    /* Decrypt the nonce from the request. */\n    retval = decrypt_encdata(context, armor_key, req, &plaintext);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to decrypt nonce\");\n        goto error;\n    }\n\n    /* Verify the nonce or timestamp. */\n    retval = nonce_verify(context, armor_key, &plaintext);\n    if (retval != 0)\n        retval = timestamp_verify(context, &plaintext);\n    krb5_free_data_contents(context, &plaintext);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to verify nonce or timestamp\");\n        goto error;\n    }\n\n    /* Create the request state.  Save the response callback, and the\n     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. */\n    rs = k5alloc(sizeof(struct request_state), &retval);\n    if (rs == NULL)\n        goto error;\n    rs->arg = arg;\n    rs->respond = respond;\n    rs->enc_tkt_reply = enc_tkt_reply;\n\n    /* Get the principal's OTP configuration string. */\n    retval = cb->get_string(context, rock, \"otp\", &config);\n    if (retval == 0 && config == NULL)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval != 0) {\n        free(rs);\n        goto error;\n    }\n\n    /* Send the request. */\n    otp_state_verify((otp_state *)moddata, cb->event_context(context, rock),\n                     request->client, config, req, on_response, rs);\n    cb->free_string(context, rock, config);\n\n    k5_free_pa_otp_req(context, req);\n    return;\n\nerror:\n    k5_free_pa_otp_req(context, req);\n    (*respond)(arg, retval, NULL, NULL, NULL);\n}","idx":67,"name":"otp_verify","project":"139763343306592","target":"False"}
{"commit_id":"278980283786827","func":"pkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n\n    pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n    if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        retval = krb5_check_clockskew(context,\n                                      auth_pack->pkAuthenticator.ctime);\n        if (retval)\n            goto cleanup;\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            k5_bcmp(cksum.contents,\n                    auth_pack->pkAuthenticator.paChecksum.contents,\n                    cksum.length) != 0) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           (unsigned char *)reqp->kdcPkId.data,\n                                           reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    free_krb5_auth_pack(&auth_pack);\n    free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}","idx":69,"name":"pkinit_server_verify_padata","project":"114623562961833","target":"False"}
{"commit_id":"272734082889588","func":"spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}","idx":99,"name":"spnego_gss_wrap_aead","project":"180227160492611","target":"False"}
{"commit_id":"260329484480565","func":"spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n\n\t/* We don't currently support exporting partially established\n\t * contexts. */\n\tif (!sc->opened)\n\t\treturn GSS_S_UNAVAILABLE;\n\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    &sc->ctx_handle,\n\t\t\t\t    interprocess_token);\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n\t\trelease_spnego_ctx(&sc);\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\treturn (ret);\n}","idx":100,"name":"spnego_gss_export_sec_context","project":"180227160492611","target":"False"}
{"commit_id":"244751002738026","func":"acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}","idx":101,"name":"acc_ctx_hints","project":"180227160492611","target":"False"}
{"commit_id":"90228842991403","func":"spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap(minor_status,\n\t\t    sc->ctx_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}","idx":102,"name":"spnego_gss_wrap","project":"180227160492611","target":"False"}
{"commit_id":"108066304931614","func":"spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n\t\t\t      iov_count);\n}","idx":103,"name":"spnego_gss_verify_mic_iov","project":"180227160492611","target":"False"}
{"commit_id":"268402273658113","func":"spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\t/* There are no SPNEGO-specific OIDs for this function. */\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}","idx":104,"name":"spnego_gss_inquire_sec_context_by_oid","project":"180227160492611","target":"False"}
{"commit_id":"23441162058371","func":"spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\t/* SPNEGO doesn't have its own context tokens. */\n\tif (!sc->opened)\n\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tsc->ctx_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}","idx":105,"name":"spnego_gss_process_context_token","project":"180227160492611","target":"False"}
{"commit_id":"182287185007117","func":"spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      sc->ctx_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}","idx":106,"name":"spnego_gss_unwrap_aead","project":"180227160492611","target":"False"}
{"commit_id":"227251271466548","func":"spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tsc->ctx_handle,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}","idx":107,"name":"spnego_gss_pseudo_random","project":"180227160492611","target":"False"}
{"commit_id":"29909949222400","func":"spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\t/*\n\t * Until we implement partial context exports, there are no SPNEGO\n\t * exported context tokens, only tokens for underlying mechs.  So just\n\t * return an error for now.\n\t */\n\treturn GSS_S_UNAVAILABLE;\n}","idx":108,"name":"spnego_gss_import_sec_context","project":"180227160492611","target":"False"}
{"commit_id":"147379054376412","func":"spnego_gss_init_sec_context(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t claimant_cred_handle,\n\t\t\tgss_ctx_id_t *context_handle,\n\t\t\tgss_name_t target_name,\n\t\t\tgss_OID mech_type,\n\t\t\tOM_uint32 req_flags,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_channel_bindings_t input_chan_bindings,\n\t\t\tgss_buffer_t input_token,\n\t\t\tgss_OID *actual_mech,\n\t\t\tgss_buffer_t output_token,\n\t\t\tOM_uint32 *ret_flags,\n\t\t\tOM_uint32 *time_rec)\n{\n\tsend_token_flag send_token = NO_TOKEN_SEND;\n\tOM_uint32 tmpmin, ret, negState;\n\tgss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\n\tdsyslog(\"Entering init_sec_context\\n\");\n\n\tmechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;\n\tnegState = REJECT;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context\n\t *      function and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * The three steps share responsibility for determining when the\n\t * exchange is complete.  If the selected mech completed in a previous\n\t * call and no MIC exchange is expected, then step 1 will decide.  If\n\t * the selected mech completes in this call and no MIC exchange is\n\t * expected, then step 2 will decide.  If a MIC exchange is expected,\n\t * then step 3 will decide.  If an error occurs in any step, the\n\t * exchange will be aborted, possibly with an error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * send_token is used to indicate what type of token, if any, should be\n\t * generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (actual_mech != NULL)\n\t\t*actual_mech = GSS_C_NO_OID;\n\n\t/* Step 1: perform mechanism negotiation. */\n\tspcred = (spnego_gss_cred_id_t)claimant_cred_handle;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t\tret = init_ctx_new(minor_status, spcred,\n\t\t\t\t   context_handle, &send_token);\n\t\tif (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tret = init_ctx_cont(minor_status, context_handle,\n\t\t\t\t    input_token, &mechtok_in,\n\t\t\t\t    &mechListMIC_in, &negState, &send_token);\n\t\tif (HARD_ERROR(ret)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Step 2: invoke the selected or optimistic mechanism's\n\t * gss_init_sec_context function, if it didn't complete previously. */\n\tspnego_ctx = (spnego_gss_ctx_id_t)*context_handle;\n\tif (!spnego_ctx->mech_complete) {\n\t\tret = init_ctx_call_init(\n\t\t\tminor_status, spnego_ctx, spcred,\n\t\t\ttarget_name, req_flags,\n\t\t\ttime_req, mechtok_in,\n\t\t\tactual_mech, &mechtok_out,\n\t\t\tret_flags, time_rec,\n\t\t\t&negState, &send_token);\n\n\t\t/* Give the mechanism a chance to force a mechlistMIC. */\n\t\tif (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))\n\t\t\tspnego_ctx->mic_reqd = 1;\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&\n\t    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status,\n\t\t\t\t mechListMIC_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t spnego_ctx, &mechListMIC_out,\n\t\t\t\t &negState, &send_token);\n\t}\ncleanup:\n\tif (send_token == INIT_TOKEN_SEND) {\n\t\tif (make_spnego_tokenInit_msg(spnego_ctx,\n\t\t\t\t\t      0,\n\t\t\t\t\t      mechListMIC_out,\n\t\t\t\t\t      req_flags,\n\t\t\t\t\t      &mechtok_out, send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\tspnego_ctx->opened = 1;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mechListMIC_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_in);\n\t\tfree(mechListMIC_in);\n\t}\n\tif (mechListMIC_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_out);\n\t\tfree(mechListMIC_out);\n\t}\n\treturn ret;\n} /* init_sec_context */","idx":109,"name":"spnego_gss_init_sec_context","project":"180227160492611","target":"False"}
{"commit_id":"28235665073821","func":"spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n\n\t/* There are no SPNEGO-specific OIDs for this function, and we cannot\n\t * construct an empty SPNEGO context with it. */\n\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    &sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}","idx":110,"name":"spnego_gss_set_sec_context_option","project":"180227160492611","target":"False"}
{"commit_id":"154884006964823","func":"spnego_gss_accept_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_cred_id_t verifier_cred_handle,\n\t\t\t    gss_buffer_t input_token,\n\t\t\t    gss_channel_bindings_t input_chan_bindings,\n\t\t\t    gss_name_t *src_name,\n\t\t\t    gss_OID *mech_type,\n\t\t\t    gss_buffer_t output_token,\n\t\t\t    OM_uint32 *ret_flags,\n\t\t\t    OM_uint32 *time_rec,\n\t\t\t    gss_cred_id_t *delegated_cred_handle)\n{\n\tOM_uint32 ret, tmpmin, negState;\n\tsend_token_flag return_token;\n\tgss_buffer_t mechtok_in, mic_in, mic_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tint sendTokenInit = 0, tmpret;\n\n\tmechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated mech's gss_accept_sec_context function\n\t *      and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * Step one determines whether the negotiation requires a MIC exchange,\n\t * while steps two and three share responsibility for determining when\n\t * the exchange is complete.  If the selected mech completes in this\n\t * call and no MIC exchange is expected, then step 2 will decide.  If a\n\t * MIC exchange is expected, then step 3 will decide.  If an error\n\t * occurs in any step, the exchange will be aborted, possibly with an\n\t * error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * return_token is used to indicate what type of token, if any, should\n\t * be generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (input_token == GSS_C_NO_BUFFER)\n\t\treturn GSS_S_CALL_INACCESSIBLE_READ;\n\n\t/* Step 1: Perform mechanism negotiation. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\tspcred = (spnego_gss_cred_id_t)verifier_cred_handle;\n\tif (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {\n\t\t/* Process an initial token or request for NegHints. */\n\t\tif (src_name != NULL)\n\t\t\t*src_name = GSS_C_NO_NAME;\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = GSS_C_NO_OID;\n\t\tif (time_rec != NULL)\n\t\t\t*time_rec = 0;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = 0;\n\t\tif (delegated_cred_handle != NULL)\n\t\t\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\t\tif (input_token->length == 0) {\n\t\t\tret = acc_ctx_hints(minor_status,\n\t\t\t\t\t    context_handle, spcred,\n\t\t\t\t\t    &mic_out,\n\t\t\t\t\t    &negState,\n\t\t\t\t\t    &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tsendTokenInit = 1;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t} else {\n\t\t\t/* Can set negState to REQUEST_MIC */\n\t\t\tret = acc_ctx_new(minor_status, input_token,\n\t\t\t\t\t  context_handle, spcred,\n\t\t\t\t\t  &mechtok_in, &mic_in,\n\t\t\t\t\t  &negState, &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else {\n\t\t/* Process a response token.  Can set negState to\n\t\t * ACCEPT_INCOMPLETE. */\n\t\tret = acc_ctx_cont(minor_status, input_token,\n\t\t\t\t   context_handle, &mechtok_in,\n\t\t\t\t   &mic_in, &negState, &return_token);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tgoto cleanup;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\n\t/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context\n\t * function. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\t/*\n\t * Handle mechtok_in and mic_in only if they are\n\t * present in input_token.  If neither is present, whether\n\t * this is an error depends on whether this is the first\n\t * round-trip.  RET is set to a default value according to\n\t * whether it is the first round-trip.\n\t */\n\tif (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {\n\t\tret = acc_ctx_call_acc(minor_status, sc, spcred,\n\t\t\t\t       mechtok_in, mech_type, &mechtok_out,\n\t\t\t\t       ret_flags, time_rec,\n\t\t\t\t       delegated_cred_handle,\n\t\t\t\t       &negState, &return_token);\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && sc->mech_complete &&\n\t    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status, mic_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t sc, &mic_out,\n\t\t\t\t &negState, &return_token);\n\t}\ncleanup:\n\tif (return_token == INIT_TOKEN_SEND && sendTokenInit) {\n\t\tassert(sc != NULL);\n\t\ttmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,\n\t\t\t\t\t\t   GSS_C_NO_BUFFER,\n\t\t\t\t\t\t   return_token, output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t} else if (return_token != NO_TOKEN_SEND &&\n\t\t   return_token != CHECK_MIC) {\n\t\ttmpret = make_spnego_tokenTarg_msg(negState,\n\t\t\t\t\t\t   sc ? sc->internal_mech :\n\t\t\t\t\t\t   GSS_C_NO_OID,\n\t\t\t\t\t\t   &mechtok_out, mic_out,\n\t\t\t\t\t\t   return_token,\n\t\t\t\t\t\t   output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t}\n\tif (ret == GSS_S_COMPLETE) {\n\t\tsc->opened = 1;\n\t\tif (sc->internal_name != GSS_C_NO_NAME &&\n\t\t    src_name != NULL) {\n\t\t\t*src_name = sc->internal_name;\n\t\t\tsc->internal_name = GSS_C_NO_NAME;\n\t\t}\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (sc != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&sc);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_in);\n\t\tfree(mic_in);\n\t}\n\tif (mic_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_out);\n\t\tfree(mic_out);\n\t}\n\treturn ret;\n}","idx":111,"name":"spnego_gss_accept_sec_context","project":"180227160492611","target":"False"}
{"commit_id":"254947600293934","func":"spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}","idx":112,"name":"spnego_gss_get_mic_iov_length","project":"180227160492611","target":"False"}
{"commit_id":"93806032821411","func":"spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (src_name != NULL)\n\t\t*src_name = GSS_C_NO_NAME;\n\tif (targ_name != NULL)\n\t\t*targ_name = GSS_C_NO_NAME;\n\tif (lifetime_rec != NULL)\n\t\t*lifetime_rec = 0;\n\tif (mech_type != NULL)\n\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\tif (ctx_flags != NULL)\n\t\t*ctx_flags = 0;\n\tif (locally_initiated != NULL)\n\t\t*locally_initiated = sc->initiate;\n\tif (opened != NULL)\n\t\t*opened = sc->opened;\n\n\tif (sc->ctx_handle != GSS_C_NO_CONTEXT) {\n\t\tret = gss_inquire_context(minor_status, sc->ctx_handle,\n\t\t\t\t\t  src_name, targ_name, lifetime_rec,\n\t\t\t\t\t  mech_type, ctx_flags, NULL, NULL);\n\t}\n\n\tif (!sc->opened) {\n\t\t/*\n\t\t * We are still doing SPNEGO negotiation, so report SPNEGO as\n\t\t * the OID.  After negotiation is complete we will report the\n\t\t * underlying mechanism OID.\n\t\t */\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\n\t\t/*\n\t\t * Remove flags we don't support with partially-established\n\t\t * contexts.  (Change this to keep GSS_C_TRANS_FLAG if we add\n\t\t * support for exporting partial SPNEGO contexts.)\n\t\t */\n\t\tif (ctx_flags != NULL) {\n\t\t\t*ctx_flags &= ~GSS_C_PROT_READY_FLAG;\n\t\t\t*ctx_flags &= ~GSS_C_TRANS_FLAG;\n\t\t}\n\t}\n\n\treturn (ret);\n}","idx":113,"name":"spnego_gss_inquire_context","project":"180227160492611","target":"False"}
{"commit_id":"63610390059128","func":"spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tsc->ctx_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}","idx":114,"name":"spnego_gss_wrap_size_limit","project":"180227160492611","target":"False"}
{"commit_id":"210028153675238","func":"create_spnego_ctx(int initiate)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->opened = 0;\n\tspnego_ctx->initiate = initiate;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}","idx":115,"name":"create_spnego_ctx","project":"180227160492611","target":"False"}
{"commit_id":"188641994340219","func":"spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_verify_mic(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}","idx":116,"name":"spnego_gss_verify_mic","project":"180227160492611","target":"False"}
{"commit_id":"217198290004162","func":"spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n\t\t\t\t      output_token);\n\t(void) release_spnego_ctx(ctx);\n\n\treturn (ret);\n}","idx":117,"name":"spnego_gss_delete_sec_context","project":"180227160492611","target":"False"}
{"commit_id":"141848782917512","func":"spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   sc->ctx_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}","idx":118,"name":"spnego_gss_wrap_iov","project":"180227160492611","target":"False"}
{"commit_id":"203241830256909","func":"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t   iov_count);\n}","idx":119,"name":"spnego_gss_get_mic_iov","project":"180227160492611","target":"False"}
{"commit_id":"117467363831192","func":"spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     sc->ctx_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}","idx":120,"name":"spnego_gss_unwrap_iov","project":"180227160492611","target":"False"}
{"commit_id":"247572365605089","func":"init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx(1);\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}","idx":121,"name":"init_ctx_new","project":"180227160492611","target":"False"}
{"commit_id":"145192913312178","func":"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  sc->ctx_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}","idx":122,"name":"spnego_gss_wrap_iov_length","project":"180227160492611","target":"False"}
{"commit_id":"38754702504391","func":"spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap(minor_status,\n\t\t\tsc->ctx_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}","idx":123,"name":"spnego_gss_unwrap","project":"180227160492611","target":"False"}
{"commit_id":"20647365901938","func":"spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_get_mic(minor_status,\n\t\t    sc->ctx_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}","idx":124,"name":"spnego_gss_get_mic","project":"180227160492611","target":"False"}
{"commit_id":"109599197146558","func":"acc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &der_mechTypes,\n\t\t\t       &mechTypes, &req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n\t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\t\tassert(mech_wanted != GSS_C_NO_OID);\n\t} else\n\t\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc->mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc->internal_mech = mech_wanted;\n\tsc->DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc->mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mechTypes);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&tmpmin, &der_mechTypes);\n\n\treturn ret;\n}","idx":125,"name":"acc_ctx_new","project":"180227160492611","target":"False"}
{"commit_id":"59955245857094","func":"spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      sc->ctx_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}","idx":126,"name":"spnego_gss_complete_auth_token","project":"180227160492611","target":"False"}
{"commit_id":"37459913139101","func":"spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_context_time(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}","idx":127,"name":"spnego_gss_context_time","project":"180227160492611","target":"False"}
{"commit_id":"255238122427456","func":"iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 1);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}","idx":133,"name":"iakerb_gss_init_sec_context","project":"101493015699813","target":"False"}
{"commit_id":"100552495875358","func":"iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, OM_uint32 req_output_size,\n                           OM_uint32 *max_input_size)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, req_output_size, max_input_size);\n}","idx":134,"name":"iakerb_gss_wrap_size_limit","project":"101493015699813","target":"False"}
{"commit_id":"38313435773964","func":"iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                int conf_req_flag, gss_qop_t qop_req,\n                gss_buffer_t input_message_buffer, int *conf_state,\n                gss_buffer_t output_message_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                         input_message_buffer, conf_state,\n                         output_message_buffer);\n}","idx":135,"name":"iakerb_gss_wrap","project":"101493015699813","target":"False"}
{"commit_id":"116876031194595","func":"iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n                   gss_buffer_t message_token)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n                            message_token);\n}","idx":136,"name":"iakerb_gss_get_mic","project":"101493015699813","target":"False"}
{"commit_id":"92550706786573","func":"iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n                    gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                             conf_state, iov, iov_count);\n}","idx":137,"name":"iakerb_gss_wrap_iov","project":"101493015699813","target":"False"}
{"commit_id":"263724932904273","func":"iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n                       int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n                                iov_count);\n}","idx":138,"name":"iakerb_gss_get_mic_iov","project":"101493015699813","target":"False"}
{"commit_id":"181446587942268","func":"iakerb_gss_process_context_token(OM_uint32 *minor_status,\n                                 const gss_ctx_id_t context_handle,\n                                 const gss_buffer_t token_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_DEFECTIVE_TOKEN;\n\n    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n                                          token_buffer);\n}","idx":139,"name":"iakerb_gss_process_context_token","project":"101493015699813","target":"False"}
{"commit_id":"108426824869345","func":"iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n                                  const gss_buffer_t value)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n                                           desired_object, value);\n}","idx":140,"name":"iakerb_gss_set_sec_context_option","project":"101493015699813","target":"False"}
{"commit_id":"33488205678940","func":"iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 0);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}","idx":141,"name":"iakerb_gss_accept_sec_context","project":"101493015699813","target":"False"}
{"commit_id":"47390198264150","func":"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}","idx":142,"name":"iakerb_gss_delete_sec_context","project":"101493015699813","target":"False"}
{"commit_id":"209512882136129","func":"iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n    ctx->initiate = initiate;\n    ctx->established = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}","idx":143,"name":"iakerb_alloc_context","project":"101493015699813","target":"False"}
{"commit_id":"333092716849","func":"iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n                          int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n                                   iov_count);\n}","idx":144,"name":"iakerb_gss_verify_mic_iov","project":"101493015699813","target":"False"}
{"commit_id":"43039968600773","func":"iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      int *conf_state, gss_qop_t *qop_state,\n                      gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n                               iov, iov_count);\n}","idx":145,"name":"iakerb_gss_unwrap_iov","project":"101493015699813","target":"False"}
{"commit_id":"111535535003117","func":"iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n                      gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n                               token_buffer, qop_state);\n}","idx":146,"name":"iakerb_gss_verify_mic","project":"101493015699813","target":"False"}
{"commit_id":"49755891245504","func":"iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n                              gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n                                       iov_count);\n}","idx":147,"name":"iakerb_gss_get_mic_iov_length","project":"101493015699813","target":"False"}
{"commit_id":"68697599535723","func":"iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                        OM_uint32 *time_rec)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n}","idx":148,"name":"iakerb_gss_context_time","project":"101493015699813","target":"False"}
{"commit_id":"67452939098071","func":"iakerb_gss_inquire_context(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n                           int *initiate, int *opened)\n{\n    OM_uint32 ret;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (src_name != NULL)\n        *src_name = GSS_C_NO_NAME;\n    if (targ_name != NULL)\n        *targ_name = GSS_C_NO_NAME;\n    if (lifetime_rec != NULL)\n        *lifetime_rec = 0;\n    if (mech_type != NULL)\n        *mech_type = (gss_OID)gss_mech_iakerb;\n    if (ctx_flags != NULL)\n        *ctx_flags = 0;\n    if (initiate != NULL)\n        *initiate = ctx->initiate;\n    if (opened != NULL)\n        *opened = ctx->established;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_COMPLETE;\n\n    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n                                   targ_name, lifetime_rec, mech_type,\n                                   ctx_flags, initiate, opened);\n\n    if (!ctx->established) {\n        /* Report IAKERB as the mech OID until the context is established. */\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n\n        /* We don't support exporting partially-established contexts. */\n        if (ctx_flags != NULL)\n            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n    }\n\n    return ret;\n}","idx":149,"name":"iakerb_gss_inquire_context","project":"101493015699813","target":"False"}
{"commit_id":"102932295779963","func":"iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n                                      gss_buffer_set_t *data_set)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n                                               desired_object, data_set);\n}","idx":150,"name":"iakerb_gss_inquire_sec_context_by_oid","project":"101493015699813","target":"False"}
{"commit_id":"147374904170628","func":"iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                  gss_buffer_t input_message_buffer,\n                  gss_buffer_t output_message_buffer, int *conf_state,\n                  gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n                           output_message_buffer, conf_state, qop_state);\n}","idx":151,"name":"iakerb_gss_unwrap","project":"101493015699813","target":"False"}
{"commit_id":"198072193883301","func":"iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, int *conf_state,\n                           gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, conf_state, iov, iov_count);\n}","idx":152,"name":"iakerb_gss_wrap_iov_length","project":"101493015699813","target":"False"}
{"commit_id":"142518286775469","func":"iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}","idx":153,"name":"iakerb_gss_export_sec_context","project":"101493015699813","target":"False"}
{"commit_id":"171967880243002","func":"iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                         int prf_key, const gss_buffer_t prf_in,\n                         ssize_t desired_output_len, gss_buffer_t prf_out)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n                                  desired_output_len, prf_out);\n}","idx":154,"name":"iakerb_gss_pseudo_random","project":"101493015699813","target":"False"}
{"commit_id":"109546850889073","func":"build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  /* initial guess at needed space */\n    char *component = NULL;\n\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n\n    if (!retval)\n        r = k5memdup0(realm, rlen, &retval);\n\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    /* take ownership */\n        data = NULL; /* take ownership */\n    }\n\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n\n    return retval;\n}","idx":156,"name":"build_principal_va","project":"218972346495359","target":"False"}
{"commit_id":"276424854139080","func":"iakerb_gss_import_sec_context(OM_uint32 *minor_status,\n                              gss_buffer_t interprocess_token,\n                              gss_ctx_id_t *context_handle)\n{\n    OM_uint32 maj, tmpmin;\n    krb5_error_code code;\n    gss_ctx_id_t gssc;\n    krb5_gss_ctx_id_t kctx;\n    iakerb_ctx_id_t ctx;\n\n    maj = krb5_gss_import_sec_context(minor_status, interprocess_token, &gssc);\n    if (maj != GSS_S_COMPLETE)\n        return maj;\n    kctx = (krb5_gss_ctx_id_t)gssc;\n\n    if (!kctx->established) {\n        /* We don't currently support importing partially established\n         * contexts. */\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        return GSS_S_FAILURE;\n    }\n\n    code = iakerb_alloc_context(&ctx, kctx->initiate);\n    if (code != 0) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        *minor_status = code;\n        return GSS_S_FAILURE;\n    }\n\n    ctx->gssc = gssc;\n    ctx->established = 1;\n    *context_handle = (gss_ctx_id_t)ctx;\n    return GSS_S_COMPLETE;\n}","idx":158,"name":"iakerb_gss_import_sec_context","project":"13018839216854","target":"False"}
{"commit_id":"18572241571626","func":"iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}","idx":159,"name":"iakerb_gss_export_sec_context","project":"13018839216854","target":"False"}
{"commit_id":"174048364162690","func":"bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  if (!xdr_opaque(xdrs, *objp, size))\n\t\t  return FALSE;\n\t  /* Check that the unmarshalled bytes are a C string. */\n\t  if ((*objp)[size - 1] != '\\0')\n\t\t  return FALSE;\n\t  if (memchr(*objp, '\\0', size - 1) != NULL)\n\t\t  return FALSE;\n\t  return TRUE;\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}","idx":161,"name":"xdr_nullstring","project":"272118200307017","target":"False"}
{"commit_id":"25453027394000","func":"kadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_int32                  now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(kdb, 0, sizeof(*kdb));\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = now + polent.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    if ((ret = kadm5_copy_principal(handle->context,\n                                    entry->principal, &(kdb->princ))))\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}","idx":164,"name":"kadm5_create_principal_3","project":"75712459139979","target":"False"}
{"commit_id":"211871276218794","func":"kadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += pol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}","idx":165,"name":"kadm5_modify_principal","project":"75712459139979","target":"False"}
{"commit_id":"91400158438408","func":"set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":190,"name":"set_string_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"40967373072804","func":"setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":191,"name":"setv4key_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"68685867967035","func":"delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":192,"name":"delete_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"129332060556543","func":"rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg1 = NULL, *prime_arg2 = NULL;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    size_t                      tlen1, tlen2, clen, slen;\n    char                        *tdots1, *tdots2, *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||\n        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    tlen1 = strlen(prime_arg1);\n    trunc_name(&tlen1, &tdots1);\n    tlen2 = strlen(prime_arg2);\n    trunc_name(&tlen2, &tdots2);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n\n    ret.code = KADM5_OK;\n    if (! CHANGEPW_SERVICE(rqstp)) {\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_DELETE, arg->src, NULL))\n            ret.code = KADM5_AUTH_DELETE;\n        /* any restrictions at all on the ADD kills the RENAME */\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_ADD, arg->dest, &rp) || rp) {\n            if (ret.code == KADM5_AUTH_DELETE)\n                ret.code = KADM5_AUTH_INSUFFICIENT;\n            else\n                ret.code = KADM5_AUTH_ADD;\n        }\n    } else\n        ret.code = KADM5_AUTH_INSUFFICIENT;\n    if (ret.code != KADM5_OK) {\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Unauthorized request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n    } else {\n        ret.code = kadm5_rename_principal((void *)handle, arg->src,\n                                          arg->dest);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, %s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         errmsg ? errmsg : _(\"success\"),\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\nexit_func:\n    free(prime_arg1);\n    free(prime_arg2);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":193,"name":"rename_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"221667023254119","func":"purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_purgekeys\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":194,"name":"purgekeys_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"46986424943626","func":"get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)\n{\n    static gpol_ret             ret;\n    kadm5_ret_t         ret2;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_principal_ent_rec     caller_ent;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_gpol_ret,  &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_policy\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    ret.code = KADM5_AUTH_GET;\n    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_INQUIRE, NULL, NULL))\n        ret.code = KADM5_OK;\n    else {\n        ret.code = kadm5_get_principal(handle->lhandle,\n                                       handle->current_caller,\n                                       &caller_ent,\n                                       KADM5_PRINCIPAL_NORMAL_MASK);\n        if (ret.code == KADM5_OK) {\n            if (caller_ent.aux_attributes & KADM5_POLICY &&\n                strcmp(caller_ent.policy, arg->name) == 0) {\n                ret.code = KADM5_OK;\n            } else ret.code = KADM5_AUTH_GET;\n            ret2 = kadm5_free_principal_ent(handle->lhandle,\n                                            &caller_ent);\n            ret.code = ret.code ? ret.code : ret2;\n        }\n    }\n\n    if (ret.code == KADM5_OK) {\n        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname,\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n\n}","idx":195,"name":"get_policy_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"109629093211023","func":"chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               arg->keepold,\n                                               arg->n_ks_tuple,\n                                               arg->ks_tuple,\n                                               &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal_3((void *)handle, arg->princ,\n                                             arg->keepold,\n                                             arg->n_ks_tuple,\n                                             arg->ks_tuple,\n                                             &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":196,"name":"chrand_principal3_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"270190999239545","func":"delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":197,"name":"delete_policy_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"45854527898870","func":"create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":198,"name":"create_principal3_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"37753121290060","func":"setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":199,"name":"setkey_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"4623197011222","func":"chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":200,"name":"chpass_principal3_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"34452735594736","func":"generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n\n    free_server_handle(handle);\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    /* okay to cast lengths to int because trunc_name limits max value */\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    return(&ret);\n}","idx":201,"name":"init_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"2288404845052","func":"modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":202,"name":"modify_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"56908880618736","func":"create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":203,"name":"create_policy_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"218145809846950","func":"get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprinc_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":204,"name":"get_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"24448890156410","func":"setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":205,"name":"setkey_principal3_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"74605222697463","func":"get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":206,"name":"get_strings_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"41114197375838","func":"chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":207,"name":"chpass_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"275973019772115","func":"create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":208,"name":"create_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"120219826794256","func":"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":209,"name":"get_privs_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"136780968279725","func":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":210,"name":"modify_policy_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"217007423844714","func":"chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":211,"name":"chrand_principal_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"237615766163325","func":"get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gpols_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":212,"name":"get_pols_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"185061958594559","func":"get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","idx":213,"name":"get_princs_2_svc","project":"65452599034640","target":"False"}
{"commit_id":"221680594789985","func":"process_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], \"=\", &arg_val);\n            arg = (arg != NULL) ? arg : \"\";\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &xargs->tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}","idx":214,"name":"process_db_args","project":"242257866677552","target":"False"}
{"commit_id":"267573949379690","func":"kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}","idx":221,"name":"kdc_process_for_user","project":"42207620444893","target":"Privacy"}
{"commit_id":"152410825328637","func":"kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}","idx":222,"name":"kdc_process_s4u_x509_user","project":"42207620444893","target":"Privacy"}
{"commit_id":"264065904775821","func":"kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code) {\n        *status = \"DECODE_PA_FOR_USER\";\n        return code;\n    }\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}","idx":223,"name":"kdc_process_for_user","project":"42207620444893","target":"Privacy"}
{"commit_id":"69948184766856","func":"kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}","idx":224,"name":"kdc_process_s4u_x509_user","project":"42207620444893","target":"Privacy"}
{"commit_id":"252194236052495","func":"s4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}","idx":262,"name":"s4u_identify_user","project":"12422060022640","target":"Privacy"}
{"commit_id":"127927334619332","func":"s4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}","idx":263,"name":"s4u_identify_user","project":"12422060022640","target":"Privacy"}
{"commit_id":"92786292105917","func":"video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\tv4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = NULL;\n\tlong\terr  = -EINVAL;\n\tint     is_ext_ctrl;\n\tsize_t  ctrls_size = 0;\n\tvoid __user *user_ptr = NULL;\n\n\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\tparg = NULL;\n\t\tbreak;\n\tcase _IOC_READ:\n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\t/* In case of an error, tell the caller that it wasn't\n\t\t   a specific control that caused it. */\n\t\tp->error_idx = p->count;\n\t\tuser_ptr = (void __user *)p->controls;\n\t\tif (p->count) {\n\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n\t\t\t/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. */\n\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n\t\t\terr = -ENOMEM;\n\t\t\tif (NULL == mbuf)\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\tp->controls = mbuf;\n\t\t}\n\t}\n\n\t/* call driver */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\tp->controls = (void *)user_ptr;\n\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_ext_ctrl;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_ext_ctrl:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}","idx":343,"name":"video_usercopy","project":"13690076025836","target":"Privacy"}
{"commit_id":"112886753874689","func":"video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}","idx":345,"name":"video_usercopy","project":"13690076025836","target":"Privacy"}
{"commit_id":"73211699935787","func":"int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}","idx":440,"name":"ip_options_get_from_user","project":"134398982668002","target":"Privacy"}
{"commit_id":"263146234416436","func":"int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}","idx":444,"name":"ip_options_get_from_user","project":"134398982668002","target":"Privacy"}
{"commit_id":"86588483993201","func":"asmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir;\n\n\tif(!(current->thread.flags & SPARC_FLAG_UNALIGNED) ||\n\t   (((insn >> 30) & 3) != 3))\n\t\tgoto kill_user;\n\tdir = decode_direction(insn);\n\tif(!ok_for_user(regs, insn, dir)) {\n\t\tgoto kill_user;\n\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\n\t\tcase both:\n\t\t\t/*\n\t\t\t * This was supported in 2.4. However, we question\n\t\t\t * the value of SWAP instruction across word boundaries.\n\t\t\t */\n\t\t\tprintk(\"Unaligned SWAP unsupported.\\n\");\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tunaligned_panic(\"Impossible user unaligned trap.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (err)\n\t\t\tgoto kill_user;\n\t\telse\n\t\t\tadvance(regs);\n\t\tgoto out;\n\t}\n\nkill_user:\n\tuser_mna_trap_fault(regs, insn);\nout:\n\t;\n}","idx":591,"name":"user_unaligned_trap","project":"116594665145327","target":"Privacy"}
{"commit_id":"36812166455488","func":"asmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir;\n\n\tif(!(current->thread.flags & SPARC_FLAG_UNALIGNED) ||\n\t   (((insn >> 30) & 3) != 3))\n\t\tgoto kill_user;\n\tdir = decode_direction(insn);\n\tif(!ok_for_user(regs, insn, dir)) {\n\t\tgoto kill_user;\n\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\n\t\tcase both:\n\t\t\t/*\n\t\t\t * This was supported in 2.4. However, we question\n\t\t\t * the value of SWAP instruction across word boundaries.\n\t\t\t */\n\t\t\tprintk(\"Unaligned SWAP unsupported.\\n\");\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tunaligned_panic(\"Impossible user unaligned trap.\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (err)\n\t\t\tgoto kill_user;\n\t\telse\n\t\t\tadvance(regs);\n\t\tgoto out;\n\t}\n\nkill_user:\n\tuser_mna_trap_fault(regs, insn);\nout:\n\t;\n}","idx":593,"name":"user_unaligned_trap","project":"116594665145327","target":"Privacy"}
{"commit_id":"14358943292691","func":"static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}","idx":823,"name":"copy_regset_to_user","project":"184845378263445","target":"Privacy"}
{"commit_id":"13914499695740","func":"static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}","idx":824,"name":"copy_regset_from_user","project":"184845378263445","target":"Privacy"}
{"commit_id":"160859433827457","func":"static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}","idx":866,"name":"macvtap_get_user","project":"261536469658156","target":"Privacy"}
{"commit_id":"220195011052959","func":"static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,\n\t\t\t\tconst struct iovec *iv, unsigned long total_len,\n\t\t\t\tsize_t count, int noblock)\n{\n\tstruct sk_buff *skb;\n\tstruct macvlan_dev *vlan;\n\tunsigned long len = total_len;\n\tint err;\n\tstruct virtio_net_hdr vnet_hdr = { 0 };\n\tint vnet_hdr_len = 0;\n\tint copylen = 0;\n\tbool zerocopy = false;\n\n\tif (q->flags & IFF_VNET_HDR) {\n\t\tvnet_hdr_len = q->vnet_hdr_sz;\n\n\t\terr = -EINVAL;\n\t\tif (len < vnet_hdr_len)\n\t\t\tgoto err;\n\t\tlen -= vnet_hdr_len;\n\n\t\terr = memcpy_fromiovecend((void *)&vnet_hdr, iv, 0,\n\t\t\t\t\t   sizeof(vnet_hdr));\n\t\tif (err < 0)\n\t\t\tgoto err;\n\t\tif ((vnet_hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t     vnet_hdr.csum_start + vnet_hdr.csum_offset + 2 >\n\t\t\t\t\t\t\tvnet_hdr.hdr_len)\n\t\t\tvnet_hdr.hdr_len = vnet_hdr.csum_start +\n\t\t\t\t\t\tvnet_hdr.csum_offset + 2;\n\t\terr = -EINVAL;\n\t\tif (vnet_hdr.hdr_len > len)\n\t\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\tif (unlikely(len < ETH_HLEN))\n\t\tgoto err;\n\n\terr = -EMSGSIZE;\n\tif (unlikely(count > UIO_MAXIOV))\n\t\tgoto err;\n\n\tif (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))\n\t\tzerocopy = true;\n\n\tif (zerocopy) {\n\t\t/* Userspace may produce vectors with count greater than\n\t\t * MAX_SKB_FRAGS, so we need to linearize parts of the skb\n\t\t * to let the rest of data to be fit in the frags.\n\t\t */\n\t\tif (count > MAX_SKB_FRAGS) {\n\t\t\tcopylen = iov_length(iv, count - MAX_SKB_FRAGS);\n\t\t\tif (copylen < vnet_hdr_len)\n\t\t\t\tcopylen = 0;\n\t\t\telse\n\t\t\t\tcopylen -= vnet_hdr_len;\n\t\t}\n\t\t/* There are 256 bytes to be copied in skb, so there is enough\n\t\t * room for skb expand head in case it is used.\n\t\t * The rest buffer is mapped from userspace.\n\t\t */\n\t\tif (copylen < vnet_hdr.hdr_len)\n\t\t\tcopylen = vnet_hdr.hdr_len;\n\t\tif (!copylen)\n\t\t\tcopylen = GOODCOPY_LEN;\n\t} else\n\t\tcopylen = len;\n\n\tskb = macvtap_alloc_skb(&q->sk, NET_IP_ALIGN, copylen,\n\t\t\t\tvnet_hdr.hdr_len, noblock, &err);\n\tif (!skb)\n\t\tgoto err;\n\n\tif (zerocopy)\n\t\terr = zerocopy_sg_from_iovec(skb, iv, vnet_hdr_len, count);\n\telse\n\t\terr = skb_copy_datagram_from_iovec(skb, 0, iv, vnet_hdr_len,\n\t\t\t\t\t\t   len);\n\tif (err)\n\t\tgoto err_kfree;\n\n\tskb_set_network_header(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\tif (vnet_hdr_len) {\n\t\terr = macvtap_skb_from_vnet_hdr(skb, &vnet_hdr);\n\t\tif (err)\n\t\t\tgoto err_kfree;\n\t}\n\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\t/* copy skb_ubuf_info for callback when skb has no error */\n\tif (zerocopy) {\n\t\tskb_shinfo(skb)->destructor_arg = m->msg_control;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_DEV_ZEROCOPY;\n\t}\n\tif (vlan)\n\t\tmacvlan_start_xmit(skb, vlan->dev);\n\telse\n\t\tkfree_skb(skb);\n\trcu_read_unlock_bh();\n\n\treturn total_len;\n\nerr_kfree:\n\tkfree_skb(skb);\n\nerr:\n\trcu_read_lock_bh();\n\tvlan = rcu_dereference_bh(q->vlan);\n\tif (vlan)\n\t\tvlan->dev->stats.tx_dropped++;\n\trcu_read_unlock_bh();\n\n\treturn err;\n}","idx":868,"name":"macvtap_get_user","project":"261536469658156","target":"Privacy"}
{"commit_id":"253064101694216","func":"static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\n\tnetlink_table_ungrab();\n}","idx":943,"name":"netlink_add_usersock_entry","project":"210853060447928","target":"Privacy"}
{"commit_id":"258796057636373","func":"static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}","idx":958,"name":"copy_to_user_auth","project":"223598489596395","target":"Privacy"}
{"commit_id":"233992129569837","func":"static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}","idx":959,"name":"copy_to_user_auth","project":"223598489596395","target":"Privacy"}
{"commit_id":"107392846180376","func":"static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}","idx":960,"name":"copy_to_user_state","project":"230516179048400","target":"Privacy"}
{"commit_id":"205636952783115","func":"static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}","idx":961,"name":"copy_to_user_policy","project":"199149502941079","target":"Privacy"}
{"commit_id":"42892470351993","func":"static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}","idx":962,"name":"copy_to_user_tmpl","project":"245232349292686","target":"Privacy"}
{"commit_id":"117475686991990","func":"int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}","idx":1098,"name":"install_user_keyrings","project":"194273651946262","target":"Privacy"}
{"commit_id":"263006793197121","func":"int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}","idx":1099,"name":"install_user_keyrings","project":"194273651946262","target":"Privacy"}
{"commit_id":"117545420793281","func":"static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\n\t/* Don't allow gaining capabilities by reentering\n\t * the same user namespace.\n\t */\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\t/* Threaded processes may not enter a different user namespace */\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\treturn commit_creds(cred);\n}","idx":1109,"name":"userns_install","project":"258873668776033","target":"Privacy"}
{"commit_id":"83930733883913","func":"int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\n\t/*\n\t * Verify that we can not violate the policy of which files\n\t * may be accessed that is specified by the root directory,\n\t * by verifing that the root directory is at the root of the\n\t * mount namespace which allows all files to be accessed.\n\t */\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\n\t/* The creator needs a mapping in the parent user namespace\n\t * or else we won't be able to reasonably tell userspace who\n\t * created a user_namespace.\n\t */\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\n\tatomic_set(&ns->count, 1);\n\t/* Leave the new->user_ns reference with the new user namespace. */\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\n\tset_cred_user_ns(new, ns);\n\n\treturn 0;\n}","idx":1126,"name":"create_user_ns","project":"276841509450353","target":"Privacy"}
{"commit_id":"106460653125861","func":"static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\t/* Get the top half of the MSR */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* Pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}","idx":1193,"name":"restore_tm_user_regs","project":"86739019988412","target":"Privacy"}
{"commit_id":"202065573520677","func":"static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}","idx":1194,"name":"restore_tm_user_regs","project":"86739019988412","target":"Privacy"}
{"commit_id":"46703701333637","func":"int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}","idx":1215,"name":"user_update","project":"92149078329707","target":"Privacy"}
{"commit_id":"43317657745521","func":"int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}","idx":1216,"name":"user_update","project":"92149078329707","target":"Privacy"}
{"commit_id":"108452847910150","func":"static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tmutex_lock(&tu->tread_sem);\n\t\tif (tu->timeri)\t{\t/* too late */\n\t\t\tmutex_unlock(&tu->tread_sem);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (get_user(xarg, p)) {\n\t\t\tmutex_unlock(&tu->tread_sem);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttu->tread = xarg ? 1 : 0;\n\t\tmutex_unlock(&tu->tread_sem);\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}","idx":1336,"name":"snd_timer_user_ioctl","project":"9481270376111","target":"Privacy"}
{"commit_id":"163575993645283","func":"static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}","idx":1337,"name":"snd_timer_user_open","project":"9481270376111","target":"Privacy"}
{"commit_id":"186989615341520","func":"static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}","idx":1338,"name":"snd_timer_user_tselect","project":"9481270376111","target":"Privacy"}
{"commit_id":"240735073964233","func":"static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}","idx":1339,"name":"snd_timer_user_release","project":"9481270376111","target":"Privacy"}
{"commit_id":"201756718349039","func":"static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}","idx":1340,"name":"snd_timer_user_ioctl","project":"9481270376111","target":"Privacy"}
{"commit_id":"196900642420391","func":"static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}","idx":1341,"name":"snd_timer_user_open","project":"9481270376111","target":"Privacy"}
{"commit_id":"107268333919276","func":"static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\n\t\tif (tu->timeri)\t/* too late */\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}","idx":1342,"name":"__snd_timer_user_ioctl","project":"9481270376111","target":"Privacy"}
{"commit_id":"38684318611759","func":"static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}","idx":1585,"name":"ffs_user_copy_worker","project":"47358095809403","target":"Privacy"}
{"commit_id":"235676956074904","func":"static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}","idx":1586,"name":"ffs_user_copy_worker","project":"47358095809403","target":"Privacy"}
{"commit_id":"193108376854412","func":"static int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tstruct snd_timer_read *tr;\n\tstruct snd_timer_tread *ttr;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\tif (tu->tread) {\n\t\t\tttr = kmalloc(params.queue_size * sizeof(*ttr),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ttr) {\n\t\t\t\tkfree(tu->tqueue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->tqueue = ttr;\n\t\t\t}\n\t\t} else {\n\t\t\ttr = kmalloc(params.queue_size * sizeof(*tr),\n\t\t\t\t     GFP_KERNEL);\n\t\t\tif (tr) {\n\t\t\t\tkfree(tu->queue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->queue = tr;\n\t\t\t}\n\t\t}\n\t}\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\tmemset(&tread, 0, sizeof(tread));\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}","idx":1629,"name":"snd_timer_user_params","project":"95175279416381","target":"Privacy"}
{"commit_id":"56289042015417","func":"static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}","idx":1630,"name":"snd_timer_user_ccallback","project":"150155248011791","target":"Privacy"}
{"commit_id":"165165335174894","func":"static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tmemset(&r1, 0, sizeof(r1));\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}","idx":1631,"name":"snd_timer_user_tinterrupt","project":"259184366576012","target":"Privacy"}
{"commit_id":"61969692902467","func":"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}","idx":1796,"name":"blk_rq_map_user_iov","project":"22626545586223","target":"Privacy"}
{"commit_id":"41250224803169","func":"static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}","idx":1959,"name":"validate_user_key","project":"85080910839532","target":"Privacy"}
{"commit_id":"89668256543454","func":"static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tdown_read(&keyring_key->sem);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\nout:\n\tup_read(&keyring_key->sem);\n\tkey_put(keyring_key);\n\treturn res;\n}","idx":1963,"name":"validate_user_key","project":"85080910839532","target":"Privacy"}
{"commit_id":"36888453543920","func":"static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\treturn result > 0 ? result : err;\n}","idx":2065,"name":"snd_timer_user_read","project":"166477318288958","target":"Privacy"}
{"commit_id":"144662213884696","func":"static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tmutex_lock(&tu->ioctl_lock);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tmutex_unlock(&tu->ioctl_lock);\n\t\t\tschedule();\n\t\t\tmutex_lock(&tu->ioctl_lock);\n\t\t\tspin_lock_irq(&tu->qlock);\n\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn result > 0 ? result : err;\n}","idx":2066,"name":"snd_timer_user_read","project":"166477318288958","target":"Privacy"}
{"commit_id":"72823373366285","func":"static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}","idx":2067,"name":"snd_timer_user_tselect","project":"23847158190815","target":"Privacy"}
{"commit_id":"163464848817445","func":"int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}","idx":2154,"name":"install_user_keyrings","project":"65196645753178","target":"Privacy"}
{"commit_id":"33936496682505","func":"int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t\tKEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t  KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}","idx":2155,"name":"install_user_keyrings","project":"65196645753178","target":"Privacy"}
{"commit_id":"241941308837203","func":"expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the nubmer of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}","idx":1,"name":"expand_dynamic_string_token","project":"7461293048740","target":"True"}
{"commit_id":"235368100398254","func":"_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n\n  /* Now fill the result path.  While copying over the string we keep\n     track of the start of the last path element.  When we come accross\n     a DST we copy over the value or (if the value is not available)\n     leave the entire path element out.  */\n  last_elem = wp = result;\n\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot use this path element, the value of the\n\t\t     replacement is unknown.  */\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    /* No DST we recognize.  */\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n\n  *wp = '\\0';\n\n  return result;\n}","idx":2,"name":"_dl_dst_substitute","project":"7461293048740","target":"True"}
{"commit_id":"161060042440601","func":"_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.  */\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}","idx":3,"name":"_dl_dst_count","project":"7461293048740","target":"True"}
{"commit_id":"131689877695615","func":"vsyslog(pri, fmt, ap)\n\tint pri;\n\tregister const char *fmt;\n\tva_list ap;\n{\n\tstruct tm now_tm;\n\ttime_t now;\n\tint fd;\n\tFILE *f;\n\tchar *buf = 0;\n\tsize_t bufsize = 0;\n\tsize_t prioff, msgoff;\n \tstruct sigaction action, oldaction;\n\tstruct sigaction *oldaction_ptr = NULL;\n \tint sigpipe;\n\tint saved_errno = errno;\n\n#define\tINTERNALLOG\tLOG_ERR|LOG_CONS|LOG_PERROR|LOG_PID\n\t/* Check for invalid bits. */\n\tif (pri & ~(LOG_PRIMASK|LOG_FACMASK)) {\n\t\tsyslog(INTERNALLOG,\n\t\t    \"syslog: unknown facility/priority: %x\", pri);\n\t\tpri &= LOG_PRIMASK|LOG_FACMASK;\n\t}\n\n\t/* Check priority against setlogmask values. */\n\tif ((LOG_MASK (LOG_PRI (pri)) & LogMask) == 0)\n\t\treturn;\n\n\t/* Set default facility if none specified. */\n\tif ((pri & LOG_FACMASK) == 0)\n\t\tpri |= LogFacility;\n\n\t/* Build the message in a memory-buffer stream.  */\n\tf = open_memstream (&buf, &bufsize);\n\tprioff = fprintf (f, \"<%d>\", pri);\n\t(void) time (&now);\n#ifdef USE_IN_LIBIO\n        f->_IO_write_ptr += strftime (f->_IO_write_ptr,\n                                      f->_IO_write_end - f->_IO_write_ptr,\n                                      \"%h %e %T \",\n\t\t\t\t      __localtime_r (&now, &now_tm));\n#else\n\tf->__bufp += strftime (f->__bufp, f->__put_limit - f->__bufp,\n\t\t\t       \"%h %e %T \", __localtime_r (&now, &now_tm));\n#endif\n\tmsgoff = ftell (f);\n\tif (LogTag == NULL)\n\t  LogTag = __progname;\n\tif (LogTag != NULL)\n\t  fputs_unlocked (LogTag, f);\n\tif (LogStat & LOG_PID)\n\t  fprintf (f, \"[%d]\", __getpid ());\n\tif (LogTag != NULL)\n\t  putc_unlocked (':', f), putc_unlocked (' ', f);\n\n\t/* Restore errno for %m format.  */\n\t__set_errno (saved_errno);\n\n\t/* We have the header.  Print the user's format into the buffer.  */\n\tvfprintf (f, fmt, ap);\n\n\t/* Close the memory stream; this will finalize the data\n\t   into a malloc'd buffer in BUF.  */\n\tfclose (f);\n\n\t/* Output to stderr if requested. */\n\tif (LogStat & LOG_PERROR) {\n\t\tstruct iovec iov[2];\n\t\tregister struct iovec *v = iov;\n\n\t\tv->iov_base = buf + msgoff;\n\t\tv->iov_len = bufsize - msgoff;\n\t\t++v;\n\t\tv->iov_base = (char *) \"\\n\";\n\t\tv->iov_len = 1;\n\t\t(void)__writev(STDERR_FILENO, iov, 2);\n\t}\n\n\t/* Prepare for multiple users.  We have to take care: open and\n\t   write are cancellation points.  */\n\t__libc_cleanup_region_start ((void (*) (void *)) cancel_handler,\n\t\t\t\t     &oldaction_ptr);\n\t__libc_lock_lock (syslog_lock);\n\n\t/* Prepare for a broken connection.  */\n \tmemset (&action, 0, sizeof (action));\n \taction.sa_handler = sigpipe_handler;\n \tsigemptyset (&action.sa_mask);\n \tsigpipe = __sigaction (SIGPIPE, &action, &oldaction);\n\tif (sigpipe == 0)\n\t  oldaction_ptr = &oldaction;\n\n\t/* Get connected, output the message to the local logger. */\n\tif (!connected)\n\t\topenlog_internal(LogTag, LogStat | LOG_NDELAY, 0);\n\n\t/* If we have a SOCK_STREAM connection, also send ASCII NUL as\n\t   a record terminator.  */\n\tif (LogType == SOCK_STREAM)\n\t  ++bufsize;\n\n\tif (!connected || __send(LogFile, buf, bufsize, 0) < 0)\n\t  {\n\t    closelog_internal ();\t/* attempt re-open next time */\n\t    /*\n\t     * Output the message to the console; don't worry about blocking,\n\t     * if console blocks everything will.  Make sure the error reported\n\t     * is the one from the syslogd failure.\n\t     */\n\t    if (LogStat & LOG_CONS &&\n\t\t(fd = __open(_PATH_CONSOLE, O_WRONLY|O_NOCTTY, 0)) >= 0)\n\t      {\n\t\tdprintf (fd, \"%s\\r\\n\", buf + msgoff);\n\t\t(void)__close(fd);\n\t      }\n\t  }\n\n\tif (sigpipe == 0)\n\t\t__sigaction (SIGPIPE, &oldaction, (struct sigaction *) NULL);\n\n\t/* End of critical section.  */\n\t__libc_cleanup_region_end (0);\n\t__libc_lock_unlock (syslog_lock);\n\n\tfree (buf);\n}","idx":7,"name":"vsyslog","project":"253444729592566","target":"True"}
{"commit_id":"168651867116832","func":"init_syntax_once ()\n{\n   register int c;\n   static int done;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}","idx":9,"name":"init_syntax_once","project":"88393274694273","target":"True"}
{"commit_id":"273774737471627","func":"getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t/* The caller expects ENOENT if nothing is found.  */\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}","idx":12,"name":"getlogin_r","project":"156577410779052","target":"True"}
{"commit_id":"31315624807780","func":"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}","idx":15,"name":"check_1_6_dummy","project":"47598748964815","target":"True"}
{"commit_id":"115132873802820","func":"process_chpw_request(krb5_context context, void *server_handle, char *realm,\n                     krb5_keytab keytab, const krb5_fulladdr *local_faddr,\n                     const krb5_fulladdr *remote_faddr, krb5_data *req,\n                     krb5_data *rep)\n{\n    krb5_error_code ret;\n    char *ptr;\n    unsigned int plen, vno;\n    krb5_data ap_req, ap_rep = empty_data();\n    krb5_data cipher = empty_data(), clear = empty_data();\n    krb5_auth_context auth_context = NULL;\n    krb5_principal changepw = NULL;\n    krb5_principal client, target = NULL;\n    krb5_ticket *ticket = NULL;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr = NULL, *targetstr = NULL;\n    const char *errmsg = NULL;\n    size_t clen;\n    char *cdots;\n    struct sockaddr_storage ss;\n    socklen_t salen;\n    char addrbuf[100];\n    krb5_address *addr = remote_faddr->address;\n\n    *rep = empty_data();\n\n    if (req->length < 4) {\n        /* either this, or the server is printing bad messages,\n           or the caller passed in garbage */\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request length was inconsistent\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1 && vno != RFC3244_VERSION) {\n        ret = KRB5KDC_ERR_BAD_PVNO;\n        numresult = KRB5_KPASSWD_BAD_VERSION;\n        snprintf(strresult, sizeof(strresult),\n                 \"Request contained unknown protocol version number %d\", vno);\n        goto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n        ret = KRB5KRB_AP_ERR_MODIFIED;\n        numresult = KRB5_KPASSWD_MALFORMED;\n        strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n                                 KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed initializing auth context\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n                               \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed building kadmin/changepw principal\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n                      NULL, &ticket);\n\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed reading application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n        numresult = KRB5_KPASSWD_AUTHERROR;\n        strlcpy(strresult, \"Failed replying to application request\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* decrypt the ChangePasswdData */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    /*\n     * Don't set a remote address in auth_context before calling krb5_rd_priv,\n     * so that we can work against clients behind a NAT.  Reflection attacks\n     * aren't a concern since we use sequence numbers and since our requests\n     * don't look anything like our responses.  Also don't set a local address,\n     * since we don't know what interface the request was received on.\n     */\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed decrypting request\", sizeof(strresult));\n        goto chpwfail;\n    }\n\n    client = ticket->enc_part2->client;\n\n    /* decode ChangePasswdData for setpw requests */\n    if (vno == RFC3244_VERSION) {\n        krb5_data *clear_data;\n\n        ret = decode_krb5_setpw_req(&clear, &clear_data, &target);\n        if (ret != 0) {\n            numresult = KRB5_KPASSWD_MALFORMED;\n            strlcpy(strresult, \"Failed decoding ChangePasswdData\",\n                    sizeof(strresult));\n            goto chpwfail;\n        }\n\n        zapfree(clear.data, clear.length);\n\n        clear = *clear_data;\n        free(clear_data);\n\n        if (target != NULL) {\n            ret = krb5_unparse_name(context, target, &targetstr);\n            if (ret != 0) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed unparsing target name for log\",\n                        sizeof(strresult));\n                goto chpwfail;\n            }\n        }\n    }\n\n    ret = krb5_unparse_name(context, client, &clientstr);\n    if (ret) {\n        numresult = KRB5_KPASSWD_HARDERROR;\n        strlcpy(strresult, \"Failed unparsing client name for log\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* for cpw, verify that this is an AS_REQ ticket */\n    if (vno == 1 &&\n        (ticket->enc_part2->flags & TKT_FLG_INITIAL) == 0) {\n        numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED;\n        strlcpy(strresult, \"Ticket must be derived from a password\",\n                sizeof(strresult));\n        goto chpwfail;\n    }\n\n    /* change the password */\n\n    ptr = k5memdup0(clear.data, clear.length, &ret);\n    ret = schpw_util_wrapper(server_handle, client, target,\n                             (ticket->enc_part2->flags & TKT_FLG_INITIAL) != 0,\n                             ptr, NULL, strresult, sizeof(strresult));\n    if (ret)\n        errmsg = krb5_get_error_message(context, ret);\n\n    /* zap the password */\n    zapfree(clear.data, clear.length);\n    zapfree(ptr, clear.length);\n    clear = empty_data();\n\n    clen = strlen(clientstr);\n    trunc_name(&clen, &cdots);\n\n    switch (addr->addrtype) {\n    case ADDRTYPE_INET: {\n        struct sockaddr_in *sin = ss2sin(&ss);\n\n        sin->sin_family = AF_INET;\n        memcpy(&sin->sin_addr, addr->contents, addr->length);\n        sin->sin_port = htons(remote_faddr->port);\n        salen = sizeof(*sin);\n        break;\n    }\n    case ADDRTYPE_INET6: {\n        struct sockaddr_in6 *sin6 = ss2sin6(&ss);\n\n        sin6->sin6_family = AF_INET6;\n        memcpy(&sin6->sin6_addr, addr->contents, addr->length);\n        sin6->sin6_port = htons(remote_faddr->port);\n        salen = sizeof(*sin6);\n        break;\n    }\n    default: {\n        struct sockaddr *sa = ss2sa(&ss);\n\n        sa->sa_family = AF_UNSPEC;\n        salen = sizeof(*sa);\n        break;\n    }\n    }\n\n    if (getnameinfo(ss2sa(&ss), salen,\n                    addrbuf, sizeof(addrbuf), NULL, 0,\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0)\n        strlcpy(addrbuf, \"<unprintable>\", sizeof(addrbuf));\n\n    if (vno == RFC3244_VERSION) {\n        size_t tlen;\n        char *tdots;\n        const char *targetp;\n\n        if (target == NULL) {\n            tlen = clen;\n            tdots = cdots;\n            targetp = targetstr;\n        } else {\n            tlen = strlen(targetstr);\n            trunc_name(&tlen, &tdots);\n            targetp = clientstr;\n        }\n\n        krb5_klog_syslog(LOG_NOTICE, _(\"setpw request from %s by %.*s%s for \"\n                                       \"%.*s%s: %s\"), addrbuf, (int) clen,\n                         clientstr, cdots, (int) tlen, targetp, tdots,\n                         errmsg ? errmsg : \"success\");\n    } else {\n        krb5_klog_syslog(LOG_NOTICE, _(\"chpw request from %s for %.*s%s: %s\"),\n                         addrbuf, (int) clen, clientstr, cdots,\n                         errmsg ? errmsg : \"success\");\n    }\n    switch (ret) {\n    case KADM5_AUTH_CHANGEPW:\n        numresult = KRB5_KPASSWD_ACCESSDENIED;\n        break;\n    case KADM5_PASS_Q_TOOSHORT:\n    case KADM5_PASS_REUSE:\n    case KADM5_PASS_Q_CLASS:\n    case KADM5_PASS_Q_DICT:\n    case KADM5_PASS_Q_GENERIC:\n    case KADM5_PASS_TOOSOON:\n        numresult = KRB5_KPASSWD_SOFTERROR;\n        break;\n    case 0:\n        numresult = KRB5_KPASSWD_SUCCESS;\n        strlcpy(strresult, \"\", sizeof(strresult));\n        break;\n    default:\n        numresult = KRB5_KPASSWD_HARDERROR;\n        break;\n    }\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher = empty_data();\n\n    if (ap_rep.length) {\n        ret = krb5_auth_con_setaddrs(context, auth_context,\n                                     local_faddr->address, NULL);\n        if (ret) {\n            numresult = KRB5_KPASSWD_HARDERROR;\n            strlcpy(strresult,\n                    \"Failed storing client and server internet addresses\",\n                    sizeof(strresult));\n        } else {\n            ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n                               &replay);\n            if (ret) {\n                numresult = KRB5_KPASSWD_HARDERROR;\n                strlcpy(strresult, \"Failed encrypting reply\",\n                        sizeof(strresult));\n            }\n        }\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n        /* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n        if (ap_rep.length) {\n            free(ap_rep.data);\n            ap_rep = empty_data();\n        }\n\n        krberror.ctime = 0;\n        krberror.cusec = 0;\n        krberror.susec = 0;\n        ret = krb5_timeofday(context, &krberror.stime);\n        if (ret)\n            goto bailout;\n\n        /* this is really icky.  but it's what all the other callers\n           to mk_error do. */\n        krberror.error = ret;\n        krberror.error -= ERROR_TABLE_BASE_krb5;\n        if (krberror.error < 0 || krberror.error > 128)\n            krberror.error = KRB_ERR_GENERIC;\n\n        krberror.client = NULL;\n\n        ret = krb5_build_principal(context, &krberror.server,\n                                   strlen(realm), realm,\n                                   \"kadmin\", \"changepw\", NULL);\n        if (ret)\n            goto bailout;\n        krberror.text.length = 0;\n        krberror.e_data = clear;\n\n        ret = krb5_mk_error(context, &krberror, &cipher);\n\n        krb5_free_principal(context, krberror.server);\n\n        if (ret)\n            goto bailout;\n    }\n\n    /* construct the reply */\n\n    ret = alloc_data(rep, 6 + ap_rep.length + cipher.length);\n    if (ret)\n        goto bailout;\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n        memcpy(ptr, ap_rep.data, ap_rep.length);\n        ptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_principal(context, changepw);\n    krb5_free_ticket(context, ticket);\n    free(ap_rep.data);\n    free(clear.data);\n    free(cipher.data);\n    krb5_free_principal(context, target);\n    krb5_free_unparsed_name(context, targetstr);\n    krb5_free_unparsed_name(context, clientstr);\n    krb5_free_error_message(context, errmsg);\n    return ret;\n}","idx":17,"name":"process_chpw_request","project":"164057968633021","target":"True"}
{"commit_id":"174958353526400","func":"init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc->mech_set. */\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}","idx":19,"name":"init_ctx_reselect","project":"179334716148121","target":"True"}
{"commit_id":"185560914878189","func":"acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}","idx":20,"name":"acc_ctx_cont","project":"179231907027180","target":"True"}
{"commit_id":"232687022774290","func":"kadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_int32                  now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, last_pwd;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n        if (ret)\n            goto done;\n\n#if 0\n        /*\n         * The spec says this check is overridden if the caller has\n         * modify privilege.  The admin server therefore makes this\n         * check itself (in chpass_principal_wrapper, misc.c).  A\n         * local caller implicitly has all authorization bits.\n         */\n        if((now - last_pwd) < pol.pw_min_life &&\n           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n            ret = KADM5_PASS_TOOSOON;\n            goto done;\n        }\n#endif\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = now + pol.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        ret = decrypt_key_data(handle->context,\n                               kdb->n_key_data, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}","idx":22,"name":"kadm5_randkey_principal_3","project":"201249276304048","target":"True"}
{"commit_id":"84674591149308","func":"krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}","idx":25,"name":"krb5_ldap_get_password_policy_from_dn","project":"48691161838925","target":"True"}
{"commit_id":"106933832321577","func":"krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone_prinicipal=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone_prinicipal true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone_prinicipal = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_prependmsg(context, ost, st, _(\"'%s' not found\"),\n                                  xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone_prinicipal to TRUE\n         */\n        create_standalone_prinicipal = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if ((st=krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                          LDAP_MOD_REPLACE | LDAP_MOD_BVALUES, bersecretkey)) != 0)\n            goto cleanup;\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            for (j = 0; ber_tl_data[j] != NULL; j++) {\n                free(ber_tl_data[j]->bv_val);\n                free(ber_tl_data[j]);\n            }\n            free(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone_prinicipal == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}","idx":27,"name":"krb5_ldap_put_principal","project":"195215522746497","target":"True"}
{"commit_id":"248485128525938","func":"krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 1;\n    int i, j, last;\n    krb5_error_code err = 0;\n    krb5_key_data *key_data;\n\n    if (n_key_data <= 0)\n        return NULL;\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data_in == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n    free(key_data);\n    if (err != 0) {\n        if (ret != NULL) {\n            for (i = 0; i <= num_versions; i++)\n                if (ret[i] != NULL)\n                    free (ret[i]);\n            free (ret);\n            ret = NULL;\n        }\n    }\n\n    return ret;\n}","idx":28,"name":"krb5_encode_krbsecretkey","project":"195215522746497","target":"True"}
{"commit_id":"109719031437813","func":"krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}","idx":31,"name":"krb5_gss_context_time","project":"76920291214045","target":"True"}
{"commit_id":"22724241653836","func":"krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}","idx":34,"name":"krb5_gss_inquire_sec_context_by_oid","project":"151992082495004","target":"True"}
{"commit_id":"201903415060886","func":"krb5_gss_inquire_context(minor_status, context_handle, initiator_name,\n                         acceptor_name, lifetime_rec, mech_type, ret_flags,\n                         locally_initiated, opened)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_name_t *initiator_name;\n    gss_name_t *acceptor_name;\n    OM_uint32 *lifetime_rec;\n    gss_OID *mech_type;\n    OM_uint32 *ret_flags;\n    int *locally_initiated;\n    int *opened;\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_gss_name_t initiator, acceptor;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    if (initiator_name)\n        *initiator_name = (gss_name_t) NULL;\n    if (acceptor_name)\n        *acceptor_name = (gss_name_t) NULL;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    initiator = NULL;\n    acceptor = NULL;\n    context = ctx->k5_context;\n\n    if ((code = krb5_timeofday(context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) < 0)\n        lifetime = 0;\n\n    if (initiator_name) {\n        if ((code = kg_duplicate_name(context,\n                                      ctx->initiate ? ctx->here : ctx->there,\n                                      &initiator))) {\n            *minor_status = code;\n            save_error_info(*minor_status, context);\n            return(GSS_S_FAILURE);\n        }\n    }\n\n    if (acceptor_name) {\n        if ((code = kg_duplicate_name(context,\n                                      ctx->initiate ? ctx->there : ctx->here,\n                                      &acceptor))) {\n            if (initiator)\n                kg_release_name(context, &initiator);\n            *minor_status = code;\n            save_error_info(*minor_status, context);\n            return(GSS_S_FAILURE);\n        }\n    }\n\n    if (initiator_name)\n        *initiator_name = (gss_name_t) initiator;\n\n    if (acceptor_name)\n        *acceptor_name = (gss_name_t) acceptor;\n\n    if (lifetime_rec)\n        *lifetime_rec = lifetime;\n\n    if (mech_type)\n        *mech_type = (gss_OID) ctx->mech_used;\n\n    if (ret_flags)\n        *ret_flags = ctx->gss_flags;\n\n    if (locally_initiated)\n        *locally_initiated = ctx->initiate;\n\n    if (opened)\n        *opened = ctx->established;\n\n    *minor_status = 0;\n    return((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);\n}","idx":36,"name":"krb5_gss_inquire_context","project":"147023369416402","target":"True"}
{"commit_id":"156686698156250","func":"kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n\n    /* Only default qop or matching established cryptosystem is allowed.\n\n       There are NO EXTENSIONS to this set for AES and friends!  The\n       new spec says \"just use 0\".  The old spec plus extensions would\n       actually allow for certain non-zero values.  Fix this to handle\n       them later.  */\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   /* XXX */\n        break;\n    }\n\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n\n    if (conf_state)\n        *conf_state = conf_req_flag;\n\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}","idx":38,"name":"kg_seal","project":"198506424303793","target":"True"}
{"commit_id":"77463936176602","func":"kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        /* may be more sensible to return an error here */\n        conf_req_flag = FALSE;\n    }\n\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n\n    *minor_status = 0;\n\n    return GSS_S_COMPLETE;\n}","idx":40,"name":"kg_seal_iov","project":"122861386712099","target":"True"}
{"commit_id":"10058181789567","func":"kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}","idx":42,"name":"kg_unseal","project":"198654895410094","target":"True"}
{"commit_id":"58615758582554","func":"kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}","idx":44,"name":"kg_unseal_iov","project":"69888990910426","target":"True"}
{"commit_id":"113625340651014","func":"krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* \"unseal\" the token */\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n    /* that's it.  delete the context */\n\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}","idx":48,"name":"krb5_gss_process_context_token","project":"94226547393645","target":"True"}
{"commit_id":"247503969831657","func":"krb5_gss_wrap_size_limit(minor_status, context_handle, conf_req_flag,\n                         qop_req, req_output_size, max_input_size)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        context_handle;\n    int                 conf_req_flag;\n    gss_qop_t           qop_req;\n    OM_uint32           req_output_size;\n    OM_uint32           *max_input_size;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32           data_size, conflen;\n    OM_uint32           ohlen;\n    int                 overhead;\n\n    /* only default qop is allowed */\n    if (qop_req != GSS_C_QOP_DEFAULT) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return(GSS_S_FAILURE);\n    }\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if (ctx->proto == 1) {\n        /* No pseudo-ASN.1 wrapper overhead, so no sequence length and\n           OID.  */\n        OM_uint32 sz = req_output_size;\n\n        /* Token header: 16 octets.  */\n        if (conf_req_flag) {\n            krb5_key key;\n            krb5_enctype enctype;\n\n            key = ctx->have_acceptor_subkey ? ctx->acceptor_subkey\n                : ctx->subkey;\n            enctype = key->keyblock.enctype;\n\n            while (sz > 0 && krb5_encrypt_size(sz, enctype) + 16 > req_output_size)\n                sz--;\n            /* Allow for encrypted copy of header.  */\n            if (sz > 16)\n                sz -= 16;\n            else\n                sz = 0;\n#ifdef CFX_EXERCISE\n            /* Allow for EC padding.  In the MIT implementation, only\n               added while testing.  */\n            if (sz > 65535)\n                sz -= 65535;\n            else\n                sz = 0;\n#endif\n        } else {\n            krb5_cksumtype cksumtype;\n            krb5_error_code err;\n            size_t cksumsize;\n\n            cksumtype = ctx->have_acceptor_subkey ? ctx->acceptor_subkey_cksumtype\n                : ctx->cksumtype;\n\n            err = krb5_c_checksum_length(ctx->k5_context, cksumtype, &cksumsize);\n            if (err) {\n                *minor_status = err;\n                return GSS_S_FAILURE;\n            }\n\n            /* Allow for token header and checksum.  */\n            if (sz < 16 + cksumsize)\n                sz = 0;\n            else\n                sz -= (16 + cksumsize);\n        }\n\n        *max_input_size = sz;\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    /* Calculate the token size and subtract that from the output size */\n    overhead = 7 + ctx->mech_used->length;\n    data_size = req_output_size;\n    conflen = kg_confounder_size(ctx->k5_context, ctx->enc->keyblock.enctype);\n    data_size = (conflen + data_size + 8) & (~(OM_uint32)7);\n    ohlen = g_token_size(ctx->mech_used,\n                         (unsigned int) (data_size + ctx->cksum_size + 14))\n        - req_output_size;\n\n    if (ohlen+overhead < req_output_size)\n        /*\n         * Cannot have trailer length that will cause us to pad over our\n         * length.\n         */\n        *max_input_size = (req_output_size - ohlen - overhead) & (~(OM_uint32)7);\n    else\n        *max_input_size = 0;\n\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}","idx":50,"name":"krb5_gss_wrap_size_limit","project":"27370316410071","target":"True"}
{"commit_id":"241179772367977","func":"bool_t auth_gssapi_unwrap_data(\n     OM_uint32 *major,\n     OM_uint32 *minor,\n     gss_ctx_id_t context,\n     uint32_t seq_num,\n     XDR *in_xdrs,\n     bool_t (*xdr_func)(),\n     caddr_t xdr_ptr)\n{\n     gss_buffer_desc in_buf, out_buf;\n     XDR temp_xdrs;\n     uint32_t verf_seq_num;\n     int conf, qop;\n     unsigned int length;\n\n     PRINTF((\"gssapi_unwrap_data: starting\\n\"));\n\n     *major = GSS_S_COMPLETE;\n     *minor = 0; /* assumption */\n\n     in_buf.value = NULL;\n     out_buf.value = NULL;\n     if (! xdr_bytes(in_xdrs, (char **) &in_buf.value,\n\t\t     &length, (unsigned int) -1)) {\n\t PRINTF((\"gssapi_unwrap_data: deserializing encrypted data failed\\n\"));\n\t temp_xdrs.x_op = XDR_FREE;\n\t (void)xdr_bytes(&temp_xdrs, (char **) &in_buf.value, &length,\n\t\t\t (unsigned int) -1);\n\t return FALSE;\n     }\n     in_buf.length = length;\n\n     *major = gss_unseal(minor, context, &in_buf, &out_buf, &conf,\n\t\t\t &qop);\n     free(in_buf.value);\n     if (*major != GSS_S_COMPLETE)\n\t  return FALSE;\n\n     PRINTF((\"gssapi_unwrap_data: %llu bytes data, %llu bytes sealed\\n\",\n\t     (unsigned long long)out_buf.length,\n\t     (unsigned long long)in_buf.length));\n\n     xdrmem_create(&temp_xdrs, out_buf.value, out_buf.length, XDR_DECODE);\n\n     /* deserialize the sequence number */\n     if (! xdr_u_int32(&temp_xdrs, &verf_seq_num)) {\n\t  PRINTF((\"gssapi_unwrap_data: deserializing verf_seq_num failed\\n\"));\n\t  gss_release_buffer(minor, &out_buf);\n\t  XDR_DESTROY(&temp_xdrs);\n\t  return FALSE;\n     }\n     if (verf_seq_num != seq_num) {\n\t  PRINTF((\"gssapi_unwrap_data: seq %d specified, read %d\\n\",\n\t\t  seq_num, verf_seq_num));\n\t  gss_release_buffer(minor, &out_buf);\n\t  XDR_DESTROY(&temp_xdrs);\n\t  return FALSE;\n     }\n     PRINTF((\"gssapi_unwrap_data: unwrap seq_num %d okay\\n\", verf_seq_num));\n\n     /* deserialize the arguments into xdr_ptr */\n     if (! (*xdr_func)(&temp_xdrs, xdr_ptr)) {\n\t  PRINTF((\"gssapi_unwrap_data: deserializing arguments failed\\n\"));\n\t  gss_release_buffer(minor, &out_buf);\n\t  xdr_free(xdr_func, xdr_ptr);\n\t  XDR_DESTROY(&temp_xdrs);\n\t  return FALSE;\n     }\n\n     PRINTF((\"gssapi_unwrap_data: succeeding\\n\\n\"));\n\n     gss_release_buffer(minor, &out_buf);\n     XDR_DESTROY(&temp_xdrs);\n     return TRUE;\n}","idx":55,"name":"auth_gssapi_unwrap_data","project":"232707072391709","target":"True"}
{"commit_id":"255282874481574","func":"check_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n     size_t slen;\n     char *sdots;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, _(\"check_rpcsec_auth: failed \"\n\t\t\t\t      \"inquire_context, stat=%u\"), maj_stat);\n\t  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     slen = gss_str.length;\n     trunc_name(&slen, &sdots);\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, _(\"bad service principal %.*s%s\"),\n\t\t\t  (int) slen, (char *) gss_str.value, sdots);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}","idx":56,"name":"check_rpcsec_auth","project":"35933147970536","target":"True"}
{"commit_id":"119120452541572","func":"svcauth_gss_accept_sec_context(struct svc_req *rqst,\n\t\t\t       struct rpc_gss_init_res *gr)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tgss_buffer_desc\t\t recv_tok, seqbuf;\n\tgss_OID\t\t\t mech;\n\tOM_uint32\t\t maj_stat = 0, min_stat = 0, ret_flags, seq;\n\n\tlog_debug(\"in svcauth_gss_accept_context()\");\n\n\tgd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\tgc = (struct rpc_gss_cred *)rqst->rq_clntcred;\n\tmemset(gr, 0, sizeof(*gr));\n\n\t/* Deserialize arguments. */\n\tmemset(&recv_tok, 0, sizeof(recv_tok));\n\n\tif (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,\n\t\t\t (caddr_t)&recv_tok))\n\t\treturn (FALSE);\n\n\tgr->gr_major = gss_accept_sec_context(&gr->gr_minor,\n\t\t\t\t\t      &gd->ctx,\n\t\t\t\t\t      svcauth_gss_creds,\n\t\t\t\t\t      &recv_tok,\n\t\t\t\t\t      GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t      &gd->client_name,\n\t\t\t\t\t      &mech,\n\t\t\t\t\t      &gr->gr_token,\n\t\t\t\t\t      &ret_flags,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL);\n\n\tsvc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);\n\n\tlog_status(\"accept_sec_context\", gr->gr_major, gr->gr_minor);\n\tif (gr->gr_major != GSS_S_COMPLETE &&\n\t    gr->gr_major != GSS_S_CONTINUE_NEEDED) {\n\t\tbadauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);\n\t\tgd->ctx = GSS_C_NO_CONTEXT;\n\t\tgoto errout;\n\t}\n\t/*\n\t * ANDROS: krb5 mechglue returns ctx of size 8 - two pointers,\n\t * one to the mechanism oid, one to the internal_ctx_id\n\t */\n\tif ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {\n\t\tfprintf(stderr, \"svcauth_gss_accept_context: out of memory\\n\");\n\t\tgoto errout;\n\t}\n\tmemcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));\n\tgr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);\n\n\t/* gr->gr_win = 0x00000005; ANDROS: for debugging linux kernel version...  */\n\tgr->gr_win = sizeof(gd->seqmask) * 8;\n\n\t/* Save client info. */\n\tgd->sec.mech = mech;\n\tgd->sec.qop = GSS_C_QOP_DEFAULT;\n\tgd->sec.svc = gc->gc_svc;\n\tgd->seq = gc->gc_seq;\n\tgd->win = gr->gr_win;\n\n\tif (gr->gr_major == GSS_S_COMPLETE) {\n#ifdef SPKM\n\t\t/* spkm3: no src_name (anonymous) */\n\t\tif(!g_OID_equal(gss_mech_spkm3, mech)) {\n#endif\n\t\t    maj_stat = gss_display_name(&min_stat, gd->client_name,\n\t\t\t\t\t    &gd->cname, &gd->sec.mech);\n#ifdef SPKM\n\t\t}\n#endif\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tlog_status(\"display_name\", maj_stat, min_stat);\n\t\t\tgoto errout;\n\t\t}\n#ifdef DEBUG\n#ifdef HAVE_HEIMDAL\n\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t  \"<mech {}, qop %d, svc %d>\",\n\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t  gd->sec.qop, gd->sec.svc);\n#else\n\t\t{\n\t\t\tgss_buffer_desc mechname;\n\n\t\t\tgss_oid_to_str(&min_stat, mech, &mechname);\n\n\t\t\tlog_debug(\"accepted context for %.*s with \"\n\t\t\t\t  \"<mech %.*s, qop %d, svc %d>\",\n\t\t\t\t  gd->cname.length, (char *)gd->cname.value,\n\t\t\t\t  mechname.length, (char *)mechname.value,\n\t\t\t\t  gd->sec.qop, gd->sec.svc);\n\n\t\t\tgss_release_buffer(&min_stat, &mechname);\n\t\t}\n#endif\n#endif /* DEBUG */\n\t\tseq = htonl(gr->gr_win);\n\t\tseqbuf.value = &seq;\n\t\tseqbuf.length = sizeof(seq);\n\n\t\tgss_release_buffer(&min_stat, &gd->checksum);\n\t\tmaj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,\n\t\t\t\t    &seqbuf, &gd->checksum);\n\n\t\tif (maj_stat != GSS_S_COMPLETE) {\n\t\t\tgoto errout;\n\t\t}\n\n\n\t\trqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;\n\t\trqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;\n\t\trqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;\n\t}\n\treturn (TRUE);\nerrout:\n\tgss_release_buffer(&min_stat, &gr->gr_token);\n\treturn (FALSE);\n}","idx":58,"name":"svcauth_gss_accept_sec_context","project":"55746502349949","target":"True"}
{"commit_id":"177007419295625","func":"gssrpc__svcauth_gss(struct svc_req *rqst, struct rpc_msg *msg,\n\tbool_t *no_dispatch)\n{\n\tenum auth_stat\t\t retstat;\n\tXDR\t \t\t xdrs;\n\tSVCAUTH\t\t\t*auth;\n\tstruct svc_rpc_gss_data\t*gd;\n\tstruct rpc_gss_cred\t*gc;\n\tstruct rpc_gss_init_res\t gr;\n\tint\t\t\t call_stat, offset;\n\tOM_uint32\t\t min_stat;\n\n\tlog_debug(\"in svcauth_gss()\");\n\n\t/* Initialize reply. */\n\trqst->rq_xprt->xp_verf = gssrpc__null_auth;\n\n\t/* Allocate and set up server auth handle. */\n\tif (rqst->rq_xprt->xp_auth == NULL ||\n\t    rqst->rq_xprt->xp_auth == &svc_auth_none) {\n\t\tif ((auth = calloc(sizeof(*auth), 1)) == NULL) {\n\t\t\tfprintf(stderr, \"svcauth_gss: out_of_memory\\n\");\n\t\t\treturn (AUTH_FAILED);\n\t\t}\n\t\tif ((gd = calloc(sizeof(*gd), 1)) == NULL) {\n\t\t\tfprintf(stderr, \"svcauth_gss: out_of_memory\\n\");\n\t\t\treturn (AUTH_FAILED);\n\t\t}\n\t\tauth->svc_ah_ops = &svc_auth_gss_ops;\n\t\tSVCAUTH_PRIVATE(auth) = gd;\n\t\trqst->rq_xprt->xp_auth = auth;\n\t}\n\telse gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\n\tlog_debug(\"xp_auth=%p, gd=%p\", rqst->rq_xprt->xp_auth, gd);\n\n\t/* Deserialize client credentials. */\n\tif (rqst->rq_cred.oa_length <= 0)\n\t\treturn (AUTH_BADCRED);\n\n\tgc = (struct rpc_gss_cred *)rqst->rq_clntcred;\n\tmemset(gc, 0, sizeof(*gc));\n\n\tlog_debug(\"calling xdrmem_create()\");\n\tlog_debug(\"oa_base=%p, oa_length=%u\", rqst->rq_cred.oa_base,\n\t\t  rqst->rq_cred.oa_length);\n\txdrmem_create(&xdrs, rqst->rq_cred.oa_base,\n\t\t      rqst->rq_cred.oa_length, XDR_DECODE);\n\tlog_debug(\"xdrmem_create() returned\");\n\n\tif (!xdr_rpc_gss_cred(&xdrs, gc)) {\n\t\tlog_debug(\"xdr_rpc_gss_cred() failed\");\n\t\tXDR_DESTROY(&xdrs);\n\t\treturn (AUTH_BADCRED);\n\t}\n\tXDR_DESTROY(&xdrs);\n\n\tretstat = AUTH_FAILED;\n\n#define ret_freegc(code) do { retstat = code; goto freegc; } while (0)\n\n\t/* Check version. */\n\tif (gc->gc_v != RPCSEC_GSS_VERSION)\n\t\tret_freegc (AUTH_BADCRED);\n\n\t/* Check RPCSEC_GSS service. */\n\tif (gc->gc_svc != RPCSEC_GSS_SVC_NONE &&\n\t    gc->gc_svc != RPCSEC_GSS_SVC_INTEGRITY &&\n\t    gc->gc_svc != RPCSEC_GSS_SVC_PRIVACY)\n\t\tret_freegc (AUTH_BADCRED);\n\n\t/* Check sequence number. */\n\tif (gd->established) {\n\t\tif (gc->gc_seq > MAXSEQ)\n\t\t\tret_freegc (RPCSEC_GSS_CTXPROBLEM);\n\n\t\tif ((offset = gd->seqlast - gc->gc_seq) < 0) {\n\t\t\tgd->seqlast = gc->gc_seq;\n\t\t\toffset = 0 - offset;\n\t\t\tgd->seqmask <<= offset;\n\t\t\toffset = 0;\n\t\t} else if ((u_int)offset >= gd->win ||\n\t\t\t   (gd->seqmask & (1 << offset))) {\n\t\t\t*no_dispatch = 1;\n\t\t\tret_freegc (RPCSEC_GSS_CTXPROBLEM);\n\t\t}\n\t\tgd->seq = gc->gc_seq;\n\t\tgd->seqmask |= (1 << offset);\n\t}\n\n\tif (gd->established) {\n\t\trqst->rq_clntname = (char *)gd->client_name;\n\t\trqst->rq_svccred = (char *)gd->ctx;\n\t}\n\n\t/* Handle RPCSEC_GSS control procedure. */\n\tswitch (gc->gc_proc) {\n\n\tcase RPCSEC_GSS_INIT:\n\tcase RPCSEC_GSS_CONTINUE_INIT:\n\t\tif (rqst->rq_proc != NULLPROC)\n\t\t\tret_freegc (AUTH_FAILED);\t\t/* XXX ? */\n\n\t\tif (!svcauth_gss_acquire_cred())\n\t\t\tret_freegc (AUTH_FAILED);\n\n\t\tif (!svcauth_gss_accept_sec_context(rqst, &gr))\n\t\t\tret_freegc (AUTH_REJECTEDCRED);\n\n\t\tif (!svcauth_gss_nextverf(rqst, htonl(gr.gr_win))) {\n\t\t\tgss_release_buffer(&min_stat, &gr.gr_token);\n\t\t\tmem_free(gr.gr_ctx.value,\n\t\t\t\t sizeof(gss_union_ctx_id_desc));\n\t\t\tret_freegc (AUTH_FAILED);\n\t\t}\n\t\t*no_dispatch = TRUE;\n\n\t\tcall_stat = svc_sendreply(rqst->rq_xprt, xdr_rpc_gss_init_res,\n\t\t\t\t\t  (caddr_t)&gr);\n\n\t\tgss_release_buffer(&min_stat, &gr.gr_token);\n\t\tgss_release_buffer(&min_stat, &gd->checksum);\n\t\tmem_free(gr.gr_ctx.value, sizeof(gss_union_ctx_id_desc));\n\t\tif (!call_stat)\n\t\t\tret_freegc (AUTH_FAILED);\n\n\t\tif (gr.gr_major == GSS_S_COMPLETE)\n\t\t\tgd->established = TRUE;\n\n\t\tbreak;\n\n\tcase RPCSEC_GSS_DATA:\n\t\tif (!svcauth_gss_validate(rqst, gd, msg))\n\t\t\tret_freegc (RPCSEC_GSS_CREDPROBLEM);\n\n\t\tif (!svcauth_gss_nextverf(rqst, htonl(gc->gc_seq)))\n \t\t\tret_freegc (AUTH_FAILED);\n\t\tbreak;\n\n\tcase RPCSEC_GSS_DESTROY:\n\t\tif (rqst->rq_proc != NULLPROC)\n\t\t\tret_freegc (AUTH_FAILED);\t\t/* XXX ? */\n\n\t\tif (!svcauth_gss_validate(rqst, gd, msg))\n\t\t\tret_freegc (RPCSEC_GSS_CREDPROBLEM);\n\n\t\tif (!svcauth_gss_nextverf(rqst, htonl(gc->gc_seq)))\n\t\t\tret_freegc (AUTH_FAILED);\n\n\t\t*no_dispatch = TRUE;\n\n\t\tcall_stat = svc_sendreply(rqst->rq_xprt,\n\t\t\t\t\t  xdr_void, (caddr_t)NULL);\n\n\t\tlog_debug(\"sendreply in destroy: %d\", call_stat);\n\n\t\tif (!svcauth_gss_release_cred())\n\t\t\tret_freegc (AUTH_FAILED);\n\n\t\tSVCAUTH_DESTROY(rqst->rq_xprt->xp_auth);\n\t\trqst->rq_xprt->xp_auth = &svc_auth_none;\n\n\t\tbreak;\n\n\tdefault:\n\t\tret_freegc (AUTH_REJECTEDCRED);\n\t\tbreak;\n\t}\n\tretstat = AUTH_OK;\nfreegc:\n\txdr_free(xdr_rpc_gss_cred, gc);\n\tlog_debug(\"returning %d from svcauth_gss()\", retstat);\n\treturn (retstat);\n}","idx":59,"name":"gssrpc__svcauth_gss","project":"55746502349949","target":"True"}
{"commit_id":"37633969996486","func":"int main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_data pname_data, tkt_data;\n    int sock = 0;\n    socklen_t l;\n    int retval;\n    struct sockaddr_in l_inaddr, f_inaddr;        /* local, foreign address */\n    krb5_creds creds, *new_creds;\n    krb5_ccache cc;\n    krb5_data msgtext, msg;\n    krb5_context context;\n    krb5_auth_context auth_context = NULL;\n\n#ifndef DEBUG\n    freopen(\"/tmp/uu-server.log\", \"w\", stderr);\n#endif\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n        exit(1);\n    }\n\n#ifdef DEBUG\n    {\n        int one = 1;\n        int acc;\n        struct servent *sp;\n        socklen_t namelen = sizeof(f_inaddr);\n\n        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {\n            com_err(\"uu-server\", errno, \"creating socket\");\n            exit(3);\n        }\n\n        l_inaddr.sin_family = AF_INET;\n        l_inaddr.sin_addr.s_addr = 0;\n        if (argc == 2) {\n            l_inaddr.sin_port = htons(atoi(argv[1]));\n        } else  {\n            if (!(sp = getservbyname(\"uu-sample\", \"tcp\"))) {\n                com_err(\"uu-server\", 0, \"can't find uu-sample/tcp service\");\n                exit(3);\n            }\n            l_inaddr.sin_port = sp->s_port;\n        }\n\n        (void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (one));\n        if (bind(sock, (struct sockaddr *)&l_inaddr, sizeof(l_inaddr))) {\n            com_err(\"uu-server\", errno, \"binding socket\");\n            exit(3);\n        }\n        if (listen(sock, 1) == -1) {\n            com_err(\"uu-server\", errno, \"listening\");\n            exit(3);\n        }\n\n        printf(\"Server started\\n\");\n        fflush(stdout);\n\n        if ((acc = accept(sock, (struct sockaddr *)&f_inaddr, &namelen)) == -1) {\n            com_err(\"uu-server\", errno, \"accepting\");\n            exit(3);\n        }\n        dup2(acc, 0);\n        close(sock);\n        sock = 0;\n    }\n#endif\n\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);\n    if (retval) {\n        com_err (\"uu-server\", retval, \"reading pname\");\n        return 2;\n    }\n\n    retval = krb5_read_message(context, (krb5_pointer) &sock, &tkt_data);\n    if (retval) {\n        com_err (\"uu-server\", retval, \"reading ticket data\");\n        return 2;\n    }\n\n    retval = krb5_cc_default(context, &cc);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting credentials cache\");\n        return 4;\n    }\n\n    memset (&creds, 0, sizeof(creds));\n    retval = krb5_cc_get_principal(context, cc, &creds.client);\n    if (retval) {\n        com_err(\"uu-client\", retval, \"getting principal name\");\n        return 6;\n    }\n\n    /* client sends it already null-terminated. */\n    printf (\"uu-server: client principal is \\\"%s\\\".\\n\", pname_data.data);\n\n    retval = krb5_parse_name(context, pname_data.data, &creds.server);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"parsing client name\");\n        return 3;\n    }\n\n    creds.second_ticket = tkt_data;\n    printf (\"uu-server: client ticket is %d bytes.\\n\",\n            creds.second_ticket.length);\n\n    retval = krb5_get_credentials(context, KRB5_GC_USER_USER, cc,\n                                  &creds, &new_creds);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"getting user-user ticket\");\n        return 5;\n    }\n\n#ifndef DEBUG\n    l = sizeof(f_inaddr);\n    if (getpeername(0, (struct sockaddr *)&f_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting client address\");\n        return 6;\n    }\n#endif\n    l = sizeof(l_inaddr);\n    if (getsockname(0, (struct sockaddr *)&l_inaddr, &l) == -1)\n    {\n        com_err(\"uu-server\", errno, \"getting local address\");\n        return 6;\n    }\n\n    /* send a ticket/authenticator to the other side, so it can get the key\n       we're using for the krb_safe below. */\n\n    retval = krb5_auth_con_init(context, &auth_context);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making auth_context\");\n        return 8;\n    }\n\n    retval = krb5_auth_con_setflags(context, auth_context,\n                                    KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"initializing the auth_context flags\");\n        return 8;\n    }\n\n    retval =\n        krb5_auth_con_genaddrs(context, auth_context, sock,\n                               KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR |\n                               KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"generating addrs for auth_context\");\n        return 9;\n    }\n\n#if 1\n    retval = krb5_mk_req_extended(context, &auth_context,\n                                  AP_OPTS_USE_SESSION_KEY,\n                                  NULL, new_creds, &msg);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"making AP_REQ\");\n        return 8;\n    }\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n#else\n    retval = krb5_sendauth(context, &auth_context, (krb5_pointer)&sock, \"???\",\n                           0, 0,\n                           AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SESSION_KEY,\n                           NULL, &creds, cc, NULL, NULL, NULL);\n#endif\n    if (retval)\n        goto cl_short_wrt;\n\n    free(msg.data);\n\n    msgtext.length = 32;\n    msgtext.data = \"Hello, other end of connection.\";\n\n    retval = krb5_mk_safe(context, auth_context, &msgtext, &msg, NULL);\n    if (retval) {\n        com_err(\"uu-server\", retval, \"encoding message to client\");\n        return 6;\n    }\n\n    retval = krb5_write_message(context, (krb5_pointer) &sock, &msg);\n    if (retval) {\n    cl_short_wrt:\n        com_err(\"uu-server\", retval, \"writing message to client\");\n        return 7;\n    }\n\n\n    krb5_free_data_contents(context, &msg);\n    krb5_free_data_contents(context, &pname_data);\n    /* tkt_data freed with creds */\n    krb5_free_cred_contents(context, &creds);\n    krb5_free_creds(context, new_creds);\n    krb5_cc_close(context, cc);\n    krb5_auth_con_free(context, auth_context);\n    krb5_free_context(context);\n    return 0;\n}","idx":61,"name":"main","project":"38219574549481","target":"True"}
{"commit_id":"254671331032540","func":"recvauth_common(krb5_context context,\n                krb5_auth_context * auth_context,\n                /* IN */\n                krb5_pointer fd,\n                char *appl_version,\n                krb5_principal server,\n                krb5_int32 flags,\n                krb5_keytab keytab,\n                /* OUT */\n                krb5_ticket ** ticket,\n                krb5_data *version)\n{\n    krb5_auth_context     new_auth_context;\n    krb5_flags            ap_option = 0;\n    krb5_error_code       retval, problem;\n    krb5_data             inbuf;\n    krb5_data             outbuf;\n    krb5_rcache           rcache = 0;\n    krb5_octet            response;\n    krb5_data             null_server;\n    int                   need_error_free = 0;\n    int                   local_rcache = 0, local_authcon = 0;\n\n    /*\n     * Zero out problem variable.  If problem is set at the end of\n     * the intial version negotiation section, it means that we\n     * need to send an error code back to the client application\n     * and exit.\n     */\n    problem = 0;\n    response = 0;\n\n    if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {\n        /*\n         * First read the sendauth version string and check it.\n         */\n        if ((retval = krb5_read_message(context, fd, &inbuf)))\n            return(retval);\n        if (strcmp(inbuf.data, sendauth_version)) {\n            problem = KRB5_SENDAUTH_BADAUTHVERS;\n            response = 1;\n        }\n        free(inbuf.data);\n    }\n    if (flags & KRB5_RECVAUTH_BADAUTHVERS) {\n        problem = KRB5_SENDAUTH_BADAUTHVERS;\n        response = 1;\n    }\n\n    /*\n     * Do the same thing for the application version string.\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return(retval);\n    if (appl_version && strcmp(inbuf.data, appl_version)) {\n        if (!problem) {\n            problem = KRB5_SENDAUTH_BADAPPLVERS;\n            response = 2;\n        }\n    }\n    if (version && !problem)\n        *version = inbuf;\n    else\n        free(inbuf.data);\n\n    /*\n     * Now we actually write the response.  If the response is non-zero,\n     * exit with a return value of problem\n     */\n    if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {\n        return(problem); /* We'll return the top-level problem */\n    }\n    if (problem)\n        return(problem);\n\n    /* We are clear of errors here */\n\n    /*\n     * Now, let's read the AP_REQ message and decode it\n     */\n    if ((retval = krb5_read_message(context, fd, &inbuf)))\n        return retval;\n\n    if (*auth_context == NULL) {\n        problem = krb5_auth_con_init(context, &new_auth_context);\n        *auth_context = new_auth_context;\n        local_authcon = 1;\n    }\n    krb5_auth_con_getrcache(context, *auth_context, &rcache);\n    if ((!problem) && rcache == NULL) {\n        /*\n         * Setup the replay cache.\n         */\n        if (server != NULL && server->length > 0) {\n            problem = krb5_get_server_rcache(context, &server->data[0],\n                                             &rcache);\n        } else {\n            null_server.length = 7;\n            null_server.data = \"default\";\n            problem = krb5_get_server_rcache(context, &null_server, &rcache);\n        }\n        if (!problem)\n            problem = krb5_auth_con_setrcache(context, *auth_context, rcache);\n        local_rcache = 1;\n    }\n    if (!problem) {\n        problem = krb5_rd_req(context, auth_context, &inbuf, server,\n                              keytab, &ap_option, ticket);\n        free(inbuf.data);\n    }\n\n    /*\n     * If there was a problem, send back a krb5_error message,\n     * preceeded by the length of the krb5_error message.  If\n     * everything's ok, send back 0 for the length.\n     */\n    if (problem) {\n        krb5_error      error;\n        const   char *message;\n\n        memset(&error, 0, sizeof(error));\n        krb5_us_timeofday(context, &error.stime, &error.susec);\n        if(server)\n            error.server = server;\n        else {\n            /* If this fails - ie. ENOMEM we are hosed\n               we cannot even send the error if we wanted to... */\n            (void) krb5_parse_name(context, \"????\", &error.server);\n            need_error_free = 1;\n        }\n\n        error.error = problem - ERROR_TABLE_BASE_krb5;\n        if (error.error > 127)\n            error.error = KRB_ERR_GENERIC;\n        message = error_message(problem);\n        error.text.length  = strlen(message) + 1;\n        error.text.data = strdup(message);\n        if (!error.text.data) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        if ((retval = krb5_mk_error(context, &error, &outbuf))) {\n            free(error.text.data);\n            goto cleanup;\n        }\n        free(error.text.data);\n        if(need_error_free)\n            krb5_free_principal(context, error.server);\n\n    } else {\n        outbuf.length = 0;\n        outbuf.data = 0;\n    }\n\n    retval = krb5_write_message(context, fd, &outbuf);\n    if (outbuf.data) {\n        free(outbuf.data);\n        /* We sent back an error, we need cleanup then return */\n        retval = problem;\n        goto cleanup;\n    }\n    if (retval)\n        goto cleanup;\n\n    /* Here lies the mutual authentication stuff... */\n    if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {\n        if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {\n            return(retval);\n        }\n        retval = krb5_write_message(context, fd, &outbuf);\n        free(outbuf.data);\n    }\n\ncleanup:;\n    if (retval) {\n        if (local_authcon) {\n            krb5_auth_con_free(context, *auth_context);\n        } else if (local_rcache && rcache != NULL) {\n            krb5_rc_close(context, rcache);\n            krb5_auth_con_setrcache(context, *auth_context, NULL);\n        }\n    }\n    return retval;\n}","idx":63,"name":"recvauth_common","project":"235879110642374","target":"True"}
{"commit_id":"200624949764419","func":"otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n           krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *pa,\n           krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n           krb5_kdcpreauth_moddata moddata,\n           krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_keyblock *armor_key = NULL;\n    krb5_pa_otp_req *req = NULL;\n    struct request_state *rs;\n    krb5_error_code retval;\n    krb5_data d, plaintext;\n    char *config;\n\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n\n    /* Get the FAST armor key. */\n    armor_key = cb->fast_armor(context, rock);\n    if (armor_key == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        com_err(\"otp\", retval, \"No armor key found when verifying padata\");\n        goto error;\n    }\n\n    /* Decode the request. */\n    d = make_data(pa->contents, pa->length);\n    retval = decode_krb5_pa_otp_req(&d, &req);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to decode OTP request\");\n        goto error;\n    }\n\n    /* Decrypt the nonce from the request. */\n    retval = decrypt_encdata(context, armor_key, req, &plaintext);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to decrypt nonce\");\n        goto error;\n    }\n\n    /* Verify the nonce or timestamp. */\n    retval = nonce_verify(context, armor_key, &plaintext);\n    if (retval != 0)\n        retval = timestamp_verify(context, &plaintext);\n    krb5_free_data_contents(context, &plaintext);\n    if (retval != 0) {\n        com_err(\"otp\", retval, \"Unable to verify nonce or timestamp\");\n        goto error;\n    }\n\n    /* Create the request state. */\n    rs = k5alloc(sizeof(struct request_state), &retval);\n    if (rs == NULL)\n        goto error;\n    rs->arg = arg;\n    rs->respond = respond;\n\n    /* Get the principal's OTP configuration string. */\n    retval = cb->get_string(context, rock, \"otp\", &config);\n    if (retval == 0 && config == NULL)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval != 0) {\n        free(rs);\n        goto error;\n    }\n\n    /* Send the request. */\n    otp_state_verify((otp_state *)moddata, cb->event_context(context, rock),\n                     request->client, config, req, on_response, rs);\n    cb->free_string(context, rock, config);\n\n    k5_free_pa_otp_req(context, req);\n    return;\n\nerror:\n    k5_free_pa_otp_req(context, req);\n    (*respond)(arg, retval, NULL, NULL, NULL);\n}","idx":65,"name":"otp_verify","project":"139763343306592","target":"True"}
{"commit_id":"9640692575439","func":"pkinit_server_verify_padata(krb5_context context,\n                            krb5_data *req_pkt,\n                            krb5_kdc_req * request,\n                            krb5_enc_tkt_part * enc_tkt_reply,\n                            krb5_pa_data * data,\n                            krb5_kdcpreauth_callbacks cb,\n                            krb5_kdcpreauth_rock rock,\n                            krb5_kdcpreauth_moddata moddata,\n                            krb5_kdcpreauth_verify_respond_fn respond,\n                            void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};\n    krb5_pa_pk_as_req *reqp = NULL;\n    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;\n    krb5_auth_pack *auth_pack = NULL;\n    krb5_auth_pack_draft9 *auth_pack9 = NULL;\n    pkinit_kdc_context plgctx = NULL;\n    pkinit_kdc_req_context reqctx = NULL;\n    krb5_checksum cksum = {0, 0, 0, NULL};\n    krb5_data *der_req = NULL;\n    int valid_eku = 0, valid_san = 0;\n    krb5_data k5data;\n    int is_signed = 1;\n    krb5_pa_data **e_data = NULL;\n    krb5_kdcpreauth_modreq modreq = NULL;\n\n    pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n    if (data == NULL || data->length <= 0 || data->contents == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n\n    if (moddata == NULL) {\n        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n        return;\n    }\n\n    plgctx = pkinit_find_realm_context(context, moddata, request->server);\n    if (plgctx == NULL) {\n        (*respond)(arg, 0, NULL, NULL, NULL);\n        return;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(data->contents, data->length, \"/tmp/kdc_as_req\");\n#endif\n    /* create a per-request context */\n    retval = pkinit_init_kdc_req_context(context, &reqctx);\n    if (retval)\n        goto cleanup;\n    reqctx->pa_type = data->pa_type;\n\n    PADATA_TO_KRB5DATA(data, &k5data);\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp->signedAuthPack.data,\n                         reqp->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data\");\n#endif\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, &is_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        pkiDebug(\"processing KRB5_PADATA_PK_AS_REQ_OLD\\n\");\n        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);\n        if (retval) {\n            pkiDebug(\"decode_krb5_pa_pk_as_req_draft9 failed\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_ASN1\n        print_buffer_bin(reqp9->signedAuthPack.data,\n                         reqp9->signedAuthPack.length,\n                         \"/tmp/kdc_signed_data_draft9\");\n#endif\n\n        retval = cms_signeddata_verify(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,\n                                       plgctx->opts->require_crl_checking,\n                                       (unsigned char *)\n                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,\n                                       (unsigned char **)&authp_data.data,\n                                       &authp_data.length,\n                                       (unsigned char **)&krb5_authz.data,\n                                       &krb5_authz.length, NULL);\n        break;\n    default:\n        pkiDebug(\"unrecognized pa_type = %d\\n\", data->pa_type);\n        retval = EINVAL;\n        goto cleanup;\n    }\n    if (retval) {\n        pkiDebug(\"pkcs7_signeddata_verify failed\\n\");\n        goto cleanup;\n    }\n    if (is_signed) {\n\n        retval = verify_client_san(context, plgctx, reqctx, request->client,\n                                   &valid_san);\n        if (retval)\n            goto cleanup;\n        if (!valid_san) {\n            pkiDebug(\"%s: did not find an acceptable SAN in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n            goto cleanup;\n        }\n        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);\n        if (retval)\n            goto cleanup;\n\n        if (!valid_eku) {\n            pkiDebug(\"%s: did not find an acceptable EKU in user \"\n                     \"certificate\\n\", __FUNCTION__);\n            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n            goto cleanup;\n        }\n    } else { /* !is_signed */\n        if (!krb5_principal_compare(context, request->client,\n                                    krb5_anonymous_principal())) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Pkinit request not signed, but client \"\n                                     \"not anonymous.\"));\n            goto cleanup;\n        }\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin(authp_data.data, authp_data.length, \"/tmp/kdc_auth_pack\");\n#endif\n\n    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack\\n\");\n            goto cleanup;\n        }\n\n        retval = krb5_check_clockskew(context,\n                                      auth_pack->pkAuthenticator.ctime);\n        if (retval)\n            goto cleanup;\n\n        /* check dh parameters */\n        if (auth_pack->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        } else if (!is_signed) {\n            /*Anonymous pkinit requires DH*/\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Anonymous pkinit without DH public \"\n                                     \"value not supported.\"));\n            goto cleanup;\n        }\n        der_req = cb->request_body(context, rock);\n        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,\n                                      0, der_req, &cksum);\n        if (retval) {\n            pkiDebug(\"unable to calculate AS REQ checksum\\n\");\n            goto cleanup;\n        }\n        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||\n            k5_bcmp(cksum.contents,\n                    auth_pack->pkAuthenticator.paChecksum.contents,\n                    cksum.length) != 0) {\n            pkiDebug(\"failed to match the checksum\\n\");\n#ifdef DEBUG_CKSUM\n            pkiDebug(\"calculating checksum on buf size (%d)\\n\",\n                     req_pkt->length);\n            print_buffer(req_pkt->data, req_pkt->length);\n            pkiDebug(\"received checksum type=%d size=%d \",\n                     auth_pack->pkAuthenticator.paChecksum.checksum_type,\n                     auth_pack->pkAuthenticator.paChecksum.length);\n            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,\n                         auth_pack->pkAuthenticator.paChecksum.length);\n            pkiDebug(\"expected checksum type=%d size=%d \",\n                     cksum.checksum_type, cksum.length);\n            print_buffer(cksum.contents, cksum.length);\n#endif\n\n            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;\n            goto cleanup;\n        }\n\n        /* check if kdcPkId present and match KDC's subjectIdentifier */\n        if (reqp->kdcPkId.data != NULL) {\n            int valid_kdcPkId = 0;\n            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,\n                                           reqctx->cryptoctx, plgctx->idctx,\n                                           (unsigned char *)reqp->kdcPkId.data,\n                                           reqp->kdcPkId.length, &valid_kdcPkId);\n            if (retval)\n                goto cleanup;\n            if (!valid_kdcPkId)\n                pkiDebug(\"kdcPkId in AS_REQ does not match KDC's cert\"\n                         \"RFC says to ignore and proceed\\n\");\n\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack = auth_pack;\n        auth_pack = NULL;\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);\n        if (retval) {\n            pkiDebug(\"failed to decode krb5_auth_pack_draft9\\n\");\n            goto cleanup;\n        }\n        if (auth_pack9->clientPublicValue != NULL) {\n            retval = server_check_dh(context, plgctx->cryptoctx,\n                                     reqctx->cryptoctx, plgctx->idctx,\n                                     &auth_pack9->clientPublicValue->algorithm.parameters,\n                                     plgctx->opts->dh_min_bits);\n\n            if (retval) {\n                pkiDebug(\"bad dh parameters\\n\");\n                goto cleanup;\n            }\n        }\n        /* remember the decoded auth_pack for verify_padata routine */\n        reqctx->rcv_auth_pack9 = auth_pack9;\n        auth_pack9 = NULL;\n        break;\n    }\n\n    /* remember to set the PREAUTH flag in the reply */\n    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    modreq = (krb5_kdcpreauth_modreq)reqctx;\n    reqctx = NULL;\n\ncleanup:\n    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {\n        pkiDebug(\"pkinit_verify_padata failed: creating e-data\\n\");\n        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,\n                                plgctx->idctx, plgctx->opts, retval, &e_data))\n            pkiDebug(\"pkinit_create_edata failed\\n\");\n    }\n\n    switch ((int)data->pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        free_krb5_pa_pk_as_req(&reqp);\n        free(cksum.contents);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        free_krb5_pa_pk_as_req_draft9(&reqp9);\n    }\n    free(authp_data.data);\n    free(krb5_authz.data);\n    if (reqctx != NULL)\n        pkinit_fini_kdc_req_context(context, reqctx);\n    free_krb5_auth_pack(&auth_pack);\n    free_krb5_auth_pack_draft9(context, &auth_pack9);\n\n    (*respond)(arg, retval, modreq, e_data, NULL);\n}","idx":68,"name":"pkinit_server_verify_padata","project":"114623562961833","target":"True"}
{"commit_id":"106464243455518","func":"spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}","idx":70,"name":"spnego_gss_wrap_aead","project":"180227160492611","target":"True"}
{"commit_id":"221023929339196","func":"spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}","idx":71,"name":"spnego_gss_export_sec_context","project":"180227160492611","target":"True"}
{"commit_id":"76276784811102","func":"acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}","idx":72,"name":"acc_ctx_hints","project":"180227160492611","target":"True"}
{"commit_id":"135605868093620","func":"spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}","idx":73,"name":"spnego_gss_wrap","project":"180227160492611","target":"True"}
{"commit_id":"141036916552895","func":"spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}","idx":74,"name":"spnego_gss_verify_mic_iov","project":"180227160492611","target":"True"}
{"commit_id":"184502850686316","func":"spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}","idx":75,"name":"spnego_gss_inquire_sec_context_by_oid","project":"180227160492611","target":"True"}
{"commit_id":"18030766984490","func":"spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}","idx":76,"name":"spnego_gss_process_context_token","project":"180227160492611","target":"True"}
{"commit_id":"49819907549582","func":"spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}","idx":77,"name":"spnego_gss_unwrap_aead","project":"180227160492611","target":"True"}
{"commit_id":"207100022357577","func":"spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}","idx":78,"name":"spnego_gss_pseudo_random","project":"180227160492611","target":"True"}
{"commit_id":"112705549886834","func":"spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}","idx":79,"name":"spnego_gss_import_sec_context","project":"180227160492611","target":"True"}
{"commit_id":"138845684273842","func":"spnego_gss_init_sec_context(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t claimant_cred_handle,\n\t\t\tgss_ctx_id_t *context_handle,\n\t\t\tgss_name_t target_name,\n\t\t\tgss_OID mech_type,\n\t\t\tOM_uint32 req_flags,\n\t\t\tOM_uint32 time_req,\n\t\t\tgss_channel_bindings_t input_chan_bindings,\n\t\t\tgss_buffer_t input_token,\n\t\t\tgss_OID *actual_mech,\n\t\t\tgss_buffer_t output_token,\n\t\t\tOM_uint32 *ret_flags,\n\t\t\tOM_uint32 *time_rec)\n{\n\tsend_token_flag send_token = NO_TOKEN_SEND;\n\tOM_uint32 tmpmin, ret, negState;\n\tgss_buffer_t mechtok_in, mechListMIC_in, mechListMIC_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\n\tdsyslog(\"Entering init_sec_context\\n\");\n\n\tmechtok_in = mechListMIC_out = mechListMIC_in = GSS_C_NO_BUFFER;\n\tnegState = REJECT;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated or optimistic mech's gss_init_sec_context\n\t *      function and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * The three steps share responsibility for determining when the\n\t * exchange is complete.  If the selected mech completed in a previous\n\t * call and no MIC exchange is expected, then step 1 will decide.  If\n\t * the selected mech completes in this call and no MIC exchange is\n\t * expected, then step 2 will decide.  If a MIC exchange is expected,\n\t * then step 3 will decide.  If an error occurs in any step, the\n\t * exchange will be aborted, possibly with an error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * send_token is used to indicate what type of token, if any, should be\n\t * generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (actual_mech != NULL)\n\t\t*actual_mech = GSS_C_NO_OID;\n\n\t/* Step 1: perform mechanism negotiation. */\n\tspcred = (spnego_gss_cred_id_t)claimant_cred_handle;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t\tret = init_ctx_new(minor_status, spcred,\n\t\t\t\t   context_handle, &send_token);\n\t\tif (ret != GSS_S_CONTINUE_NEEDED) {\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tret = init_ctx_cont(minor_status, context_handle,\n\t\t\t\t    input_token, &mechtok_in,\n\t\t\t\t    &mechListMIC_in, &negState, &send_token);\n\t\tif (HARD_ERROR(ret)) {\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Step 2: invoke the selected or optimistic mechanism's\n\t * gss_init_sec_context function, if it didn't complete previously. */\n\tspnego_ctx = (spnego_gss_ctx_id_t)*context_handle;\n\tif (!spnego_ctx->mech_complete) {\n\t\tret = init_ctx_call_init(\n\t\t\tminor_status, spnego_ctx, spcred,\n\t\t\ttarget_name, req_flags,\n\t\t\ttime_req, mechtok_in,\n\t\t\tactual_mech, &mechtok_out,\n\t\t\tret_flags, time_rec,\n\t\t\t&negState, &send_token);\n\n\t\t/* Give the mechanism a chance to force a mechlistMIC. */\n\t\tif (!HARD_ERROR(ret) && mech_requires_mechlistMIC(spnego_ctx))\n\t\t\tspnego_ctx->mic_reqd = 1;\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && spnego_ctx->mech_complete &&\n\t    (spnego_ctx->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status,\n\t\t\t\t mechListMIC_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t spnego_ctx, &mechListMIC_out,\n\t\t\t\t &negState, &send_token);\n\t}\ncleanup:\n\tif (send_token == INIT_TOKEN_SEND) {\n\t\tif (make_spnego_tokenInit_msg(spnego_ctx,\n\t\t\t\t\t      0,\n\t\t\t\t\t      mechListMIC_out,\n\t\t\t\t\t      req_flags,\n\t\t\t\t\t      &mechtok_out, send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\t/*\n\t\t * Now, switch the output context to refer to the\n\t\t * negotiated mechanism's context.\n\t\t */\n\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t\trelease_spnego_ctx(&spnego_ctx);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mechListMIC_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_in);\n\t\tfree(mechListMIC_in);\n\t}\n\tif (mechListMIC_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechListMIC_out);\n\t\tfree(mechListMIC_out);\n\t}\n\treturn ret;\n} /* init_sec_context */","idx":80,"name":"spnego_gss_init_sec_context","project":"180227160492611","target":"True"}
{"commit_id":"213511587979935","func":"spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}","idx":81,"name":"spnego_gss_set_sec_context_option","project":"180227160492611","target":"True"}
{"commit_id":"16151484690564","func":"spnego_gss_accept_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_cred_id_t verifier_cred_handle,\n\t\t\t    gss_buffer_t input_token,\n\t\t\t    gss_channel_bindings_t input_chan_bindings,\n\t\t\t    gss_name_t *src_name,\n\t\t\t    gss_OID *mech_type,\n\t\t\t    gss_buffer_t output_token,\n\t\t\t    OM_uint32 *ret_flags,\n\t\t\t    OM_uint32 *time_rec,\n\t\t\t    gss_cred_id_t *delegated_cred_handle)\n{\n\tOM_uint32 ret, tmpmin, negState;\n\tsend_token_flag return_token;\n\tgss_buffer_t mechtok_in, mic_in, mic_out;\n\tgss_buffer_desc mechtok_out = GSS_C_EMPTY_BUFFER;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tint sendTokenInit = 0, tmpret;\n\n\tmechtok_in = mic_in = mic_out = GSS_C_NO_BUFFER;\n\n\t/*\n\t * This function works in three steps:\n\t *\n\t *   1. Perform mechanism negotiation.\n\t *   2. Invoke the negotiated mech's gss_accept_sec_context function\n\t *      and examine the results.\n\t *   3. Process or generate MICs if necessary.\n\t *\n\t * Step one determines whether the negotiation requires a MIC exchange,\n\t * while steps two and three share responsibility for determining when\n\t * the exchange is complete.  If the selected mech completes in this\n\t * call and no MIC exchange is expected, then step 2 will decide.  If a\n\t * MIC exchange is expected, then step 3 will decide.  If an error\n\t * occurs in any step, the exchange will be aborted, possibly with an\n\t * error token.\n\t *\n\t * negState determines the state of the negotiation, and is\n\t * communicated to the acceptor if a continuing token is sent.\n\t * return_token is used to indicate what type of token, if any, should\n\t * be generated.\n\t */\n\n\t/* Validate arguments. */\n\tif (minor_status != NULL)\n\t\t*minor_status = 0;\n\tif (output_token != GSS_C_NO_BUFFER) {\n\t\toutput_token->length = 0;\n\t\toutput_token->value = NULL;\n\t}\n\n\tif (minor_status == NULL ||\n\t    output_token == GSS_C_NO_BUFFER ||\n\t    context_handle == NULL)\n\t\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n\tif (input_token == GSS_C_NO_BUFFER)\n\t\treturn GSS_S_CALL_INACCESSIBLE_READ;\n\n\t/* Step 1: Perform mechanism negotiation. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\tspcred = (spnego_gss_cred_id_t)verifier_cred_handle;\n\tif (sc == NULL || sc->internal_mech == GSS_C_NO_OID) {\n\t\t/* Process an initial token or request for NegHints. */\n\t\tif (src_name != NULL)\n\t\t\t*src_name = GSS_C_NO_NAME;\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = GSS_C_NO_OID;\n\t\tif (time_rec != NULL)\n\t\t\t*time_rec = 0;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = 0;\n\t\tif (delegated_cred_handle != NULL)\n\t\t\t*delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n\t\tif (input_token->length == 0) {\n\t\t\tret = acc_ctx_hints(minor_status,\n\t\t\t\t\t    context_handle, spcred,\n\t\t\t\t\t    &mic_out,\n\t\t\t\t\t    &negState,\n\t\t\t\t\t    &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tsendTokenInit = 1;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t} else {\n\t\t\t/* Can set negState to REQUEST_MIC */\n\t\t\tret = acc_ctx_new(minor_status, input_token,\n\t\t\t\t\t  context_handle, spcred,\n\t\t\t\t\t  &mechtok_in, &mic_in,\n\t\t\t\t\t  &negState, &return_token);\n\t\t\tif (ret != GSS_S_COMPLETE)\n\t\t\t\tgoto cleanup;\n\t\t\tret = GSS_S_CONTINUE_NEEDED;\n\t\t}\n\t} else {\n\t\t/* Process a response token.  Can set negState to\n\t\t * ACCEPT_INCOMPLETE. */\n\t\tret = acc_ctx_cont(minor_status, input_token,\n\t\t\t\t   context_handle, &mechtok_in,\n\t\t\t\t   &mic_in, &negState, &return_token);\n\t\tif (ret != GSS_S_COMPLETE)\n\t\t\tgoto cleanup;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\n\t/* Step 2: invoke the negotiated mechanism's gss_accept_sec_context\n\t * function. */\n\tsc = (spnego_gss_ctx_id_t)*context_handle;\n\t/*\n\t * Handle mechtok_in and mic_in only if they are\n\t * present in input_token.  If neither is present, whether\n\t * this is an error depends on whether this is the first\n\t * round-trip.  RET is set to a default value according to\n\t * whether it is the first round-trip.\n\t */\n\tif (negState != REQUEST_MIC && mechtok_in != GSS_C_NO_BUFFER) {\n\t\tret = acc_ctx_call_acc(minor_status, sc, spcred,\n\t\t\t\t       mechtok_in, mech_type, &mechtok_out,\n\t\t\t\t       ret_flags, time_rec,\n\t\t\t\t       delegated_cred_handle,\n\t\t\t\t       &negState, &return_token);\n\t}\n\n\t/* Step 3: process or generate the MIC, if the negotiated mech is\n\t * complete and supports MICs. */\n\tif (!HARD_ERROR(ret) && sc->mech_complete &&\n\t    (sc->ctx_flags & GSS_C_INTEG_FLAG)) {\n\n\t\tret = handle_mic(minor_status, mic_in,\n\t\t\t\t (mechtok_out.length != 0),\n\t\t\t\t sc, &mic_out,\n\t\t\t\t &negState, &return_token);\n\t}\ncleanup:\n\tif (return_token == INIT_TOKEN_SEND && sendTokenInit) {\n\t\tassert(sc != NULL);\n\t\ttmpret = make_spnego_tokenInit_msg(sc, 1, mic_out, 0,\n\t\t\t\t\t\t   GSS_C_NO_BUFFER,\n\t\t\t\t\t\t   return_token, output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t} else if (return_token != NO_TOKEN_SEND &&\n\t\t   return_token != CHECK_MIC) {\n\t\ttmpret = make_spnego_tokenTarg_msg(negState,\n\t\t\t\t\t\t   sc ? sc->internal_mech :\n\t\t\t\t\t\t   GSS_C_NO_OID,\n\t\t\t\t\t\t   &mechtok_out, mic_out,\n\t\t\t\t\t\t   return_token,\n\t\t\t\t\t\t   output_token);\n\t\tif (tmpret < 0)\n\t\t\tret = GSS_S_FAILURE;\n\t}\n\tif (ret == GSS_S_COMPLETE) {\n\t\t*context_handle = (gss_ctx_id_t)sc->ctx_handle;\n\t\tif (sc->internal_name != GSS_C_NO_NAME &&\n\t\t    src_name != NULL) {\n\t\t\t*src_name = sc->internal_name;\n\t\t\tsc->internal_name = GSS_C_NO_NAME;\n\t\t}\n\t\trelease_spnego_ctx(&sc);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (sc != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&sc);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (mechtok_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mechtok_in);\n\t\tfree(mechtok_in);\n\t}\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_in);\n\t\tfree(mic_in);\n\t}\n\tif (mic_out != GSS_C_NO_BUFFER) {\n\t\tgss_release_buffer(&tmpmin, mic_out);\n\t\tfree(mic_out);\n\t}\n\treturn ret;\n}","idx":82,"name":"spnego_gss_accept_sec_context","project":"180227160492611","target":"True"}
{"commit_id":"194168860922846","func":"spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}","idx":83,"name":"spnego_gss_get_mic_iov_length","project":"180227160492611","target":"True"}
{"commit_id":"233266646437811","func":"spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}","idx":84,"name":"spnego_gss_inquire_context","project":"180227160492611","target":"True"}
{"commit_id":"194521507589805","func":"spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}","idx":85,"name":"spnego_gss_wrap_size_limit","project":"180227160492611","target":"True"}
{"commit_id":"217506816517441","func":"spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}","idx":86,"name":"spnego_gss_verify_mic","project":"180227160492611","target":"True"}
{"commit_id":"80696893869557","func":"spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t/*\n\t * If this is still an SPNEGO mech, release it locally.\n\t */\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}","idx":87,"name":"spnego_gss_delete_sec_context","project":"180227160492611","target":"True"}
{"commit_id":"227753349348433","func":"spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}","idx":88,"name":"spnego_gss_wrap_iov","project":"180227160492611","target":"True"}
