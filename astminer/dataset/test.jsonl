{"commit_id":"133036088395237","func":"validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}","idx":216,"name":"validate_as_request","project":"9681320992537","target":"False"}
{"commit_id":"111709692895491","func":"finish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0 && state->status == NULL)\n        state->status = \"UNKNOWN_REASON\";\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}","idx":218,"name":"finish_process_as_req","project":"17097258194479","target":"False"}
{"commit_id":"23411325922940","func":"process_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}","idx":220,"name":"process_tgs_req","project":"148064544610761","target":"False"}
{"commit_id":"264065904775821","func":"kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code) {\n        *status = \"DECODE_PA_FOR_USER\";\n        return code;\n    }\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}","idx":223,"name":"kdc_process_for_user","project":"42207620444893","target":"False"}
{"commit_id":"69948184766856","func":"kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code) {\n        *status = \"DECODE_PA_S4U_X509_USER\";\n        return code;\n    }\n\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n\n    return 0;\n}","idx":224,"name":"kdc_process_s4u_x509_user","project":"42207620444893","target":"False"}
{"commit_id":"31375870066876","func":"kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n\n    /*\n     * Constrained delegation is mutually exclusive with renew/forward/etc.\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /* Ensure that evidence ticket server matches TGT client */\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, /* after canon */\n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n\n    /* Backend policy check */\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n\n    return 0;\n}","idx":225,"name":"kdc_process_s4u2proxy_req","project":"42207620444893","target":"False"}
{"commit_id":"148342731372537","func":"gss_accept_sec_context (minor_status,\n                        context_handle,\n                        verifier_cred_handle,\n                        input_token_buffer,\n                        input_chan_bindings,\n                        src_name,\n                        mech_type,\n                        output_token,\n                        ret_flags,\n                        time_rec,\n                        d_cred)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n\n{\n    OM_uint32\t\tstatus, temp_status, temp_minor_status;\n    OM_uint32\t\ttemp_ret_flags = 0;\n    gss_union_ctx_id_t\tunion_ctx_id = NULL;\n    gss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\n    gss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\n    gss_name_t\t\tinternal_name = GSS_C_NO_NAME;\n    gss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\n    gss_OID_desc\ttoken_mech_type_desc;\n    gss_OID\t\ttoken_mech_type = &token_mech_type_desc;\n    gss_OID\t\tactual_mech = GSS_C_NO_OID;\n    gss_OID\t\tselected_mech = GSS_C_NO_OID;\n    gss_OID\t\tpublic_mech;\n    gss_mechanism\tmech = NULL;\n    gss_union_cred_t\tuc;\n    int\t\t\ti;\n\n    status = val_acc_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  verifier_cred_handle,\n\t\t\t\t  input_token_buffer,\n\t\t\t\t  input_chan_bindings,\n\t\t\t\t  src_name,\n\t\t\t\t  mech_type,\n\t\t\t\t  output_token,\n\t\t\t\t  ret_flags,\n\t\t\t\t  time_rec,\n\t\t\t\t  d_cred);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\n\tif (input_token_buffer == GSS_C_NO_BUFFER)\n\t    return (GSS_S_CALL_INACCESSIBLE_READ);\n\n\t/* Get the token mech type */\n\tstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\n\tif (status)\n\t    return status;\n\n\t/*\n\t * An interposer calling back into the mechglue can't pass in a special\n\t * mech, so we have to recognize it using verifier_cred_handle.  Use\n\t * the mechanism for which we have matching creds, if available.\n\t */\n\tif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\t    uc = (gss_union_cred_t)verifier_cred_handle;\n\t    for (i = 0; i < uc->count; i++) {\n\t\tpublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\n\t\tif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\n\t\t    selected_mech = &uc->mechs_array[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\tif (selected_mech == GSS_C_NO_OID) {\n\t    status = gssint_select_mech_type(minor_status, token_mech_type,\n\t\t\t\t\t     &selected_mech);\n\t    if (status)\n\t\treturn status;\n\t}\n\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tselected_mech = union_ctx_id->mech_type;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n    }\n\n    /* Now create a new context if we didn't get one. */\n    if (*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (!union_ctx_id)\n\t    return (GSS_S_FAILURE);\n\n\tunion_ctx_id->loopback = union_ctx_id;\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n\tstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t      &union_ctx_id->mech_type);\n\tif (status != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    return (status);\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     */\n    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\tinput_cred_handle =\n\t    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\n\t\t\t\t      selected_mech);\n\tif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\n\t    /* verifier credential specified but no acceptor credential found */\n\t    status = GSS_S_NO_CRED;\n\t    goto error_out;\n\t}\n    } else if (!allow_mech_by_default(selected_mech)) {\n\tstatus = GSS_S_NO_CRED;\n\tgoto error_out;\n    }\n\n    /*\n     * now select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech && mech->gss_accept_sec_context) {\n\n\t    status = mech->gss_accept_sec_context(minor_status,\n\t\t\t\t\t\t  &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t\t  input_cred_handle,\n\t\t\t\t\t\t  input_token_buffer,\n\t\t\t\t\t\t  input_chan_bindings,\n\t\t\t\t\t\t  src_name ? &internal_name : NULL,\n\t\t\t\t\t\t  &actual_mech,\n\t\t\t\t\t\t  output_token,\n\t\t\t\t\t\t  &temp_ret_flags,\n\t\t\t\t\t\t  time_rec,\n\t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n\n\t    /* If there's more work to do, keep going... */\n\t    if (status == GSS_S_CONTINUE_NEEDED) {\n\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n\t\treturn GSS_S_CONTINUE_NEEDED;\n\t    }\n\n\t    /* if the call failed, return with failure */\n\t    if (status != GSS_S_COMPLETE) {\n\t\tmap_error(minor_status, mech);\n\t\tgoto error_out;\n\t    }\n\n\t    /*\n\t     * if src_name is non-NULL,\n\t     * convert internal_name into a union name equivalent\n\t     * First call the mechanism specific display_name()\n\t     * then call gss_import_name() to create\n\t     * the union name struct cast to src_name\n\t     */\n\t    if (src_name != NULL) {\n\t\tif (internal_name != GSS_C_NO_NAME) {\n\t\t    /* consumes internal_name regardless of success */\n\t\t    temp_status = gssint_convert_name_to_union_name(\n\t\t\t    &temp_minor_status, mech,\n\t\t\t    internal_name, &tmp_src_name);\n\t\t    if (temp_status != GSS_S_COMPLETE) {\n\t\t\tstatus = temp_status;\n\t\t\t*minor_status = temp_minor_status;\n\t\t\tmap_error(minor_status, mech);\n\t\t\tif (output_token->length)\n\t\t\t    (void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t\t\t      output_token);\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    *src_name = tmp_src_name;\n\t\t} else\n\t\t    *src_name = GSS_C_NO_NAME;\n\t    }\n\n#define g_OID_prefix_equal(o1, o2) \\\n        (((o1)->length >= (o2)->length) && \\\n        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n\t    /* Ensure we're returning correct creds format */\n\t    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\n\t\ttmp_d_cred != GSS_C_NO_CREDENTIAL) {\n\t\tpublic_mech = gssint_get_public_oid(selected_mech);\n\t\tif (actual_mech != GSS_C_NO_OID &&\n\t\t    public_mech != GSS_C_NO_OID &&\n\t\t    !g_OID_prefix_equal(actual_mech, public_mech)) {\n\t\t    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */\n\t\t} else {\n\t\t    gss_union_cred_t d_u_cred = NULL;\n\n\t\t    d_u_cred = malloc(sizeof (gss_union_cred_desc));\n\t\t    if (d_u_cred == NULL) {\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\n\n\t\t    d_u_cred->count = 1;\n\n\t\t    status = generic_gss_copy_oid(&temp_minor_status,\n\t\t\t\t\t\t  selected_mech,\n\t\t\t\t\t\t  &d_u_cred->mechs_array);\n\n\t\t    if (status != GSS_S_COMPLETE) {\n\t\t\tfree(d_u_cred);\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\n\t\t    if (d_u_cred->cred_array != NULL) {\n\t\t\td_u_cred->cred_array[0] = tmp_d_cred;\n\t\t    } else {\n\t\t\tfree(d_u_cred);\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->loopback = d_u_cred;\n\t\t    *d_cred = (gss_cred_id_t)d_u_cred;\n\t\t}\n\t    }\n\n\t    if (mech_type != NULL)\n\t\t*mech_type = gssint_get_public_oid(actual_mech);\n\t    if (ret_flags != NULL)\n\t\t*ret_flags = temp_ret_flags;\n\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n\t    return GSS_S_COMPLETE;\n    } else {\n\n\tstatus = GSS_S_BAD_MECH;\n    }\n\nerror_out:\n\t/*\n\t * RFC 2744 5.1 requires that we not create a context on a failed first\n\t * call to accept, and recommends that on a failed subsequent call we\n\t * make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n\tif (union_ctx_id->mech_type) {\n\t    if (union_ctx_id->mech_type->elements)\n\t\tfree(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t}\n\tif (union_ctx_id->internal_ctx_id && mech &&\n\t    mech->gss_delete_sec_context) {\n\t    mech->gss_delete_sec_context(&temp_minor_status,\n\t\t\t\t\t &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t GSS_C_NO_BUFFER);\n\t}\n\tfree(union_ctx_id);\n    }\n\n    if (src_name)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (tmp_src_name != GSS_C_NO_NAME)\n\t(void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t  (gss_buffer_t)tmp_src_name);\n\n    return (status);\n}","idx":227,"name":"gss_accept_sec_context","project":"110511205440666","target":"False"}
{"commit_id":"46893467210392","func":"gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}","idx":228,"name":"gss_complete_auth_token","project":"237791278275692","target":"False"}
{"commit_id":"8636816965298","func":"gss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}","idx":229,"name":"gss_context_time","project":"45908064611434","target":"False"}
{"commit_id":"189129532496444","func":"gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}","idx":231,"name":"gss_delete_sec_context","project":"126719386548325","target":"False"}
{"commit_id":"205410941517296","func":"gss_export_sec_context(minor_status,\n                       context_handle,\n                       interprocess_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\tinterprocess_token;\n\n{\n    OM_uint32\t\tstatus;\n    OM_uint32 \t\tlength;\n    gss_union_ctx_id_t\tctx = NULL;\n    gss_mechanism\tmech;\n    gss_buffer_desc\ttoken = GSS_C_EMPTY_BUFFER;\n    char\t\t*buf;\n\n    status = val_exp_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle, interprocess_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn GSS_S_BAD_MECH;\n    if (!mech->gss_export_sec_context)\n\treturn (GSS_S_UNAVAILABLE);\n\n    status = mech->gss_export_sec_context(minor_status,\n\t\t\t\t\t  &ctx->internal_ctx_id, &token);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\tgoto cleanup;\n    }\n\n    length = token.length + 4 + ctx->mech_type->length;\n    interprocess_token->length = length;\n    interprocess_token->value = malloc(length);\n    if (interprocess_token->value == 0) {\n\t*minor_status = ENOMEM;\n\tstatus = GSS_S_FAILURE;\n\tgoto cleanup;\n    }\n    buf = interprocess_token->value;\n    length = ctx->mech_type->length;\n    buf[3] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[2] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[1] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[0] = (unsigned char) (length & 0xFF);\n    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);\n    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);\n\n    status = GSS_S_COMPLETE;\n\ncleanup:\n    (void) gss_release_buffer(minor_status, &token);\n    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t/* If the mech deleted its context, delete the union context. */\n\tfree(ctx->mech_type->elements);\n\tfree(ctx->mech_type);\n\tfree(ctx);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n    return status;\n}","idx":232,"name":"gss_export_sec_context","project":"230941994705458","target":"False"}
{"commit_id":"62446792706633","func":"gss_init_sec_context (minor_status,\n                      claimant_cred_handle,\n                      context_handle,\n                      target_name,\n                      req_mech_type,\n                      req_flags,\n                      time_req,\n                      input_chan_bindings,\n                      input_token,\n                      actual_mech_type,\n                      output_token,\n                      ret_flags,\n                      time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_cred_id_t\t\tclaimant_cred_handle;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_name_t\t\ttarget_name;\ngss_OID\t\t\treq_mech_type;\nOM_uint32\t\treq_flags;\nOM_uint32\t\ttime_req;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_buffer_t\t\tinput_token;\ngss_OID *\t\tactual_mech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus, temp_minor_status;\n    gss_union_name_t\tunion_name;\n    gss_union_cred_t\tunion_cred;\n    gss_name_t\t\tinternal_name;\n    gss_union_ctx_id_t\tunion_ctx_id;\n    gss_OID\t\tselected_mech;\n    gss_mechanism\tmech;\n    gss_cred_id_t\tinput_cred_handle;\n\n    status = val_init_sec_ctx_args(minor_status,\n\t\t\t\t   claimant_cred_handle,\n\t\t\t\t   context_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   req_mech_type,\n\t\t\t\t   req_flags,\n\t\t\t\t   time_req,\n\t\t\t\t   input_chan_bindings,\n\t\t\t\t   input_token,\n\t\t\t\t   actual_mech_type,\n\t\t\t\t   output_token,\n\t\t\t\t   ret_flags,\n\t\t\t\t   time_rec);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    status = gssint_select_mech_type(minor_status, req_mech_type,\n\t\t\t\t     &selected_mech);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    union_name = (gss_union_name_t)target_name;\n\n    /*\n     * obtain the gss mechanism information for the requested\n     * mechanism.  If mech_type is NULL, set it to the resultant\n     * mechanism\n     */\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech == NULL)\n\treturn (GSS_S_BAD_MECH);\n\n    if (mech->gss_init_sec_context == NULL)\n\treturn (GSS_S_UNAVAILABLE);\n\n    /*\n     * If target_name is mechanism_specific, then it must match the\n     * mech_type that we're about to use.  Otherwise, do an import on\n     * the external_name form of the target name.\n     */\n    if (union_name->mech_type &&\n\tg_OID_equal(union_name->mech_type, selected_mech)) {\n\tinternal_name = union_name->mech_name;\n    } else {\n\tif ((status = gssint_import_internal_name(minor_status, selected_mech,\n\t\t\t\t\t\t union_name,\n\t\t\t\t\t\t &internal_name)) != GSS_S_COMPLETE)\n\t    return (status);\n    }\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (union_ctx_id == NULL)\n\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t    status = GSS_S_NO_CONTEXT;\n\t    goto end;\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n     * now call the approprate underlying mechanism routine\n     */\n\n    status = mech->gss_init_sec_context(\n\tminor_status,\n\tinput_cred_handle,\n\t&union_ctx_id->internal_ctx_id,\n\tinternal_name,\n\tgssint_get_public_oid(selected_mech),\n\treq_flags,\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * RFC 2744 5.19 requires that we not create a context on a failed\n\t * first call to init, and recommends that on a failed subsequent call\n\t * we make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n\tmap_error(minor_status, mech);\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\nend:\n    if (union_name->mech_name == NULL ||\n\tunion_name->mech_name != internal_name) {\n\t(void) gssint_release_internal_name(&temp_minor_status,\n\t\t\t\t\t    selected_mech, &internal_name);\n    }\n\n    return(status);\n}","idx":234,"name":"gss_init_sec_context","project":"138245821810109","target":"False"}
{"commit_id":"102367907219405","func":"gss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}","idx":235,"name":"gss_inquire_context","project":"142724009446212","target":"False"}
{"commit_id":"49032829369310","func":"gss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}","idx":236,"name":"gss_pseudo_random","project":"108005382574976","target":"False"}
{"commit_id":"134669582948125","func":"gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}","idx":237,"name":"gss_process_context_token","project":"264085541191173","target":"False"}
{"commit_id":"182769662411610","func":"gss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}","idx":238,"name":"gss_wrap","project":"79103794525585","target":"False"}
{"commit_id":"193520981161640","func":"gss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}","idx":239,"name":"gss_wrap_size_limit","project":"79103794525585","target":"False"}
{"commit_id":"223699775111077","func":"gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}","idx":240,"name":"gss_get_mic","project":"28689221413124","target":"False"}
{"commit_id":"189037627016029","func":"gss_unwrap (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\ngss_qop_t *\t\tqop_state;\n\n{\n/* EXPORT DELETE START */\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (output_message_buffer != GSS_C_NO_BUFFER) {\n\toutput_message_buffer->length = 0;\n\toutput_message_buffer->value = NULL;\n    }\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER ||\n\tGSS_EMPTY_BUFFER(input_message_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap) {\n\t    status = mech->gss_unwrap(minor_status,\n\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t      input_message_buffer,\n\t\t\t\t      output_message_buffer,\n\t\t\t\t      conf_state,\n\t\t\t\t      qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {\n\t    status = gssint_unwrap_aead(mech,\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx,\n\t\t\t\t\tinput_message_buffer,\n\t\t\t\t\tGSS_C_NO_BUFFER,\n\t\t\t\t\toutput_message_buffer,\n\t\t\t\t\tconf_state,\n\t\t\t\t\t(gss_qop_t *)qop_state);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n/* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}","idx":241,"name":"gss_unwrap","project":"218153705302454","target":"False"}
{"commit_id":"48369677064355","func":"gss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}","idx":242,"name":"gss_unwrap_aead","project":"6818884646571","target":"False"}
{"commit_id":"108450654945997","func":"gss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}","idx":243,"name":"gss_unwrap_iov","project":"173941388812339","target":"False"}
{"commit_id":"259813163848141","func":"gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}","idx":244,"name":"gss_verify_mic_iov","project":"173941388812339","target":"False"}
{"commit_id":"31345653898985","func":"gss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}","idx":245,"name":"gss_verify_mic","project":"145455272193821","target":"False"}
{"commit_id":"11153652781868","func":"gss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}","idx":246,"name":"gss_wrap_aead","project":"164939323797166","target":"False"}
{"commit_id":"200653798341903","func":"gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}","idx":247,"name":"gss_get_mic_iov_length","project":"88918831847289","target":"False"}
{"commit_id":"235827276458721","func":"gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}","idx":248,"name":"gss_wrap_iov","project":"88918831847289","target":"False"}
{"commit_id":"271746877576086","func":"gss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}","idx":249,"name":"gss_wrap_iov_length","project":"88918831847289","target":"False"}
{"commit_id":"144305917450009","func":"gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}","idx":250,"name":"gss_get_mic_iov","project":"88918831847289","target":"False"}
{"commit_id":"85026960110941","func":"get_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;\n    size_t i, j;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &pkinit_sans, &upn_sans, NULL);\n    if (ret)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}","idx":253,"name":"get_matching_data","project":"223501216886499","target":"False"}
{"commit_id":"127458955953368","func":"rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\n\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}","idx":254,"name":"rfc2253_name","project":"223501216886499","target":"False"}
{"commit_id":"9101021565866","func":"kadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_timestamp              now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;\n             tl_data_tail = tl_data_tail->tl_data_next) {\n            if (tl_data_tail->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n        }\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = calloc(1, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);\n    if (ret)\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}","idx":255,"name":"kadm5_create_principal_3","project":"94481434134406","target":"False"}
{"commit_id":"76161048021505","func":"validate_xargs(krb5_context context,\n               krb5_ldap_server_handle *ldap_server_handle,\n               const xargs_t *xargs, const char *standalone_dn,\n               char *const *subtrees, unsigned int ntrees)\n{\n    krb5_error_code st;\n\n    if (xargs->dn != NULL) {\n        /* The supplied dn must be within a realm container. */\n        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);\n        if (st)\n            return st;\n        /* The supplied dn must exist without Kerberos attributes. */\n        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->linkdn != NULL) {\n        /* The supplied linkdn must be within a realm container. */\n        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);\n        if (st)\n            return st;\n        /* The supplied linkdn must exist. */\n        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,\n                             FALSE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->containerdn != NULL && standalone_dn != NULL) {\n        /* standalone_dn (likely composed using containerdn) must be within a\n         * container. */\n        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);\n        if (st)\n            return st;\n    }\n\n    return 0;\n}","idx":257,"name":"validate_xargs","project":"150087264956859","target":"False"}
{"commit_id":"157312054709029","func":"check_dn_exists(krb5_context context,\n                krb5_ldap_server_handle *ldap_server_handle,\n                const char *dn, krb5_boolean nonkrb_only)\n{\n    krb5_error_code st = 0, tempst;\n    krb5_ldap_context *ldap_context = context->dal_handle->db_context;\n    LDAP *ld = ldap_server_handle->ldap_handle;\n    LDAPMessage *result = NULL, *ent;\n    char *attrs[] = { \"krbticketpolicyreference\", \"krbprincipalname\", NULL };\n    char **values;\n\n    LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attrs, IGNORE_STATUS);\n    if (st != LDAP_SUCCESS)\n        return set_ldap_error(context, st, OP_SEARCH);\n\n    ent = ldap_first_entry(ld, result);\n    CHECK_NULL(ent);\n\n    values = ldap_get_values(ld, ent, \"krbticketpolicyreference\");\n    if (values != NULL)\n        ldap_value_free(values);\n\n    values = ldap_get_values(ld, ent, \"krbprincipalname\");\n    if (values != NULL) {\n        ldap_value_free(values);\n        if (nonkrb_only) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"ldap object is already kerberized\"));\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    return st;\n}","idx":258,"name":"check_dn_exists","project":"150087264956859","target":"False"}
{"commit_id":"31287196926667","func":"krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        st = validate_xargs(context, ldap_server_handle, &xargs,\n                            standalone_principal_dn, subtreelist, ntrees);\n        if (st)\n            goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}","idx":259,"name":"krb5_ldap_put_principal","project":"150087264956859","target":"False"}
{"commit_id":"191803715585402","func":"check_dn_in_container(krb5_context context, const char *dn,\n                      char *const *subtrees, unsigned int ntrees)\n{\n    unsigned int i;\n    size_t dnlen = strlen(dn), stlen;\n\n    for (i = 0; i < ntrees; i++) {\n        if (subtrees[i] == NULL || *subtrees[i] == '\\0')\n            return 0;\n        stlen = strlen(subtrees[i]);\n        if (dnlen >= stlen &&\n            strcasecmp(dn + dnlen - stlen, subtrees[i]) == 0 &&\n            (dnlen == stlen || dn[dnlen - stlen - 1] == ','))\n            return 0;\n    }\n\n    k5_setmsg(context, EINVAL, _(\"DN is out of the realm subtree\"));\n    return EINVAL;\n}","idx":260,"name":"check_dn_in_container","project":"150087264956859","target":"False"}
{"commit_id":"161169455497243","func":"kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n\n        memset(&no_server, 0, sizeof(no_server));\n\n        /* Ignore password expiration and needchange attributes (as Windows\n         * does), since S4U2Self is not password authentication. */\n        princ->pw_expiration = 0;\n        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\n\n        code = validate_as_request(kdc_active_realm, request, *princ,\n                                   no_server, kdc_time, status, &e_data);\n        if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}","idx":261,"name":"kdc_process_s4u2self_req","project":"34085069692679","target":"False"}
{"commit_id":"127927334619332","func":"s4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n    code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                             opts, krb5_get_as_key_noop, &userid, &use_master,\n                             NULL);\n    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n        *canon_user = userid.user;\n        userid.user = NULL;\n        code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}","idx":263,"name":"s4u_identify_user","project":"12422060022640","target":"False"}
{"commit_id":"281039005279390","func":"decode_atype(const taginfo *t, const uint8_t *asn1, size_t len,\n             const struct atype_info *a, void *val)\n{\n    krb5_error_code ret;\n\n    switch (a->type) {\n    case atype_fn: {\n        const struct fn_info *fn = a->tinfo;\n        assert(fn->dec != NULL);\n        return fn->dec(t, asn1, len, val);\n    }\n    case atype_sequence:\n        return decode_sequence(asn1, len, a->tinfo, val);\n    case atype_ptr: {\n        const struct ptr_info *ptrinfo = a->tinfo;\n        void *ptr = LOADPTR(val, ptrinfo);\n        assert(ptrinfo->basetype != NULL);\n        if (ptr != NULL) {\n            /* Container was already allocated by a previous sequence field. */\n            return decode_atype(t, asn1, len, ptrinfo->basetype, ptr);\n        } else {\n            ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr);\n            if (ret)\n                return ret;\n            STOREPTR(ptr, ptrinfo, val);\n            break;\n        }\n    }\n    case atype_offset: {\n        const struct offset_info *off = a->tinfo;\n        assert(off->basetype != NULL);\n        return decode_atype(t, asn1, len, off->basetype,\n                            (char *)val + off->dataoff);\n    }\n    case atype_optional: {\n        const struct optional_info *opt = a->tinfo;\n        return decode_atype(t, asn1, len, opt->basetype, val);\n    }\n    case atype_counted: {\n        const struct counted_info *counted = a->tinfo;\n        void *dataptr = (char *)val + counted->dataoff;\n        size_t count;\n        assert(counted->basetype != NULL);\n        ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count);\n        if (ret)\n            return ret;\n        return store_count(count, counted, val);\n    }\n    case atype_tagged_thing: {\n        const struct tagged_info *tag = a->tinfo;\n        taginfo inner_tag;\n        const taginfo *tp = t;\n        const uint8_t *rem;\n        size_t rlen;\n        if (!tag->implicit) {\n            ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);\n            if (ret)\n                return ret;\n            /* Note: we don't check rlen (it should be 0). */\n            tp = &inner_tag;\n            if (!check_atype_tag(tag->basetype, tp))\n                return ASN1_BAD_ID;\n        }\n        return decode_atype(tp, asn1, len, tag->basetype, val);\n    }\n    case atype_bool: {\n        intmax_t intval;\n        ret = k5_asn1_decode_bool(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_int: {\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_int(intval, a->size, val);\n    }\n    case atype_uint: {\n        uintmax_t intval;\n        ret = k5_asn1_decode_uint(asn1, len, &intval);\n        if (ret)\n            return ret;\n        return store_uint(intval, a->size, val);\n    }\n    case atype_int_immediate: {\n        const struct immediate_info *imm = a->tinfo;\n        intmax_t intval;\n        ret = k5_asn1_decode_int(asn1, len, &intval);\n        if (ret)\n            return ret;\n        if (intval != imm->val && imm->err != 0)\n            return imm->err;\n        break;\n    }\n    default:\n        /* Null-terminated sequence types are handled in decode_atype_to_ptr,\n         * since they create variable-sized objects. */\n        assert(a->type != atype_nullterm_sequence_of);\n        assert(a->type != atype_nonempty_nullterm_sequence_of);\n        assert(a->type > atype_min);\n        assert(a->type < atype_max);\n        abort();\n    }\n    return 0;\n}","idx":270,"name":"decode_atype","project":"103659409853354","target":"False"}
{"commit_id":"10327936469656","func":"split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}","idx":271,"name":"split_der","project":"103659409853354","target":"False"}
{"commit_id":"211927501015414","func":"decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        /*\n         * Find the applicable sequence field.  This logic is a little\n         * oversimplified; we could match an element to an optional extensible\n         * choice or optional stored-DER type when we ought to match a\n         * subsequent non-optional field.  But it's unwise and (hopefully) very\n         * rare for ASN.1 modules to require such precision.\n         */\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        /* We currently model all sequences as extensible.  We should consider\n         * changing this before making the encoder visible to plugins. */\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    /* Initialize any fields in the C object which were not accounted for in\n     * the sequence.  Error out if any of them aren't optional. */\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    /* Free what we've decoded so far.  Free pointers in a second pass in\n     * case multiple fields refer to the same pointer. */\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}","idx":272,"name":"decode_sequence","project":"103659409853354","target":"False"}
{"commit_id":"166449573603983","func":"decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}","idx":273,"name":"decode_sequence_of","project":"103659409853354","target":"False"}
{"commit_id":"224849564580345","func":"k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    /* rlen should be 0, but we don't check it (and due to padding in\n     * non-length-preserving enctypes, it will sometimes be nonzero). */\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}","idx":274,"name":"k5_asn1_full_decode","project":"103659409853354","target":"False"}
{"commit_id":"171861520516510","func":"get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,\n        const uint8_t **contents_out, size_t *clen_out,\n        const uint8_t **remainder_out, size_t *rlen_out, int recursion)\n{\n    krb5_error_code ret;\n    uint8_t o;\n    const uint8_t *c, *p, *tag_start = asn1;\n    size_t clen, llen, i;\n    taginfo t;\n\n    *contents_out = *remainder_out = NULL;\n    *clen_out = *rlen_out = 0;\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n    tag_out->asn1class = o & 0xC0;\n    tag_out->construction = o & 0x20;\n    if ((o & 0x1F) != 0x1F) {\n        tag_out->tagnum = o & 0x1F;\n    } else {\n        tag_out->tagnum = 0;\n        do {\n            if (len == 0)\n                return ASN1_OVERRUN;\n            o = *asn1++;\n            len--;\n            tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);\n        } while (o & 0x80);\n    }\n\n    if (len == 0)\n        return ASN1_OVERRUN;\n    o = *asn1++;\n    len--;\n\n    if (o == 0x80) {\n        /* Indefinite form (should not be present in DER, but we accept it). */\n        if (tag_out->construction != CONSTRUCTED)\n            return ASN1_MISMATCH_INDEF;\n        if (recursion >= 32)\n            return ASN1_OVERFLOW;\n        p = asn1;\n        while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {\n            ret = get_tag(p, len, &t, &c, &clen, &p, &len, recursion + 1);\n            if (ret)\n                return ret;\n        }\n        tag_out->tag_end_len = 2;\n        *contents_out = asn1;\n        *clen_out = p - asn1;\n        *remainder_out = p + 2;\n        *rlen_out = len - 2;\n    } else if ((o & 0x80) == 0) {\n        /* Short form (first octet gives content length). */\n        if (o > len)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1;\n        *clen_out = o;\n        *remainder_out = asn1 + *clen_out;\n        *rlen_out = len - (*remainder_out - asn1);\n    } else {\n        /* Long form (first octet gives number of base-256 length octets). */\n        llen = o & 0x7F;\n        if (llen > len)\n            return ASN1_OVERRUN;\n        if (llen > sizeof(*clen_out))\n            return ASN1_OVERFLOW;\n        for (i = 0, clen = 0; i < llen; i++)\n            clen = (clen << 8) | asn1[i];\n        if (clen > len - llen)\n            return ASN1_OVERRUN;\n        tag_out->tag_end_len = 0;\n        *contents_out = asn1 + llen;\n        *clen_out = clen;\n        *remainder_out = *contents_out + clen;\n        *rlen_out = len - (*remainder_out - asn1);\n    }\n    tag_out->tag_len = *contents_out - tag_start;\n    return 0;\n}","idx":275,"name":"get_tag","project":"103659409853354","target":"False"}
{"commit_id":"120722125071310","func":"ec_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n          krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *data,\n          krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,\n          krb5_kdcpreauth_moddata moddata,\n          krb5_kdcpreauth_verify_respond_fn respond, void *arg)\n{\n    krb5_error_code retval = 0;\n    krb5_enc_data *enc = NULL;\n    krb5_data scratch, plain;\n    krb5_keyblock *armor_key = cb->fast_armor(context, rock);\n    krb5_pa_enc_ts *ts = NULL;\n    krb5_keyblock *client_keys = NULL;\n    krb5_keyblock *challenge_key = NULL;\n    krb5_keyblock *kdc_challenge_key;\n    krb5_kdcpreauth_modreq modreq = NULL;\n    int i = 0;\n    char *ai = NULL, *realmstr = NULL;\n    krb5_data realm = request->server->realm;\n\n    plain.data = NULL;\n\n    if (armor_key == NULL) {\n        retval = ENOENT;\n        k5_setmsg(context, ENOENT,\n                  _(\"Encrypted Challenge used outside of FAST tunnel\"));\n    }\n    scratch.data = (char *) data->contents;\n    scratch.length = data->length;\n    if (retval == 0)\n        retval = decode_krb5_enc_data(&scratch, &enc);\n    if (retval == 0) {\n        plain.data =  malloc(enc->ciphertext.length);\n        plain.length = enc->ciphertext.length;\n        if (plain.data == NULL)\n            retval = ENOMEM;\n    }\n\n    /* Check for a configured FAST ec auth indicator. */\n    if (retval == 0)\n        realmstr = k5memdup0(realm.data, realm.length, &retval);\n    if (realmstr != NULL)\n        retval = profile_get_string(context->profile, KRB5_CONF_REALMS,\n                                    realmstr,\n                                    KRB5_CONF_ENCRYPTED_CHALLENGE_INDICATOR,\n                                    NULL, &ai);\n\n    if (retval == 0)\n        retval = cb->client_keys(context, rock, &client_keys);\n    if (retval == 0) {\n        for (i = 0; client_keys[i].enctype&& (retval == 0); i++ ) {\n            retval = krb5_c_fx_cf2_simple(context,\n                                          armor_key, \"clientchallengearmor\",\n                                          &client_keys[i], \"challengelongterm\",\n                                          &challenge_key);\n            if (retval == 0)\n                retval  = krb5_c_decrypt(context, challenge_key,\n                                         KRB5_KEYUSAGE_ENC_CHALLENGE_CLIENT,\n                                         NULL, enc, &plain);\n            if (challenge_key)\n                krb5_free_keyblock(context, challenge_key);\n            challenge_key = NULL;\n            if (retval == 0)\n                break;\n            /*We failed to decrypt. Try next key*/\n            retval = 0;\n        }\n        if (client_keys[i].enctype == 0) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            k5_setmsg(context, retval,\n                      _(\"Incorrect password in encrypted challenge\"));\n        }\n    }\n    if (retval == 0)\n        retval = decode_krb5_pa_enc_ts(&plain, &ts);\n    if (retval == 0)\n        retval = krb5_check_clockskew(context, ts->patimestamp);\n    if (retval == 0) {\n        enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n        /*\n         * If this fails, we won't generate a reply to the client.  That may\n         * cause the client to fail, but at this point the KDC has considered\n         * this a success, so the return value is ignored.\n         */\n        if (krb5_c_fx_cf2_simple(context, armor_key, \"kdcchallengearmor\",\n                                 &client_keys[i], \"challengelongterm\",\n                                 &kdc_challenge_key) == 0) {\n            modreq = (krb5_kdcpreauth_modreq)kdc_challenge_key;\n            if (ai != NULL)\n                cb->add_auth_indicator(context, rock, ai);\n        }\n    }\n    cb->free_keys(context, rock, client_keys);\n    if (plain.data)\n        free(plain.data);\n    if (enc)\n        krb5_free_enc_data(context, enc);\n    if (ts)\n        krb5_free_pa_enc_ts(context, ts);\n    free(realmstr);\n    free(ai);\n\n    (*respond)(arg, retval, modreq, NULL, NULL);\n}","idx":277,"name":"ec_verify","project":"279716010046665","target":"False"}
{"commit_id":"171488335150647","func":"process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n    if (sprinc == NULL) {\n        status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}","idx":278,"name":"process_tgs_req","project":"263385689284013","target":"False"}
{"commit_id":"265637405931423","func":"int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\n\t\t\tlen = skb->len - offset;\n\t\t\t/* Stop reading if we hit a patch of urgent data */\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If recv_actor drops the lock (e.g. TCP splice\n\t\t\t * receive) the skb pointer might be invalid when\n\t\t\t * getting here: tcp_collapse might have deleted it\n\t\t\t * while aggregating skbs from the socket queue.\n\t\t\t */\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n\t\tsk_eat_skb(sk, skb, 0);\n\t\tif (!desc->count)\n\t\t\tbreak;\n\t\ttp->copied_seq = seq;\n\t}\n\ttp->copied_seq = seq;\n\n\ttcp_rcv_space_adjust(sk);\n\n\t/* Clean up data we have read: This will do ACK frames. */\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}","idx":279,"name":"tcp_read_sock","project":"219050031958871","target":"False"}
{"commit_id":"7368913936281","func":"bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tswitch (crev) {\n\tcase 1:\n\t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING)\n\t\t\treturn false;\n\n\t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t/* PAL timings appear to have wrong values for totals */\n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\n\t\t\treturn false;\n\n\t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}","idx":281,"name":"radeon_atom_get_tv_timings","project":"49320838141689","target":"False"}
{"commit_id":"79453173354859","func":"int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\n\tif (!(dev->flags & IFF_UP) ||\n\t    (skb->len > (dev->mtu + dev->hard_header_len))) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}","idx":284,"name":"dev_forward_skb","project":"138954365741142","target":"False"}
{"commit_id":"248370609257618","func":"static inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); /* not really needed */\n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}","idx":286,"name":"init_idle_pids","project":"97473752816411","target":"False"}
{"commit_id":"23348242468398","func":"struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}","idx":287,"name":"fork_idle","project":"97473752816411","target":"False"}
{"commit_id":"270327277491569","func":"static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\n\treturn r;\n}","idx":288,"name":"__netdev_printk","project":"92038226215371","target":"False"}
{"commit_id":"107830981786381","func":"int netdev_printk(const char *level, const struct net_device *dev,\n\t\t  const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\n\tva_start(args, format);\n\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tr = __netdev_printk(level, dev, &vaf);\n\tva_end(args);\n\n\treturn r;\n}","idx":289,"name":"netdev_printk","project":"92038226215371","target":"False"}
{"commit_id":"236168400932671","func":"cifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM, xid;\n\tstruct cifsSesInfo *ses;\n\n\txid = GetXid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tFreeXid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcFYI(1, \"Session needs reconnect\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tFreeXid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tFreeXid(xid);\n\t\treturn ses;\n\t}\n\n\tcFYI(1, \"Existing smb sess not found\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->addr.sockAddr6.sin6_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\",\n\t\t\t&server->addr.sockAddr6.sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\",\n\t\t\t&server->addr.sockAddr.sin_addr.s_addr);\n\n\tif (volume_info->username)\n\t\tstrncpy(ses->userName, volume_info->username,\n\t\t\tMAX_USERNAME_SIZE);\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tint len = strlen(volume_info->domainname);\n\t\tses->domainName = kmalloc(len + 1, GFP_KERNEL);\n\t\tif (ses->domainName)\n\t\t\tstrcpy(ses->domainName, volume_info->domainname);\n\t}\n\tses->linux_uid = volume_info->linux_uid;\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tFreeXid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}","idx":292,"name":"cifs_get_smb_ses","project":"87230826741587","target":"False"}
{"commit_id":"143257153418066","func":"cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->linux_uid != ses->linux_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* anything else takes username/password */\n\t\t\tif (strncmp(ses->userName, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    strncmp(ses->password, vol->password,\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}","idx":293,"name":"cifs_find_smb_ses","project":"87230826741587","target":"False"}
{"commit_id":"12974655163968","func":"static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t   struct frag_hdr *fhdr, int nhoff)\n{\n\tstruct sk_buff *prev, *next;\n\tstruct net_device *dev;\n\tint offset, end;\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\tif (fq->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto err;\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((u8 *)&fhdr->frag_off -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t/* Is this the final fragment? */\n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t/* If we already have some bits beyond end\n\t\t * or have different end, the segment is corrupted.\n\t\t */\n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.last_in & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto err;\n\t\tfq->q.last_in |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t/* Check if the fragment is rounded to 8 bytes.\n\t\t * Required by the RFC.\n\t\t */\n\t\tif (end & 0x7) {\n\t\t\t/* RFC2460 says always send parameter problem in\n\t\t\t * this case. -DaveM\n\t\t\t */\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t\t  offsetof(struct ipv6hdr, payload_len));\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t/* Some bits beyond end -> corruption. */\n\t\t\tif (fq->q.last_in & INET_FRAG_LAST_IN)\n\t\t\t\tgoto err;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t/* Point into the IP datagram 'data' part. */\n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto err;\n\n\tif (pskb_trim_rcsum(skb, end - offset))\n\t\tgoto err;\n\n\t/* Find out which fragments are in front and at the back of us\n\t * in the chain of fragments so far.  We must know where to put\n\t * this fragment, right?\n\t */\n\tprev = fq->q.fragments_tail;\n\tif (!prev || FRAG6_CB(prev)->offset < offset) {\n\t\tnext = NULL;\n\t\tgoto found;\n\t}\n\tprev = NULL;\n\tfor(next = fq->q.fragments; next != NULL; next = next->next) {\n\t\tif (FRAG6_CB(next)->offset >= offset)\n\t\t\tbreak;\t/* bingo! */\n\t\tprev = next;\n\t}\n\nfound:\n\t/* RFC5722, Section 4:\n\t *                                  When reassembling an IPv6 datagram, if\n\t *   one or more its constituent fragments is determined to be an\n\t *   overlapping fragment, the entire datagram (and any constituent\n\t *   fragments, including those not yet received) MUST be silently\n\t *   discarded.\n\t */\n\n\t/* Check for overlap with preceding fragment. */\n\tif (prev &&\n\t    (FRAG6_CB(prev)->offset + prev->len) - offset > 0)\n\t\tgoto discard_fq;\n\n\t/* Look for overlap with succeeding segment. */\n\tif (next && FRAG6_CB(next)->offset < end)\n\t\tgoto discard_fq;\n\n\tFRAG6_CB(skb)->offset = offset;\n\n\t/* Insert this fragment in the chain of fragments. */\n\tskb->next = next;\n\tif (!next)\n\t\tfq->q.fragments_tail = skb;\n\tif (prev)\n\t\tprev->next = skb;\n\telse\n\t\tfq->q.fragments = skb;\n\n\tdev = skb->dev;\n\tif (dev) {\n\t\tfq->iif = dev->ifindex;\n\t\tskb->dev = NULL;\n\t}\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.meat += skb->len;\n\tatomic_add(skb->truesize, &fq->q.net->mem);\n\n\t/* The first fragment.\n\t * nhoffset is obtained from the first fragment, of course.\n\t */\n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.last_in |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len)\n\t\treturn ip6_frag_reasm(fq, prev, dev);\n\n\twrite_lock(&ip6_frags.lock);\n\tlist_move_tail(&fq->q.lru_list, &fq->q.net->lru_list);\n\twrite_unlock(&ip6_frags.lock);\n\treturn -1;\n\ndiscard_fq:\n\tfq_kill(fq);\nerr:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n}","idx":296,"name":"ip6_frag_queue","project":"216573880297487","target":"False"}
{"commit_id":"50236704134784","func":"static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}","idx":302,"name":"futex_wait_requeue_pi","project":"118765740862898","target":"False"}
{"commit_id":"226667318339614","func":"static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\n\tret = -ERESTART_RESTARTBLOCK;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}","idx":303,"name":"futex_wait","project":"118765740862898","target":"False"}
{"commit_id":"193115335775786","func":"int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}","idx":304,"name":"mlx4_register_vlan","project":"17196259762306","target":"False"}
{"commit_id":"219388806863633","func":"int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}","idx":305,"name":"mlx4_register_mac","project":"17196259762306","target":"False"}
{"commit_id":"106427296390267","func":"static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}","idx":306,"name":"fuse_verify_ioctl_iov","project":"146145437857864","target":"False"}
{"commit_id":"225196397912546","func":"long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}","idx":307,"name":"fuse_do_ioctl","project":"146145437857864","target":"False"}
{"commit_id":"98669882519036","func":"SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\n\t/* Check the IN_* constants for consistency.  */\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\n\t/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\n\tatomic_inc(&user->inotify_devs);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\nout_free_uid:\n\tfree_uid(user);\n\treturn ret;\n}","idx":308,"name":"SYSCALL_DEFINE1","project":"206643080956798","target":"False"}
{"commit_id":"70760750041358","func":"static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}","idx":309,"name":"dup_task_struct","project":"172426466034780","target":"False"}
{"commit_id":"125552922894655","func":"asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\n\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\traw_spin_lock_irq(&rq->lock);\n\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If a worker is going to sleep, notify and\n\t\t\t * ask workqueue whether it wants to wake up a\n\t\t\t * task to maintain concurrency.  If so, wake\n\t\t\t * up the task.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tpre_schedule(rq, prev);\n\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tclear_tsk_need_resched(prev);\n\trq->skip_clock_update = 0;\n\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tWARN_ON_ONCE(test_tsk_need_resched(next));\n\n\t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n\t\t/*\n\t\t * The context switch have flipped the stack from under us\n\t\t * and restored the local variables which were saved when\n\t\t * this task called schedule() in the past. prev == current\n\t\t * is still correct, but it can be moved to another cpu/rq.\n\t\t */\n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\n\tpost_schedule(rq);\n\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}","idx":314,"name":"schedule","project":"171771387903602","target":"False"}
{"commit_id":"51056841900251","func":"static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}","idx":315,"name":"check_preempt_curr","project":"171771387903602","target":"False"}
{"commit_id":"247005931601077","func":"inline void update_rq_clock(struct rq *rq)\n{\n\tint cpu = cpu_of(rq);\n\tu64 irq_time;\n\n\tif (rq->skip_clock_update)\n\t\treturn;\n\n\trq->clock = sched_clock_cpu(cpu);\n\tirq_time = irq_time_cpu(cpu);\n\tif (rq->clock - irq_time > rq->clock_task)\n\t\trq->clock_task = rq->clock - irq_time;\n\n\tsched_irq_time_avg_update(rq, irq_time);\n}","idx":316,"name":"update_rq_clock","project":"171771387903602","target":"False"}
{"commit_id":"2360387688746","func":"static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\t/*\n\t\t * orinoco does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/* wl_lkm implies value 2 == PSK for Hermes I\n\t\t * which ties in with WEXT\n\t\t * no other hints tho :(\n\t\t */\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t/* When countermeasures are enabled, shut down the\n\t\t * card; when disabled, re-enable the card. This must\n\t\t * take effect immediately.\n\t\t *\n\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t */\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t/* else silently accept disable of WPA */\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}","idx":318,"name":"orinoco_ioctl_set_auth","project":"28579670178236","target":"False"}
{"commit_id":"126138698880418","func":"static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}","idx":319,"name":"ima_lsm_rule_init","project":"174302765842687","target":"False"}
{"commit_id":"157570700677489","func":"static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}","idx":321,"name":"handle_emulation_failure","project":"19148134016236","target":"False"}
{"commit_id":"234965122836727","func":"static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\n\tif (!port) {\n\t\tif (hlist_unhashed(&mp->mglist))\n\t\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\n\trcu_assign_pointer(*pp, p);\n\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\n\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}","idx":323,"name":"br_multicast_add_group","project":"270605270739934","target":"False"}
{"commit_id":"224063967255303","func":"static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}","idx":324,"name":"bnep_sock_ioctl","project":"13143650092801","target":"False"}
{"commit_id":"244057131776185","func":"static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}","idx":325,"name":"sco_sock_getsockopt_old","project":"12519783640276","target":"False"}
{"commit_id":"275378353030933","func":"static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}","idx":326,"name":"do_replace","project":"100240702759054","target":"False"}
{"commit_id":"3226633202457","func":"int rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\tunsigned int hdr_off, unsigned int sg, unsigned int off)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\tstruct ib_device *dev = ic->i_cm_id->device;\n\tstruct rds_ib_send_work *send = NULL;\n\tstruct rds_ib_send_work *first;\n\tstruct rds_ib_send_work *prev;\n\tstruct ib_send_wr *failed_wr;\n\tstruct scatterlist *scat;\n\tu32 pos;\n\tu32 i;\n\tu32 work_alloc;\n\tu32 credit_alloc = 0;\n\tu32 posted;\n\tu32 adv_credits = 0;\n\tint send_flags = 0;\n\tint bytes_sent = 0;\n\tint ret;\n\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t/* Do not send cong updates to IB loopback */\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tscat = &rm->data.op_sg[sg];\n\t\tret = sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t\tret = min_t(int, ret, scat->length - conn->c_xmit_data_off);\n\t\treturn ret;\n\t}\n\n\t/* FIXME we may overallocate here */\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {\n\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\trds_ib_stats_inc(s_ib_tx_ring_full);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (ic->i_flowctl) {\n\t\tcredit_alloc = rds_ib_send_grab_credits(ic, work_alloc, &posted, 0, RDS_MAX_ADV_CREDIT);\n\t\tadv_credits += posted;\n\t\tif (credit_alloc < work_alloc) {\n\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - credit_alloc);\n\t\t\twork_alloc = credit_alloc;\n\t\t\tflow_controlled = 1;\n\t\t}\n\t\tif (work_alloc == 0) {\n\t\t\tset_bit(RDS_LL_SEND_FULL, &conn->c_flags);\n\t\t\trds_ib_stats_inc(s_ib_tx_throttle);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* map the message the first time we see it */\n\tif (!ic->i_data_op) {\n\t\tif (rm->data.op_nents) {\n\t\t\trm->data.op_count = ib_dma_map_sg(dev,\n\t\t\t\t\t\t\t  rm->data.op_sg,\n\t\t\t\t\t\t\t  rm->data.op_nents,\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\trdsdebug(\"ic %p mapping rm %p: %d\\n\", ic, rm, rm->data.op_count);\n\t\t\tif (rm->data.op_count == 0) {\n\t\t\t\trds_ib_stats_inc(s_ib_tx_sg_mapping_failure);\n\t\t\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\t\t\tret = -ENOMEM; /* XXX ? */\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\trm->data.op_count = 0;\n\t\t}\n\n\t\trds_message_addref(rm);\n\t\tic->i_data_op = &rm->data;\n\n\t\t/* Finalize the header */\n\t\tif (test_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_ACK_REQUIRED;\n\t\tif (test_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags))\n\t\t\trm->m_inc.i_hdr.h_flags |= RDS_FLAG_RETRANSMITTED;\n\n\t\t/* If it has a RDMA op, tell the peer we did it. This is\n\t\t * used by the peer to release use-once RDMA MRs. */\n\t\tif (rm->rdma.op_active) {\n\t\t\tstruct rds_ext_header_rdma ext_hdr;\n\n\t\t\text_hdr.h_rdma_rkey = cpu_to_be32(rm->rdma.op_rkey);\n\t\t\trds_message_add_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\tRDS_EXTHDR_RDMA, &ext_hdr, sizeof(ext_hdr));\n\t\t}\n\t\tif (rm->m_rdma_cookie) {\n\t\t\trds_message_add_rdma_dest_extension(&rm->m_inc.i_hdr,\n\t\t\t\t\trds_rdma_cookie_key(rm->m_rdma_cookie),\n\t\t\t\t\trds_rdma_cookie_offset(rm->m_rdma_cookie));\n\t\t}\n\n\t\t/* Note - rds_ib_piggyb_ack clears the ACK_REQUIRED bit, so\n\t\t * we should not do this unless we have a chance of at least\n\t\t * sticking the header into the send ring. Which is why we\n\t\t * should call rds_ib_ring_alloc first. */\n\t\trm->m_inc.i_hdr.h_ack = cpu_to_be64(rds_ib_piggyb_ack(ic));\n\t\trds_message_make_checksum(&rm->m_inc.i_hdr);\n\n\t\t/*\n\t\t * Update adv_credits since we reset the ACK_REQUIRED bit.\n\t\t */\n\t\tif (ic->i_flowctl) {\n\t\t\trds_ib_send_grab_credits(ic, 0, &posted, 1, RDS_MAX_ADV_CREDIT - adv_credits);\n\t\t\tadv_credits += posted;\n\t\t\tBUG_ON(adv_credits > 255);\n\t\t}\n\t}\n\n\t/* Sometimes you want to put a fence between an RDMA\n\t * READ and the following SEND.\n\t * We could either do this all the time\n\t * or when requested by the user. Right now, we let\n\t * the application choose.\n\t */\n\tif (rm->rdma.op_active && rm->rdma.op_fence)\n\t\tsend_flags = IB_SEND_FENCE;\n\n\t/* Each frag gets a header. Msgs may be 0 bytes */\n\tsend = &ic->i_sends[pos];\n\tfirst = send;\n\tprev = NULL;\n\tscat = &ic->i_data_op->op_sg[sg];\n\ti = 0;\n\tdo {\n\t\tunsigned int len = 0;\n\n\t\t/* Set up the header */\n\t\tsend->s_wr.send_flags = send_flags;\n\t\tsend->s_wr.opcode = IB_WR_SEND;\n\t\tsend->s_wr.num_sge = 1;\n\t\tsend->s_wr.next = NULL;\n\t\tsend->s_queued = jiffies;\n\t\tsend->s_op = NULL;\n\n\t\tsend->s_sge[0].addr = ic->i_send_hdrs_dma\n\t\t\t+ (pos * sizeof(struct rds_header));\n\t\tsend->s_sge[0].length = sizeof(struct rds_header);\n\n\t\tmemcpy(&ic->i_send_hdrs[pos], &rm->m_inc.i_hdr, sizeof(struct rds_header));\n\n\t\t/* Set up the data, if present */\n\t\tif (i < work_alloc\n\t\t    && scat != &rm->data.op_sg[rm->data.op_count]) {\n\t\t\tlen = min(RDS_FRAG_SIZE, ib_sg_dma_len(dev, scat) - off);\n\t\t\tsend->s_wr.num_sge = 2;\n\n\t\t\tsend->s_sge[1].addr = ib_sg_dma_address(dev, scat) + off;\n\t\t\tsend->s_sge[1].length = len;\n\n\t\t\tbytes_sent += len;\n\t\t\toff += len;\n\t\t\tif (off == ib_sg_dma_len(dev, scat)) {\n\t\t\t\tscat++;\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t}\n\n\t\trds_ib_set_wr_signal_state(ic, send, 0);\n\n\t\t/*\n\t\t * Always signal the last one if we're stopping due to flow control.\n\t\t */\n\t\tif (ic->i_flowctl && flow_controlled && i == (work_alloc-1))\n\t\t\tsend->s_wr.send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED;\n\n\t\tif (send->s_wr.send_flags & IB_SEND_SIGNALED)\n\t\t\tnr_sig++;\n\n\t\trdsdebug(\"send %p wr %p num_sge %u next %p\\n\", send,\n\t\t\t &send->s_wr, send->s_wr.num_sge, send->s_wr.next);\n\n\t\tif (ic->i_flowctl && adv_credits) {\n\t\t\tstruct rds_header *hdr = &ic->i_send_hdrs[pos];\n\n\t\t\t/* add credit and redo the header checksum */\n\t\t\thdr->h_credit = adv_credits;\n\t\t\trds_message_make_checksum(hdr);\n\t\t\tadv_credits = 0;\n\t\t\trds_ib_stats_inc(s_ib_tx_credit_updates);\n\t\t}\n\n\t\tif (prev)\n\t\t\tprev->s_wr.next = &send->s_wr;\n\t\tprev = send;\n\n\t\tpos = (pos + 1) % ic->i_send_ring.w_nr;\n\t\tsend = &ic->i_sends[pos];\n\t\ti++;\n\n\t} while (i < work_alloc\n\t\t && scat != &rm->data.op_sg[rm->data.op_count]);\n\n\t/* Account the RDS header in the number of bytes we sent, but just once.\n\t * The caller has no concept of fragmentation. */\n\tif (hdr_off == 0)\n\t\tbytes_sent += sizeof(struct rds_header);\n\n\t/* if we finished the message then send completion owns it */\n\tif (scat == &rm->data.op_sg[rm->data.op_count]) {\n\t\tprev->s_op = ic->i_data_op;\n\t\tprev->s_wr.send_flags |= IB_SEND_SOLICITED;\n\t\tic->i_data_op = NULL;\n\t}\n\n\t/* Put back wrs & credits we didn't use */\n\tif (i < work_alloc) {\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc - i);\n\t\twork_alloc = i;\n\t}\n\tif (ic->i_flowctl && i < credit_alloc)\n\t\trds_ib_send_add_credits(conn, credit_alloc - i);\n\n\tif (nr_sig)\n\t\tatomic_add(nr_sig, &ic->i_signaled_sends);\n\n\t/* XXX need to worry about failed_wr and partial sends. */\n\tfailed_wr = &first->s_wr;\n\tret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);\n\trdsdebug(\"ic %p first %p (wr %p) ret %d wr %p\\n\", ic,\n\t\t first, &first->s_wr, ret, failed_wr);\n\tBUG_ON(failed_wr != &first->s_wr);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"RDS/IB: ib_post_send to %pI4 \"\n\t\t       \"returned %d\\n\", &conn->c_faddr, ret);\n\t\trds_ib_ring_unalloc(&ic->i_send_ring, work_alloc);\n\t\trds_ib_sub_signaled(ic, nr_sig);\n\t\tif (prev->s_op) {\n\t\t\tic->i_data_op = prev->s_op;\n\t\t\tprev->s_op = NULL;\n\t\t}\n\n\t\trds_ib_conn_error(ic->conn, \"ib_post_send failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = bytes_sent;\nout:\n\tBUG_ON(adv_credits);\n\treturn ret;\n}","idx":328,"name":"rds_ib_xmit","project":"168173141981676","target":"False"}
{"commit_id":"252007290437811","func":"static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t/* For the embedded inc. Matching put is in loop_inc_free() */\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}","idx":330,"name":"rds_loop_xmit","project":"135745802249266","target":"False"}
{"commit_id":"240362445846100","func":"void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tint no_module;\n\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\n\tno_module = !dev;\n\tif (no_module && capable(CAP_NET_ADMIN))\n\t\tno_module = request_module(\"netdev-%s\", name);\n\tif (no_module && capable(CAP_SYS_MODULE)) {\n\t\tif (!request_module(\"%s\", name))\n\t\t\tpr_err(\"Loading kernel module for a network device \"\n\"with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \"\n\"instead\\n\", name);\n\t}\n}","idx":332,"name":"dev_load","project":"26404692361463","target":"False"}
{"commit_id":"259571140091752","func":"static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\n\tperf_read_regs(regs);\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\t/* event has overflowed */\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\n\t/*\n\t * In case we didn't find and reset the event that caused\n\t * the interrupt, scan all events and reset any that are\n\t * negative, to avoid getting continual interrupts.\n\t * Any that we processed in the previous loop will not be negative.\n\t */\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif (pmc_overflow(val))\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\n\t/*\n\t * Reset MMCR0 to its normal value.  This will set PMXE and\n\t * clear FC (freeze counters) and PMAO (perf mon alert occurred)\n\t * and thus allow interrupts to occur again.\n\t * XXX might want to use MSR.PM to keep the events frozen until\n\t * we get back out of this interrupt.\n\t */\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}","idx":334,"name":"perf_event_interrupt","project":"253891839574055","target":"False"}
{"commit_id":"211851907726263","func":"static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\n\t/*\n\t * Events on POWER7 can roll back if a speculative event doesn't\n\t * eventually complete. Unfortunately in some rare cases they will\n\t * raise a performance monitor exception. We need to catch this to\n\t * ensure we reset the PMC. In all cases the PMC will be 256 or less\n\t * cycles from overflow.\n\t *\n\t * We only do this if the first pass fails to find any overflowing\n\t * PMCs because a user might set a period of less than 256 and we\n\t * don't want to mistakenly reset them.\n\t */\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\n\treturn false;\n}","idx":335,"name":"pmc_overflow","project":"253891839574055","target":"False"}
{"commit_id":"192525210604212","func":"static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}","idx":337,"name":"x86_assign_hw_event","project":"151638281669925","target":"False"}
{"commit_id":"99673908048129","func":"long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}","idx":340,"name":"do_rt_tgsigqueueinfo","project":"12971557257100","target":"False"}
{"commit_id":"274652237031755","func":"SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info.si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info.si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}","idx":341,"name":"SYSCALL_DEFINE3","project":"12971557257100","target":"False"}
{"commit_id":"74044978188768","func":"long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\treturn video_usercopy(file, cmd, arg, __video_do_ioctl);\n}","idx":344,"name":"video_ioctl2","project":"13690076025836","target":"False"}
{"commit_id":"112886753874689","func":"video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}","idx":345,"name":"video_usercopy","project":"13690076025836","target":"False"}
{"commit_id":"194799334858975","func":"midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\t/* Invalid patch format */\n\tif (format != SYSEX_PATCH)\n\t\t  return -EINVAL;\n\n\t/* Patch header too short */\n\tif (count < hdr_size)\n\t\treturn -EINVAL;\n\n\tcount -= hdr_size;\n\n\t/*\n\t * Copy the header from user space\n\t */\n\n\tif (copy_from_user(&sysex, addr, hdr_size))\n\t\treturn -EFAULT;\n\n\t/* Sysex record too short */\n\tif ((unsigned)count < (unsigned)sysex.len)\n\t\tsysex.len = count;\n\n\tleft = sysex.len;\n\tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}","idx":347,"name":"midi_synth_load_patch","project":"174617136821649","target":"False"}
{"commit_id":"54835894347900","func":"static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}","idx":349,"name":"opl3_load_patch","project":"22194042226484","target":"False"}
{"commit_id":"232168532757005","func":"int sequencer_write(int dev, struct file *file, const char __user *buf, int count)\n{\n\tunsigned char event_rec[EV_SZ], ev_code;\n\tint p = 0, c, ev_size;\n\tint mode = translate_mode(file);\n\n\tdev = dev >> 4;\n\n\tDEB(printk(\"sequencer_write(dev=%d, count=%d)\\n\", dev, count));\n\n\tif (mode == OPEN_READ)\n\t\treturn -EIO;\n\n\tc = count;\n\n\twhile (c >= 4)\n\t{\n\t\tif (copy_from_user((char *) event_rec, &(buf)[p], 4))\n\t\t\tgoto out;\n\t\tev_code = event_rec[0];\n\n\t\tif (ev_code == SEQ_FULLSIZE)\n\t\t{\n\t\t\tint err, fmt;\n\n\t\t\tdev = *(unsigned short *) &event_rec[2];\n\t\t\tif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\n\t\t\t\treturn -ENXIO;\n\n\t\t\tif (!(synth_open_mask & (1 << dev)))\n\t\t\t\treturn -ENXIO;\n\n\t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (ev_code >= 128)\n\t\t{\n\t\t\tif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: Invalid level 2 event %x\\n\", ev_code);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 8;\n\n\t\t\tif (c < ev_size)\n\t\t\t{\n\t\t\t\tif (!seq_playing)\n\t\t\t\t\tseq_startplay();\n\t\t\t\treturn count - c;\n\t\t\t}\n\t\t\tif (copy_from_user((char *)&event_rec[4],\n\t\t\t\t\t   &(buf)[p + 4], 4))\n\t\t\t\tgoto out;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (seq_mode == SEQ_2)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"Sequencer: 4 byte event in level 2 mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tev_size = 4;\n\n\t\t\tif (event_rec[0] != SEQ_MIDIPUTC)\n\t\t\t\tobsolete_api_used = 1;\n\t\t}\n\n\t\tif (event_rec[0] == SEQ_MIDIPUTC)\n\t\t{\n\t\t\tif (!midi_opened[event_rec[2]])\n\t\t\t{\n\t\t\t\tint err, mode;\n\t\t\t\tint dev = event_rec[2];\n\n\t\t\t\tif (dev >= max_mididev || midi_devs[dev]==NULL)\n\t\t\t\t{\n\t\t\t\t\t/*printk(\"Sequencer Error: Nonexistent MIDI device %d\\n\", dev);*/\n\t\t\t\t\treturn -ENXIO;\n\t\t\t\t}\n\t\t\t\tmode = translate_mode(file);\n\n\t\t\t\tif ((err = midi_devs[dev]->open(dev, mode,\n\t\t\t\t\t\t\t\tsequencer_midi_input, sequencer_midi_output)) < 0)\n\t\t\t\t{\n\t\t\t\t\tseq_reset();\n\t\t\t\t\tprintk(KERN_WARNING \"Sequencer Error: Unable to open Midi #%d\\n\", dev);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tmidi_opened[dev] = 1;\n\t\t\t}\n\t\t}\n\t\tif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\n\t\t{\n\t\t\tint processed = count - c;\n\n\t\t\tif (!seq_playing)\n\t\t\t\tseq_startplay();\n\n\t\t\tif (!processed && (file->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\t\t\telse\n\t\t\t\treturn processed;\n\t\t}\n\t\tp += ev_size;\n\t\tc -= ev_size;\n\t}\n\n\tif (!seq_playing)\n\t\tseq_startplay();\nout:\n\treturn count;\n}","idx":351,"name":"sequencer_write","project":"264084761299805","target":"False"}
{"commit_id":"172060591404504","func":"static void opl3_panning(int dev, int voice, int value)\n{\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tdevc->voc[voice].panning = value;\n}","idx":353,"name":"opl3_panning","project":"182884661600614","target":"False"}
{"commit_id":"185480811943992","func":"static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tif (chn < 0 || chn > 15)\n\t\treturn;\n\n\tinfo = &synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}","idx":354,"name":"opl3_setup_voice","project":"182884661600614","target":"False"}
{"commit_id":"168312234669696","func":"static int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}","idx":355,"name":"proc_dmesg_restrict","project":"183940249785315","target":"False"}
{"commit_id":"125224316326053","func":"static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t/* 60 bytes */\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t/* 60 bytes */\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n\tn = 1;\n\n\tname_len = fp[n++];\n\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\n\tattr_len = fp[n++];\n\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t/* We have a match; send the value.  */\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}","idx":356,"name":"iriap_getvaluebyclass_indication","project":"60099808988429","target":"False"}
{"commit_id":"82079536992419","func":"int rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n\t\t\tswitch (*p) {\n\t\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t/* Error in facilities format */\n\t}\n\n\treturn 1;\n}","idx":358,"name":"rose_parse_facilities","project":"68422682842186","target":"False"}
{"commit_id":"256402984801655","func":"static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}","idx":359,"name":"rose_parse_ccitt","project":"68422682842186","target":"False"}
{"commit_id":"6553902572855","func":"static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}","idx":360,"name":"rose_parse_national","project":"68422682842186","target":"False"}
{"commit_id":"223879354521589","func":"int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct rose_sock *make_rose;\n\tstruct rose_facilities_struct facilities;\n\tint n;\n\n\tskb->sk = NULL;\t\t/* Initially we don't know who it's for */\n\n\t/*\n\t *\tskb->data points to the rose frame start\n\t */\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\treturn 0;\n\t}\n\n\tsk = rose_find_listener(&facilities.source_addr, &facilities.source_call);\n\n\t/*\n\t * We can't accept the Call Request.\n\t */\n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = rose_make_new(sk)) == NULL) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\treturn 0;\n\t}\n\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmake_rose = rose_sk(make);\n\n\tmake_rose->lci           = lci;\n\tmake_rose->dest_addr     = facilities.dest_addr;\n\tmake_rose->dest_call     = facilities.dest_call;\n\tmake_rose->dest_ndigis   = facilities.dest_ndigis;\n\tfor (n = 0 ; n < facilities.dest_ndigis ; n++)\n\t\tmake_rose->dest_digis[n] = facilities.dest_digis[n];\n\tmake_rose->source_addr   = facilities.source_addr;\n\tmake_rose->source_call   = facilities.source_call;\n\tmake_rose->source_ndigis = facilities.source_ndigis;\n\tfor (n = 0 ; n < facilities.source_ndigis ; n++)\n\t\tmake_rose->source_digis[n]= facilities.source_digis[n];\n\tmake_rose->neighbour     = neigh;\n\tmake_rose->device        = dev;\n\tmake_rose->facilities    = facilities;\n\n\tmake_rose->neighbour->use++;\n\n\tif (rose_sk(sk)->defer) {\n\t\tmake_rose->state = ROSE_STATE_5;\n\t} else {\n\t\trose_write_internal(make, ROSE_CALL_ACCEPTED);\n\t\tmake_rose->state = ROSE_STATE_3;\n\t\trose_start_idletimer(make);\n\t}\n\n\tmake_rose->condition = 0x00;\n\tmake_rose->vs        = 0;\n\tmake_rose->va        = 0;\n\tmake_rose->vr        = 0;\n\tmake_rose->vl        = 0;\n\tsk->sk_ack_backlog++;\n\n\trose_insert_socket(make);\n\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\trose_start_heartbeat(make);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk, skb->len);\n\n\treturn 1;\n}","idx":362,"name":"rose_rx_call_request","project":"83821377722439","target":"False"}
{"commit_id":"65482201880960","func":"static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tif (skb->len < ROSE_MIN_LEN) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tif (frametype == ROSE_CALL_REQUEST &&\n\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}","idx":364,"name":"rose_loopback_timer","project":"36346335786319","target":"False"}
{"commit_id":"240396360145495","func":"int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n{\n\tstruct rose_neigh *rose_neigh, *new_neigh;\n\tstruct rose_route *rose_route;\n\tstruct rose_facilities_struct facilities;\n\trose_address *src_addr, *dest_addr;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci, new_lci;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tint res = 0;\n\tchar buf[11];\n\n#if 0\n\tif (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)\n\t\treturn res;\n#endif\n\n\tif (skb->len < ROSE_MIN_LEN)\n\t\treturn res;\n\tframetype = skb->data[2];\n\tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\tif (frametype == ROSE_CALL_REQUEST &&\n\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t     ROSE_CALL_REQ_ADDR_LEN_VAL))\n\t\treturn res;\n\tsrc_addr  = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\n\tdest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 &&\n\t\t    ax25->ax25_dev->dev == rose_neigh->dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\tprintk(\"rose_route : unknown neighbour or device %s\\n\",\n\t\t       ax2asc(buf, &ax25->dest_addr));\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tObviously the link is working, halt the ftimer.\n\t */\n\trose_stop_ftimer(rose_neigh);\n\n\t/*\n\t *\tLCI of zero is always for us, and its always a restart\n\t * \tframe.\n\t */\n\tif (lci == 0) {\n\t\trose_link_rx_restart(skb, rose_neigh, frametype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tFind an existing socket.\n\t */\n\tif ((sk = rose_find_socket(lci, rose_neigh)) != NULL) {\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\t\t/* Remove an existing unused socket */\n\t\t\trose_clear_queues(sk);\n\t\t\trose->cause\t = ROSE_NETWORK_CONGESTION;\n\t\t\trose->diagnostic = 0;\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour\t = NULL;\n\t\t\trose->lci\t = 0;\n\t\t\trose->state\t = ROSE_STATE_0;\n\t\t\tsk->sk_state\t = TCP_CLOSE;\n\t\t\tsk->sk_err\t = 0;\n\t\t\tsk->sk_shutdown\t |= SEND_SHUTDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tres = rose_process_rx_frame(sk, skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tIs is a Call Request and is it for us ?\n\t */\n\tif (frametype == ROSE_CALL_REQUEST)\n\t\tif ((dev = rose_dev_get(dest_addr)) != NULL) {\n\t\t\tres = rose_rx_call_request(skb, dev, rose_neigh, lci);\n\t\t\tdev_put(dev);\n\t\t\tgoto out;\n\t\t}\n\n\tif (!sysctl_rose_routing_control) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tRoute it to the next in line if we have an entry for it.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->lci1 == lci &&\n\t\t    rose_route->neigh1 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh2 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh2);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (rose_route->lci2 == lci &&\n\t\t    rose_route->neigh2 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh1 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh1);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\t/*\n\t *\tWe know that:\n\t *\t1. The frame isn't for us,\n\t *\t2. It isn't \"owned\" by any existing route.\n\t */\n\tif (frametype != ROSE_CALL_REQUEST) {\t/* XXX */\n\t\tres = 0;\n\t\tgoto out;\n\t}\n\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCheck for routing loops.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->rand == facilities.rand &&\n\t\t    rosecmp(src_addr, &rose_route->src_addr) == 0 &&\n\t\t    ax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&\n\t\t    ax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {\n\t\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);\n\t\t\tgoto out;\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\tif ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic, 1)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);\n\t\tgoto out;\n\t}\n\n\tif ((new_lci = rose_new_lci(new_neigh)) == 0) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 71);\n\t\tgoto out;\n\t}\n\n\tif ((rose_route = kmalloc(sizeof(*rose_route), GFP_ATOMIC)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\tgoto out;\n\t}\n\n\trose_route->lci1      = lci;\n\trose_route->src_addr  = *src_addr;\n\trose_route->dest_addr = *dest_addr;\n\trose_route->src_call  = facilities.dest_call;\n\trose_route->dest_call = facilities.source_call;\n\trose_route->rand      = facilities.rand;\n\trose_route->neigh1    = rose_neigh;\n\trose_route->lci2      = new_lci;\n\trose_route->neigh2    = new_neigh;\n\n\trose_route->neigh1->use++;\n\trose_route->neigh2->use++;\n\n\trose_route->next = rose_route_list;\n\trose_route_list  = rose_route;\n\n\tskb->data[0] &= 0xF0;\n\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\n\trose_transmit_link(skb, rose_route->neigh2);\n\tres = 1;\n\nout:\n\tspin_unlock_bh(&rose_route_list_lock);\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\n\treturn res;\n}","idx":366,"name":"rose_route_frame","project":"209673985093604","target":"False"}
{"commit_id":"233009630404038","func":"int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\n\treturn facilities_len == 0;\n}","idx":369,"name":"rose_parse_facilities","project":"87233230065746","target":"False"}
{"commit_id":"199038732969187","func":"static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (len < 2 + l)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tif (l < 1 + ROSE_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tif (l % AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}","idx":370,"name":"rose_parse_national","project":"87233230065746","target":"False"}
{"commit_id":"222141508070819","func":"void rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tchar buffer[100];\n\tint len, faclen = 0;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(buffer, rose);\n\t\tlen   += faclen;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t/*\n\t *\tSpace for AX.25 header and PID.\n\t */\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\n\n\tdptr = skb_put(skb, skb_tailroom(skb));\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, buffer, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t/* Address length */\n\t\t*dptr++ = 0;\t\t/* Facilities length */\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}","idx":371,"name":"rose_write_internal","project":"87233230065746","target":"False"}
{"commit_id":"18034125992998","func":"static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}","idx":372,"name":"rose_parse_ccitt","project":"87233230065746","target":"False"}
{"commit_id":"156034469497927","func":"static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tif (!IS_ERR(vma))\n\t\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}","idx":374,"name":"m_stop","project":"56163155914435","target":"False"}
{"commit_id":"235851917404239","func":"int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}","idx":376,"name":"tpm_open","project":"63491585838103","target":"False"}
{"commit_id":"198231355229542","func":"static void dma_rx(struct b43_dmaring *ring, int *slot)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_rxhdr_fw4 *rxhdr;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tint err;\n\tdma_addr_t dmaaddr;\n\n\tdesc = ops->idx2desc(ring, *slot, &meta);\n\n\tsync_descbuffer_for_cpu(ring, meta->dmaaddr, ring->rx_buffersize);\n\tskb = meta->skb;\n\n\trxhdr = (struct b43_rxhdr_fw4 *)skb->data;\n\tlen = le16_to_cpu(rxhdr->frame_len);\n\tif (len == 0) {\n\t\tint i = 0;\n\n\t\tdo {\n\t\t\tudelay(2);\n\t\t\tbarrier();\n\t\t\tlen = le16_to_cpu(rxhdr->frame_len);\n\t\t} while (len == 0 && i++ < 5);\n\t\tif (unlikely(len == 0)) {\n\t\t\tdmaaddr = meta->dmaaddr;\n\t\t\tgoto drop_recycle_buffer;\n\t\t}\n\t}\n\tif (unlikely(b43_rx_buffer_is_poisoned(ring, skb))) {\n\t\t/* Something went wrong with the DMA.\n\t\t * The device did not touch the buffer and did not overwrite the poison. */\n\t\tb43dbg(ring->dev->wl, \"DMA RX: Dropping poisoned buffer.\\n\");\n\t\tdmaaddr = meta->dmaaddr;\n\t\tgoto drop_recycle_buffer;\n\t}\n\tif (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {\n\t\t/* The data did not fit into one descriptor buffer\n\t\t * and is split over multiple buffers.\n\t\t * This should never happen, as we try to allocate buffers\n\t\t * big enough. So simply ignore this packet.\n\t\t */\n\t\tint cnt = 0;\n\t\ts32 tmp = len;\n\n\t\twhile (1) {\n\t\t\tdesc = ops->idx2desc(ring, *slot, &meta);\n\t\t\t/* recycle the descriptor buffer. */\n\t\t\tb43_poison_rx_buffer(ring, meta->skb);\n\t\t\tsync_descbuffer_for_device(ring, meta->dmaaddr,\n\t\t\t\t\t\t   ring->rx_buffersize);\n\t\t\t*slot = next_slot(ring, *slot);\n\t\t\tcnt++;\n\t\t\ttmp -= ring->rx_buffersize;\n\t\t\tif (tmp <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tb43err(ring->dev->wl, \"DMA RX buffer too small \"\n\t\t       \"(len: %u, buffer: %u, nr-dropped: %d)\\n\",\n\t\t       len, ring->rx_buffersize, cnt);\n\t\tgoto drop;\n\t}\n\n\tdmaaddr = meta->dmaaddr;\n\terr = setup_rx_descbuffer(ring, desc, meta, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tb43dbg(ring->dev->wl, \"DMA RX: setup_rx_descbuffer() failed\\n\");\n\t\tgoto drop_recycle_buffer;\n\t}\n\n\tunmap_descbuffer(ring, dmaaddr, ring->rx_buffersize, 0);\n\tskb_put(skb, len + ring->frameoffset);\n\tskb_pull(skb, ring->frameoffset);\n\n\tb43_rx(ring->dev, skb, rxhdr);\ndrop:\n\treturn;\n\ndrop_recycle_buffer:\n\t/* Poison and recycle the RX buffer. */\n\tb43_poison_rx_buffer(ring, skb);\n\tsync_descbuffer_for_device(ring, dmaaddr, ring->rx_buffersize);\n}","idx":378,"name":"dma_rx","project":"258170342606915","target":"False"}
{"commit_id":"236019003577622","func":"static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\t/* ideally the idr is empty and we won't hit the BUG in teh callback */\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}","idx":379,"name":"inotify_free_group_priv","project":"120117290056513","target":"False"}
{"commit_id":"38123402864822","func":"SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\n\t/* Check the IN_* constants for consistency.  */\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\t/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */\n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_put_group(group);\n\n\treturn ret;\n}","idx":383,"name":"SYSCALL_DEFINE1","project":"57532827575778","target":"False"}
{"commit_id":"103602209724533","func":"static struct fsnotify_group *inotify_new_group(unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\tgroup->max_events = max_events;\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.fa = NULL;\n\tgroup->inotify_data.user = get_current_user();\n\n\tif (atomic_inc_return(&group->inotify_data.user->inotify_devs) >\n\t    inotify_max_user_instances) {\n\t\tfsnotify_put_group(group);\n\t\treturn ERR_PTR(-EMFILE);\n\t}\n\n\treturn group;\n}","idx":384,"name":"inotify_new_group","project":"57532827575778","target":"False"}
{"commit_id":"153882767021282","func":"\t\t\t\t__acquires(kernel_lock)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS) {\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, \"bsdgroups\",\n\t\t\t\"2.6.38\");\n\t\tset_opt(sb, GRPID);\n\t}\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n#ifdef CONFIG_EXT4_FS_XATTR\n\tset_opt(sb, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\tset_opt(sb, MBLK_IO_SUBMIT);\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\tif (def_mount_opts & EXT4_DEFM_BLOCK_VALIDITY)\n\t\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, NULL, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#blocks per group too big: %lu\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                ext4_msg(sb, KERN_WARNING, \"bad geometry: first data\"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n#endif\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tinit_timer(&sbi->s_err_report);\n\tsbi->s_err_report.function = print_daily_error_info;\n\tsbi->s_err_report.data = (unsigned long) sb;\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_max_writeback_mb_bump = 128;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tsb->s_op = &ext4_sops;\n\telse\n\t\tsb->s_op = &ext4_nojournal_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tset_opt(sb, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\t/*\n\t * The journal may have updated the bg summary counts, so we\n\t * need to update the global counters.\n\t */\n\tpercpu_counter_set(&sbi->s_freeblocks_counter,\n\t\t\t   ext4_count_free_blocks(sb));\n\tpercpu_counter_set(&sbi->s_freeinodes_counter,\n\t\t\t   ext4_count_free_inodes(sb));\n\tpercpu_counter_set(&sbi->s_dirs_counter,\n\t\t\t   ext4_count_dirs(sb));\n\tpercpu_counter_set(&sbi->s_dirtyblocks_counter, 0);\n\nno_journal:\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->dio_unwritten_wq =\n\t\talloc_workqueue(\"ext4-dio-unwritten\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\tif (test_opt(sb, DELALLOC) &&\n\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring delalloc option - \"\n\t\t\t \"requested data journaling mode\");\n\t\tclear_opt(sb, DELALLOC);\n\t}\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - requested data journaling mode\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t\tif (sb->s_blocksize < PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - block size is too small\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t}\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount4;\n\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount4;\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\text4_mb_release(sb);\n\t\text4_ext_release(sb);\n\t\tgoto failed_mount4;\n\t};\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\nfailed_mount4:\n\tiput(root);\n\tsb->s_root = NULL;\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tdestroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);\nfailed_mount_wq:\n\text4_release_system_zone(sb);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tdel_timer(&sbi->s_err_report);\n\tif (sbi->s_flex_groups) {\n\t\tif (is_vmalloc_addr(sbi->s_flex_groups))\n\t\t\tvfree(sbi->s_flex_groups);\n\t\telse\n\t\t\tkfree(sbi->s_flex_groups);\n\t}\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn ret;\n}","idx":386,"name":"__acquires","project":"84143171438606","target":"False"}
{"commit_id":"204211061536573","func":"static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\n\t/* Need to be careful about a growing mapping */\n\tif (new_len > old_len) {\n\t\tunsigned long pgoff;\n\n\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n\t\t\tgoto Efault;\n\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpgoff += vma->vm_pgoff;\n\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n\t\t\tgoto Einval;\n\t}\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}","idx":388,"name":"vma_to_resize","project":"263599377473806","target":"False"}
{"commit_id":"90904349964505","func":"cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}","idx":390,"name":"cifs_mount","project":"27144755206268","target":"False"}
{"commit_id":"91230419341089","func":"static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tif (iph->ihl == 5)\n\t\treturn 0;\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}","idx":392,"name":"br_parse_ip_options","project":"82820302477370","target":"False"}
{"commit_id":"38697500317492","func":"static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t * do checksum of UDP packets sent as multiple IP fragments.\n\t */\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* Check if there is enough headroom to insert fragment header. */\n\tif ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.\n\t */\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\n\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t * fragment header are updated in ipv6_gso_segment()\n\t */\n\tsegs = skb_segment(skb, features);\n\nout:\n\treturn segs;\n}","idx":394,"name":"udp6_ufo_fragment","project":"109393055881853","target":"False"}
{"commit_id":"211787839159037","func":"static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}","idx":396,"name":"vma_adjust_trans_huge","project":"142504911172269","target":"False"}
{"commit_id":"230663539958876","func":"static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n\t\t\t\t\t    struct page **hpage)\n{\n\tstruct mm_slot *mm_slot;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tint progress = 0;\n\n\tVM_BUG_ON(!pages);\n\tVM_BUG_ON(!spin_is_locked(&khugepaged_mm_lock));\n\n\tif (khugepaged_scan.mm_slot)\n\t\tmm_slot = khugepaged_scan.mm_slot;\n\telse {\n\t\tmm_slot = list_entry(khugepaged_scan.mm_head.next,\n\t\t\t\t     struct mm_slot, mm_node);\n\t\tkhugepaged_scan.address = 0;\n\t\tkhugepaged_scan.mm_slot = mm_slot;\n\t}\n\tspin_unlock(&khugepaged_mm_lock);\n\n\tmm = mm_slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, khugepaged_scan.address);\n\n\tprogress++;\n\tfor (; vma; vma = vma->vm_next) {\n\t\tunsigned long hstart, hend;\n\n\t\tcond_resched();\n\t\tif (unlikely(khugepaged_test_exit(mm))) {\n\t\t\tprogress++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((!(vma->vm_flags & VM_HUGEPAGE) &&\n\t\t     !khugepaged_always()) ||\n\t\t    (vma->vm_flags & VM_NOHUGEPAGE)) {\n\t\tskip:\n\t\t\tprogress++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!vma->anon_vma || vma->vm_ops)\n\t\t\tgoto skip;\n\t\tif (is_vma_temporary_stack(vma))\n\t\t\tgoto skip;\n\t\t/*\n\t\t * If is_pfn_mapping() is true is_learn_pfn_mapping()\n\t\t * must be true too, verify it here.\n\t\t */\n\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) ||\n\t\t\t  vma->vm_flags & VM_NO_THP);\n\n\t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\t\thend = vma->vm_end & HPAGE_PMD_MASK;\n\t\tif (hstart >= hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address > hend)\n\t\t\tgoto skip;\n\t\tif (khugepaged_scan.address < hstart)\n\t\t\tkhugepaged_scan.address = hstart;\n\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n\n\t\twhile (khugepaged_scan.address < hend) {\n\t\t\tint ret;\n\t\t\tcond_resched();\n\t\t\tif (unlikely(khugepaged_test_exit(mm)))\n\t\t\t\tgoto breakouterloop;\n\n\t\t\tVM_BUG_ON(khugepaged_scan.address < hstart ||\n\t\t\t\t  khugepaged_scan.address + HPAGE_PMD_SIZE >\n\t\t\t\t  hend);\n\t\t\tret = khugepaged_scan_pmd(mm, vma,\n\t\t\t\t\t\t  khugepaged_scan.address,\n\t\t\t\t\t\t  hpage);\n\t\t\t/* move to next address */\n\t\t\tkhugepaged_scan.address += HPAGE_PMD_SIZE;\n\t\t\tprogress += HPAGE_PMD_NR;\n\t\t\tif (ret)\n\t\t\t\t/* we released mmap_sem so break loop */\n\t\t\t\tgoto breakouterloop_mmap_sem;\n\t\t\tif (progress >= pages)\n\t\t\t\tgoto breakouterloop;\n\t\t}\n\t}\nbreakouterloop:\n\tup_read(&mm->mmap_sem); /* exit_mmap will destroy ptes after this */\nbreakouterloop_mmap_sem:\n\n\tspin_lock(&khugepaged_mm_lock);\n\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n\t/*\n\t * Release the current mm_slot if this mm is about to die, or\n\t * if we scanned all vmas of this mm.\n\t */\n\tif (khugepaged_test_exit(mm) || !vma) {\n\t\t/*\n\t\t * Make sure that if mm_users is reaching zero while\n\t\t * khugepaged runs here, khugepaged_exit will find\n\t\t * mm_slot not pointing to the exiting mm.\n\t\t */\n\t\tif (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {\n\t\t\tkhugepaged_scan.mm_slot = list_entry(\n\t\t\t\tmm_slot->mm_node.next,\n\t\t\t\tstruct mm_slot, mm_node);\n\t\t\tkhugepaged_scan.address = 0;\n\t\t} else {\n\t\t\tkhugepaged_scan.mm_slot = NULL;\n\t\t\tkhugepaged_full_scans++;\n\t\t}\n\n\t\tcollect_mm_slot(mm_slot);\n\t}\n\n\treturn progress;\n}","idx":401,"name":"khugepaged_scan_mm_slot","project":"16966830567002","target":"False"}
{"commit_id":"59779590892676","func":"static void collapse_huge_page(struct mm_struct *mm,\n\t\t\t       unsigned long address,\n\t\t\t       struct page **hpage,\n\t\t\t       struct vm_area_struct *vma,\n\t\t\t       int node)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd, _pmd;\n\tpte_t *pte;\n\tpgtable_t pgtable;\n\tstruct page *new_page;\n\tspinlock_t *ptl;\n\tint isolated;\n\tunsigned long hstart, hend;\n\n\tVM_BUG_ON(address & ~HPAGE_PMD_MASK);\n#ifndef CONFIG_NUMA\n\tVM_BUG_ON(!*hpage);\n\tnew_page = *hpage;\n\tif (unlikely(mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))) {\n\t\tup_read(&mm->mmap_sem);\n\t\treturn;\n\t}\n#else\n\tVM_BUG_ON(*hpage);\n\t/*\n\t * Allocate the page while the vma is still valid and under\n\t * the mmap_sem read mode so there is no memory allocation\n\t * later when we take the mmap_sem in write mode. This is more\n\t * friendly behavior (OTOH it may actually hide bugs) to\n\t * filesystems in userland with daemons allocating memory in\n\t * the userland I/O paths.  Allocating memory with the\n\t * mmap_sem in read mode is good idea also to allow greater\n\t * scalability.\n\t */\n\tnew_page = alloc_hugepage_vma(khugepaged_defrag(), vma, address,\n\t\t\t\t      node, __GFP_OTHER_NODE);\n\tif (unlikely(!new_page)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tcount_vm_event(THP_COLLAPSE_ALLOC_FAILED);\n\t\t*hpage = ERR_PTR(-ENOMEM);\n\t\treturn;\n\t}\n\tcount_vm_event(THP_COLLAPSE_ALLOC);\n\tif (unlikely(mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))) {\n\t\tup_read(&mm->mmap_sem);\n\t\tput_page(new_page);\n\t\treturn;\n\t}\n#endif\n\n\t/* after allocating the hugepage upgrade to mmap_sem write mode */\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Prevent all access to pagetables with the exception of\n\t * gup_fast later hanlded by the ptep_clear_flush and the VM\n\t * handled by the anon_vma lock + PG_lock.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tif (unlikely(khugepaged_test_exit(mm)))\n\t\tgoto out;\n\n\tvma = find_vma(mm, address);\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (address < hstart || address + HPAGE_PMD_SIZE > hend)\n\t\tgoto out;\n\n\tif ((!(vma->vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||\n\t    (vma->vm_flags & VM_NOHUGEPAGE))\n\t\tgoto out;\n\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\tgoto out;\n\tif (is_vma_temporary_stack(vma))\n\t\tgoto out;\n\t/*\n\t * If is_pfn_mapping() is true is_learn_pfn_mapping() must be\n\t * true too, verify it here.\n\t */\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);\n\n\tpgd = pgd_offset(mm, address);\n\tif (!pgd_present(*pgd))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (!pud_present(*pud))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\t/* pmd can't go away or become huge under us */\n\tif (!pmd_present(*pmd) || pmd_trans_huge(*pmd))\n\t\tgoto out;\n\n\tanon_vma_lock(vma->anon_vma);\n\n\tpte = pte_offset_map(pmd, address);\n\tptl = pte_lockptr(mm, pmd);\n\n\tspin_lock(&mm->page_table_lock); /* probably unnecessary */\n\t/*\n\t * After this gup_fast can't run anymore. This also removes\n\t * any huge TLB entry from the CPU so we won't allow\n\t * huge and small TLB entries for the same virtual address\n\t * to avoid the risk of CPU bugs in that area.\n\t */\n\t_pmd = pmdp_clear_flush_notify(vma, address, pmd);\n\tspin_unlock(&mm->page_table_lock);\n\n\tspin_lock(ptl);\n\tisolated = __collapse_huge_page_isolate(vma, address, pte);\n\tspin_unlock(ptl);\n\n\tif (unlikely(!isolated)) {\n\t\tpte_unmap(pte);\n\t\tspin_lock(&mm->page_table_lock);\n\t\tBUG_ON(!pmd_none(*pmd));\n\t\tset_pmd_at(mm, address, pmd, _pmd);\n\t\tspin_unlock(&mm->page_table_lock);\n\t\tanon_vma_unlock(vma->anon_vma);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * All pages are isolated and locked so anon_vma rmap\n\t * can't run anymore.\n\t */\n\tanon_vma_unlock(vma->anon_vma);\n\n\t__collapse_huge_page_copy(pte, new_page, vma, address, ptl);\n\tpte_unmap(pte);\n\t__SetPageUptodate(new_page);\n\tpgtable = pmd_pgtable(_pmd);\n\tVM_BUG_ON(page_count(pgtable) != 1);\n\tVM_BUG_ON(page_mapcount(pgtable) != 0);\n\n\t_pmd = mk_pmd(new_page, vma->vm_page_prot);\n\t_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);\n\t_pmd = pmd_mkhuge(_pmd);\n\n\t/*\n\t * spin_lock() below is not the equivalent of smp_wmb(), so\n\t * this is needed to avoid the copy_huge_page writes to become\n\t * visible after the set_pmd_at() write.\n\t */\n\tsmp_wmb();\n\n\tspin_lock(&mm->page_table_lock);\n\tBUG_ON(!pmd_none(*pmd));\n\tpage_add_new_anon_rmap(new_page, vma, address);\n\tset_pmd_at(mm, address, pmd, _pmd);\n\tupdate_mmu_cache(vma, address, entry);\n\tprepare_pmd_huge_pte(pgtable, mm);\n\tmm->nr_ptes--;\n\tspin_unlock(&mm->page_table_lock);\n\n#ifndef CONFIG_NUMA\n\t*hpage = NULL;\n#endif\n\tkhugepaged_pages_collapsed++;\nout_up_write:\n\tup_write(&mm->mmap_sem);\n\treturn;\n\nout:\n\tmem_cgroup_uncharge_page(new_page);\n#ifdef CONFIG_NUMA\n\tput_page(new_page);\n#endif\n\tgoto out_up_write;\n}","idx":402,"name":"collapse_huge_page","project":"16966830567002","target":"False"}
{"commit_id":"43325607659909","func":"int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\t/*\n\t\t * Not yet faulted in so we will register later in the\n\t\t * page fault if needed.\n\t\t */\n\t\treturn 0;\n\tif (vma->vm_ops)\n\t\t/* khugepaged not yet working on file or special mappings */\n\t\treturn 0;\n\t/*\n\t * If is_pfn_mapping() is true is_learn_pfn_mapping() must be\n\t * true too, verify it here.\n\t */\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}","idx":403,"name":"khugepaged_enter_vma_merge","project":"16966830567002","target":"False"}
{"commit_id":"42235453648349","func":"int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}","idx":404,"name":"hugepage_madvise","project":"16966830567002","target":"False"}
{"commit_id":"53630287515446","func":"int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;\n\n\trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,\n\t\t\t       inet->inet_sport, inet->inet_dport, sk);\n\tif (IS_ERR(rt)) {\n\t\trt = NULL;\n\t\tgoto failure;\n\t}\n\t/* OK, now commit destination to socket.  */\n\tsk_setup_caps(sk, &rt->dst);\n\n\tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,\n\t\t\t\t\t\t    inet->inet_daddr,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport);\n\tinet->inet_id = dp->dccps_iss ^ jiffies;\n\n\terr = dccp_connect(sk);\n\trt = NULL;\n\tif (err != 0)\n\t\tgoto failure;\nout:\n\treturn err;\nfailure:\n\t/*\n\t * This unhashes the socket and releases the local port, if necessary.\n\t */\n\tdccp_set_state(sk, DCCP_CLOSED);\n\tip_rt_put(rt);\n\tsk->sk_route_caps = 0;\n\tinet->inet_dport = 0;\n\tgoto out;\n}","idx":407,"name":"dccp_v4_connect","project":"60835035360579","target":"False"}
{"commit_id":"140499756283187","func":"struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->inet_opt\t= ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}","idx":408,"name":"dccp_v4_request_recv_sock","project":"60835035360579","target":"False"}
{"commit_id":"157844768030584","func":"static struct sock *dccp_v6_request_recv_sock(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *ireq6 = inet6_rsk(req);\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (dst == NULL) {\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_DCCP;\n\t\tipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);\n\t\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\t\tipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.fl6_dport = inet_rsk(req)->rmt_port;\n\t\tfl6.fl6_sport = inet_rsk(req)->loc_port;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);\n\tnewsk->sk_bound_dev_if = ireq6->iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (ireq6->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(ireq6->pktopts);\n\t\tireq6->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (opt != NULL) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\tif (opt != NULL && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn NULL;\n}","idx":410,"name":"dccp_v6_request_recv_sock","project":"275658719589348","target":"False"}
{"commit_id":"116963269835279","func":"int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tstruct ip_options_rcu *inet_opt;\n\tint err;\n\n\t/* Route is OK, nothing to do. */\n\tif (rt)\n\t\treturn 0;\n\n\t/* Reroute. */\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tdaddr = inet->inet_daddr;\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trcu_read_unlock();\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t/* Routing failed... */\n\t\tsk->sk_route_caps = 0;\n\t\t/*\n\t\t * Other protocols have to map its equivalent state to TCP_SYN_SENT.\n\t\t * DCCP maps its DCCP_REQUESTING state to TCP_SYN_SENT. -acme\n\t\t */\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\n\treturn err;\n}","idx":414,"name":"inet_sk_rebuild_header","project":"188878254239156","target":"False"}
{"commit_id":"262779911071989","func":"static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\n\t\tif (!ret) {\n\t\t\tspin_lock(&ctx->event_wqh.lock);\n\t\t\tif (!list_empty(&fork_event)) {\n\t\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t\t       wq.entry);\n\t\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\t}\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t}\n\t}\n\n\treturn ret;\n}","idx":2170,"name":"userfaultfd_ctx_read","project":"85275401280549","target":"Privacy"}
{"commit_id":"239493581016049","func":"static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,\n\t\t\t\t    struct uffd_msg *msg)\n{\n\tssize_t ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct userfaultfd_wait_queue *uwq;\n\t/*\n\t * Handling fork event requires sleeping operations, so\n\t * we drop the event_wqh lock, then do these ops, then\n\t * lock it back and wake up the waiter. While the lock is\n\t * dropped the ewq may go away so we keep track of it\n\t * carefully.\n\t */\n\tLIST_HEAD(fork_event);\n\tstruct userfaultfd_ctx *fork_nctx = NULL;\n\n\t/* always take the fd_wqh lock before the fault_pending_wqh lock */\n\tspin_lock(&ctx->fd_wqh.lock);\n\t__add_wait_queue(&ctx->fd_wqh, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t\tuwq = find_userfault(ctx);\n\t\tif (uwq) {\n\t\t\t/*\n\t\t\t * Use a seqcount to repeat the lockless check\n\t\t\t * in wake_userfault() to avoid missing\n\t\t\t * wakeups because during the refile both\n\t\t\t * waitqueue could become empty if this is the\n\t\t\t * only userfault.\n\t\t\t */\n\t\t\twrite_seqcount_begin(&ctx->refile_seq);\n\n\t\t\t/*\n\t\t\t * The fault_pending_wqh.lock prevents the uwq\n\t\t\t * to disappear from under us.\n\t\t\t *\n\t\t\t * Refile this userfault from\n\t\t\t * fault_pending_wqh to fault_wqh, it's not\n\t\t\t * pending anymore after we read it.\n\t\t\t *\n\t\t\t * Use list_del() by hand (as\n\t\t\t * userfaultfd_wake_function also uses\n\t\t\t * list_del_init() by hand) to be sure nobody\n\t\t\t * changes __remove_wait_queue() to use\n\t\t\t * list_del_init() in turn breaking the\n\t\t\t * !list_empty_careful() check in\n\t\t\t * handle_userfault(). The uwq->wq.head list\n\t\t\t * must never be empty at any time during the\n\t\t\t * refile, or the waitqueue could disappear\n\t\t\t * from under us. The \"wait_queue_head_t\"\n\t\t\t * parameter of __remove_wait_queue() is unused\n\t\t\t * anyway.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->fault_wqh, &uwq->wq);\n\n\t\t\twrite_seqcount_end(&ctx->refile_seq);\n\n\t\t\t/* careful to always initialize msg if ret == 0 */\n\t\t\t*msg = uwq->msg;\n\t\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tuwq = find_userfault_evt(ctx);\n\t\tif (uwq) {\n\t\t\t*msg = uwq->msg;\n\n\t\t\tif (uwq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tfork_nctx = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tuwq->msg.arg.reserved.reserved1;\n\t\t\t\tlist_move(&uwq->wq.entry, &fork_event);\n\t\t\t\t/*\n\t\t\t\t * fork_nctx can be freed as soon as\n\t\t\t\t * we drop the lock, unless we take a\n\t\t\t\t * reference on it.\n\t\t\t\t */\n\t\t\t\tuserfaultfd_ctx_get(fork_nctx);\n\t\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (no_wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->fd_wqh.lock);\n\t\tschedule();\n\t\tspin_lock(&ctx->fd_wqh.lock);\n\t}\n\t__remove_wait_queue(&ctx->fd_wqh, &wait);\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->fd_wqh.lock);\n\n\tif (!ret && msg->event == UFFD_EVENT_FORK) {\n\t\tret = resolve_userfault_fork(ctx, fork_nctx, msg);\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t\tif (!list_empty(&fork_event)) {\n\t\t\t/*\n\t\t\t * The fork thread didn't abort, so we can\n\t\t\t * drop the temporary refcount.\n\t\t\t */\n\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\n\t\t\tuwq = list_first_entry(&fork_event,\n\t\t\t\t\t       typeof(*uwq),\n\t\t\t\t\t       wq.entry);\n\t\t\t/*\n\t\t\t * If fork_event list wasn't empty and in turn\n\t\t\t * the event wasn't already released by fork\n\t\t\t * (the event is allocated on fork kernel\n\t\t\t * stack), put the event back to its place in\n\t\t\t * the event_wq. fork_event head will be freed\n\t\t\t * as soon as we return so the event cannot\n\t\t\t * stay queued there no matter the current\n\t\t\t * \"ret\" value.\n\t\t\t */\n\t\t\tlist_del(&uwq->wq.entry);\n\t\t\t__add_wait_queue(&ctx->event_wqh, &uwq->wq);\n\n\t\t\t/*\n\t\t\t * Leave the event in the waitqueue and report\n\t\t\t * error to userland if we failed to resolve\n\t\t\t * the userfault fork.\n\t\t\t */\n\t\t\tif (likely(!ret))\n\t\t\t\tuserfaultfd_event_complete(ctx, uwq);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the fork thread aborted and the\n\t\t\t * refcount from the fork thread on fork_nctx\n\t\t\t * has already been released. We still hold\n\t\t\t * the reference we took before releasing the\n\t\t\t * lock above. If resolve_userfault_fork\n\t\t\t * failed we've to drop it because the\n\t\t\t * fork_nctx has to be freed in such case. If\n\t\t\t * it succeeded we'll hold it because the new\n\t\t\t * uffd references it.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tuserfaultfd_ctx_put(fork_nctx);\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t}\n\n\treturn ret;\n}","idx":2171,"name":"userfaultfd_ctx_read","project":"85275401280549","target":"Privacy"}
{"commit_id":"246360152353860","func":"static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}","idx":2172,"name":"userfaultfd_event_wait_completion","project":"85275401280549","target":"Privacy"}
{"commit_id":"201703497778869","func":"struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\toffset = offset_in_page(uaddr);\n\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n\t\t\t\t\t    bytes)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * check if vector was merged with previous\n\t\t\t * drop page reference if needed\n\t\t\t */\n\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n\t\t\t\tput_page(pages[j]);\n\n\t\t\tlen -= bytes;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}","idx":2179,"name":"bio_map_user_iov","project":"63668092494145","target":"Privacy"}
{"commit_id":"70440063197424","func":"struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\toffset = offset_in_page(uaddr);\n\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n\t\t\t\t\t    bytes)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * check if vector was merged with previous\n\t\t\t * drop page reference if needed\n\t\t\t */\n\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n\t\t\t\tput_page(pages[j]);\n\n\t\t\tlen -= bytes;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}","idx":2180,"name":"bio_map_user_iov","project":"267355323290795","target":"Privacy"}
{"commit_id":"135487596542841","func":"struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\tstruct bio_vec *bvec;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (unlikely(ret < local_nr_pages)) {\n\t\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\t\tif (!pages[j])\n\t\t\t\t\tbreak;\n\t\t\t\tput_page(pages[j]);\n\t\t\t}\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\toffset = offset_in_page(uaddr);\n\t\tfor (j = cur_page; j < page_limit; j++) {\n\t\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n\n\t\t\tif (len <= 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n\t\t\t\t\t    bytes)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * check if vector was merged with previous\n\t\t\t * drop page reference if needed\n\t\t\t */\n\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n\t\t\t\tput_page(pages[j]);\n\n\t\t\tlen -= bytes;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tbio_for_each_segment_all(bvec, bio, j) {\n\t\tput_page(bvec->bv_page);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}","idx":2181,"name":"bio_map_user_iov","project":"267355323290795","target":"Privacy"}
{"commit_id":"8896999014791","func":"key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}","idx":2228,"name":"lookup_user_key","project":"280854947575495","target":"Privacy"}
{"commit_id":"219955543871180","func":"key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}","idx":2229,"name":"lookup_user_key","project":"280854947575495","target":"Privacy"}
{"commit_id":"254104154321275","func":"void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}","idx":2236,"name":"user_describe","project":"57173822172577","target":"Privacy"}
{"commit_id":"24183400430036","func":"int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}","idx":2237,"name":"user_update","project":"57173822172577","target":"Privacy"}
{"commit_id":"206685830462591","func":"void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}","idx":2238,"name":"user_describe","project":"57173822172577","target":"Privacy"}
{"commit_id":"203099542860181","func":"int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}","idx":2239,"name":"user_update","project":"57173822172577","target":"Privacy"}
{"commit_id":"253289603655264","func":"static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}","idx":2247,"name":"xfrm_user_rcv_msg","project":"221242579779505","target":"Privacy"}
{"commit_id":"195394495322596","func":"static inline unsigned long get_tpuser(void)\n{\n\tunsigned long reg = 0;\n\n\tif (has_tls_reg && !tls_emu)\n\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n\n\treturn reg;\n}","idx":2904,"name":"get_tpuser","project":"279239975647329","target":"Privacy"}
{"commit_id":"152990558496428","func":"int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}","idx":2936,"name":"unshare_userns","project":"226442587178666","target":"Privacy"}
{"commit_id":"29032845681297","func":"int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tint err = -ENOMEM;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (cred) {\n\t\terr = create_user_ns(cred);\n\t\tif (err)\n\t\t\tput_cred(cred);\n\t\telse\n\t\t\t*new_cred = cred;\n\t}\n\n\treturn err;\n}","idx":2937,"name":"unshare_userns","project":"226442587178666","target":"Privacy"}
{"commit_id":"92643035495292","func":"pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}","idx":3161,"name":"pipe_iov_copy_to_user","project":"59224738000128","target":"Privacy"}
{"commit_id":"212075550473917","func":"pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}","idx":3196,"name":"pipe_iov_copy_from_user","project":"156089814684735","target":"Privacy"}
{"commit_id":"12103701763027","func":"static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\t\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}","idx":3233,"name":"snd_ctl_elem_user_put","project":"14468243893180","target":"Privacy"}
{"commit_id":"69214083459582","func":"static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}","idx":3234,"name":"snd_ctl_elem_user_tlv","project":"14468243893180","target":"Privacy"}
{"commit_id":"172361333376888","func":"static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn change;\n}","idx":3235,"name":"snd_ctl_elem_user_put","project":"14468243893180","target":"Privacy"}
{"commit_id":"66808533565539","func":"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}","idx":3237,"name":"snd_ctl_elem_user_get","project":"14468243893180","target":"Privacy"}
{"commit_id":"160521799565998","func":"static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn change;\n}","idx":3238,"name":"snd_ctl_elem_user_tlv","project":"14468243893180","target":"Privacy"}
{"commit_id":"268942618726681","func":"static int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct compat_user *dummy32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t__u32 mask = PSW32_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW32_MASK_RI : 0;\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif ((tmp & ~mask) != PSW32_USER_BITS)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\n\t\t\t\t(regs->psw.mask & PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & mask) << 32;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\tregs->psw.addr = (__u64) tmp & PSW32_ADDR_INSN;\n\t\t\t/* Transfer 31 bit amode bit to psw mask. */\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & PSW32_ADDR_AMODE);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &regs->psw + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writess of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    test_fp_ctl(tmp))\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\t__poke_user_per_compat(child, addr, data);\n\t}\n\n\treturn 0;\n}","idx":3260,"name":"__poke_user_compat","project":"269295033570445","target":"Privacy"}
{"commit_id":"207344688138297","func":"static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\n\t}\n\n\treturn 0;\n}","idx":3261,"name":"__poke_user","project":"269295033570445","target":"Privacy"}
{"commit_id":"229272207959850","func":"static int __poke_user_compat(struct task_struct *child,\n\t\t\t      addr_t addr, addr_t data)\n{\n\tstruct compat_user *dummy32 = NULL;\n\t__u32 tmp = (__u32) data;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy32->regs.acrs) {\n\t\tstruct pt_regs *regs = task_pt_regs(child);\n\t\t/*\n\t\t * psw, gprs, acrs and orig_gpr2 are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.psw.mask) {\n\t\t\t__u32 mask = PSW32_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW32_MASK_RI : 0;\n\t\t\t/* Build a 64 bit psw mask from 31 bit mask. */\n\t\t\tif ((tmp ^ PSW32_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW32_MASK_ASC) == PSW32_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\n\t\t\t\t(regs->psw.mask & PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & mask) << 32;\n\t\t} else if (addr == (addr_t) &dummy32->regs.psw.addr) {\n\t\t\t/* Build a 64 bit psw address from 31 bit address. */\n\t\t\tregs->psw.addr = (__u64) tmp & PSW32_ADDR_INSN;\n\t\t\t/* Transfer 31 bit amode bit to psw mask. */\n\t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_BA) |\n\t\t\t\t(__u64)(tmp & PSW32_ADDR_AMODE);\n\t\t} else {\n\t\t\t/* gpr 0-15 */\n\t\t\t*(__u32*)((addr_t) &regs->psw + addr*2 + 4) = tmp;\n\t\t}\n\t} else if (addr < (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy32->regs.acrs;\n\t\t*(__u32*)((addr_t) &child->thread.acrs + offset) = tmp;\n\n\t} else if (addr == (addr_t) (&dummy32->regs.orig_gpr2)) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n\n\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writess of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure \n\t\t */\n\t\tif (addr == (addr_t) &dummy32->regs.fp_regs.fpc &&\n\t\t    test_fp_ctl(tmp))\n\t\t\treturn -EINVAL;\n\t        offset = addr - (addr_t) &dummy32->regs.fp_regs;\n\t\t*(__u32 *)((addr_t) &child->thread.fp_regs + offset) = tmp;\n\n\t} else if (addr < (addr_t) (&dummy32->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy32->regs.per_info;\n\t\t__poke_user_per_compat(child, addr, data);\n\t}\n\n\treturn 0;\n}","idx":3262,"name":"__poke_user_compat","project":"269295033570445","target":"Privacy"}
{"commit_id":"44663034379581","func":"static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\t/* Invalid addressing mode bits */\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\t/*\n\t\t * Very special case: old & broken 64 bit gdb writing\n\t\t * to acrs[15] with a 64 bit value. Ignore the lower\n\t\t * half of the value and write the upper 32 bit to\n\t\t * acrs[15]. Sick...\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\t/*\n\t\t * orig_gpr2 is stored on the kernel stack\n\t\t */\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\t/*\n\t\t * prevent writes of padding hole between\n\t\t * orig_gpr2 and fp_regs on s390.\n\t\t */\n\t\treturn 0;\n\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\t/*\n\t\t * floating point regs. are stored in the thread structure\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\t/*\n\t\t * Handle access to the per_info structure.\n\t\t */\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\n\t}\n\n\treturn 0;\n}","idx":3263,"name":"__poke_user","project":"269295033570445","target":"Privacy"}
{"commit_id":"221036824720309","func":"int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}","idx":3339,"name":"user_match","project":"51207003488165","target":"Privacy"}
{"commit_id":"64691213886387","func":"static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the\n\t\t * normal stack.\n\t\t */\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\t/*\n\t\t\t * This looks like an signal frame\n\t\t\t */\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}","idx":3577,"name":"perf_callchain_user_64","project":"33688258755519","target":"Privacy"}
{"commit_id":"83027996831677","func":"static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the\n\t\t * normal stack.\n\t\t */\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\t/*\n\t\t\t * This looks like an signal frame\n\t\t\t */\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}","idx":3578,"name":"perf_callchain_user_64","project":"33688258755519","target":"Privacy"}
{"commit_id":"170200687091884","func":"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}","idx":3829,"name":"userfaultfd_register","project":"66191200093922","target":"Privacy"}
{"commit_id":"252890600156186","func":"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}","idx":3830,"name":"userfaultfd_unregister","project":"66191200093922","target":"Privacy"}
{"commit_id":"14973133332178","func":"int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\n\treturn 0;\n}","idx":3873,"name":"ipmi_destroy_user","project":"75877652290683","target":"Privacy"}
{"commit_id":"139106624131012","func":"static void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkfree(user);\n}","idx":3874,"name":"free_user","project":"75877652290683","target":"Privacy"}
{"commit_id":"243462789275204","func":"void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\n\t\t/* Get an arbitrary mm pointer that hasn't been cleaned yet */\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\n\t\t/*\n\t\t * The umap_lock is nested under mmap_sem since it used within\n\t\t * the vma_ops callbacks, so we have to clean the list one mm\n\t\t * at a time to get the lock ordering right. Typically there\n\t\t * will only be one mm, so no big deal.\n\t\t */\n\t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n\t\tup_write(&mm->mmap_sem);\n\t\tmmput(mm);\n\t}\n}","idx":4001,"name":"uverbs_user_mmap_disassociate","project":"26892204013577","target":"Privacy"}
{"commit_id":"109286128127516","func":"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}","idx":4003,"name":"userfaultfd_unregister","project":"117581281607347","target":"Privacy"}
{"commit_id":"211770557078519","func":"static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t/*\n\t\t\t * &ewq->wq may be queued in fork_event, but\n\t\t\t * __remove_wait_queue ignores the head\n\t\t\t * parameter. It would be a problem if it\n\t\t\t * didn't.\n\t\t\t */\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\n\t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n\t\tdown_write(&mm->mmap_sem);\n\t\t/* no task can run (and in turn coredump) yet */\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}","idx":4004,"name":"userfaultfd_event_wait_completion","project":"117581281607347","target":"Privacy"}
{"commit_id":"23026242494767","func":"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If this vma contains ending address, and huge pages\n\t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(!vma_can_userfault(vma));\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}","idx":4005,"name":"userfaultfd_register","project":"117581281607347","target":"Privacy"}
{"commit_id":"106627693223769","func":"static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\t/* len == 0 means wake all */\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\n\tWRITE_ONCE(ctx->released, true);\n\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\n\t/*\n\t * Flush page faults out of all CPUs. NOTE: all page faults\n\t * must be retried without returning VM_FAULT_SIGBUS if\n\t * userfaultfd_ctx_get() succeeds but vma->vma_userfault_ctx\n\t * changes while handle_userfault released the mmap_sem. So\n\t * it's critical that released is set to true (above), before\n\t * taking the mmap_sem for writing.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto skip_mm;\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\nskip_mm:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\t/*\n\t * After no new page faults can wait on this fault_*wqh, flush\n\t * the last page faults that may have been already waiting on\n\t * the fault_*wqh.\n\t */\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\t/* Flush pending events that may still wait on event_wqh */\n\twake_up_all(&ctx->event_wqh);\n\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}","idx":4006,"name":"userfaultfd_release","project":"117581281607347","target":"Privacy"}
{"commit_id":"57715207044159","func":"  def add_user( user, role )\n    check_write_access!\n    unless role.kind_of? Role\n      role = Role.get_by_title(role)\n    end\n\n    if role.global\n      #only nonglobal roles may be set in a project\n      raise SaveError, \"tried to set global role '#{role.title}' for user '#{user}' in package '#{self.name}'\"\n    end\n\n    unless user.kind_of? User\n      user = User.get_by_login(user.to_s)\n    end\n\n    PackageUserRoleRelationship.create(\n                                       :package => self,\n                                       :user => user,\n                                       :role => role )\n  end","idx":4514,"name":"add_user","project":"38458808397357","target":"Privacy"}
{"commit_id":"74686737147429","func":"  def add_user( user, role )\n    check_write_access!\n\n    unless role.kind_of? Role\n      role = Role.get_by_title(role)\n    end\n    if role.global\n      #only nonglobal roles may be set in a project\n      raise SaveError, \"tried to set global role '#{role_title}' for user '#{user}' in project '#{self.name}'\"\n    end\n\n    unless user.kind_of? User\n      user = User.get_by_login(user)\n    end\n\n    logger.debug \"adding user: #{user.login}, #{role.title}\"\n    ProjectUserRoleRelationship.create(\n      :project => self,\n      :user => user,\n      :role => role )\n  end","idx":4523,"name":"add_user","project":"82628720506888","target":"Privacy"}
{"commit_id":"102283711971257","func":"function current_user_get_bug_filter( $p_project_id = null ) {\n\t$f_filter_string = gpc_get_string( 'filter', '' );\n\t$t_filter = '';\n\n\tif( !is_blank( $f_filter_string ) ) {\n\t\tif( is_numeric( $f_filter_string ) ) {\n\t\t\t$t_token = token_get_value( TOKEN_FILTER );\n\t\t\tif( null != $t_token ) {\n\t\t\t\t$t_filter = json_decode( $t_token, true );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_filter = json_decode( $f_filter_string, true );\n\t\t}\n\t\t$t_filter = filter_ensure_valid_filter( $t_filter );\n\t} else if( !filter_is_cookie_valid() ) {\n\t\t$t_filter = filter_get_default();\n\t} else {\n\t\t$t_user_id = auth_get_current_user_id();\n\t\t$t_filter = user_get_bug_filter( $t_user_id, $p_project_id );\n\t}\n\n\treturn $t_filter;\n}","idx":4801,"name":"current_user_get_bug_filter","project":"66042983344585","target":"Privacy"}
{"commit_id":"212695118746822","func":"function current_user_get_bug_filter( $p_project_id = null ) {\n\t$f_filter_string = gpc_get_string( 'filter', '' );\n\t$t_filter = array();\n\n\tif( !is_blank( $f_filter_string ) ) {\n\t\tif( is_numeric( $f_filter_string ) ) {\n\t\t\t$t_token = token_get_value( TOKEN_FILTER );\n\t\t\tif( null != $t_token ) {\n\t\t\t\t$t_filter = json_decode( $t_token, true );\n\t\t\t}\n\t\t} else {\n\t\t\t$t_filter = json_decode( $f_filter_string, true );\n\t\t}\n\t\t$t_filter = filter_ensure_valid_filter( $t_filter );\n\t} else if( !filter_is_cookie_valid() ) {\n\t\t$t_filter = filter_get_default();\n\t} else {\n\t\t$t_user_id = auth_get_current_user_id();\n\t\t$t_filter = user_get_bug_filter( $t_user_id, $p_project_id );\n\t}\n\n\treturn $t_filter;\n}","idx":4802,"name":"current_user_get_bug_filter","project":"66042983344585","target":"Privacy"}
{"commit_id":"168552832489514","func":"    public function storeUserCredentials()\n    {\n    }","idx":4948,"name":"storeUserCredentials","project":"17603307311772","target":"Privacy"}
{"commit_id":"186876750264586","func":"    public function storeUserCredentials()\n    {\n        global $cfg;\n\n        $this->createBlowfishIV();\n\n        // Name and password cookies need to be refreshed each time\n        // Duration = one month for username\n        $GLOBALS['PMA_Config']->setCookie(\n            'pmaUser-' . $GLOBALS['server'],\n            $this->blowfishEncrypt(\n                $cfg['Server']['user'],\n                $this->_getBlowfishSecret()\n            )\n        );\n\n        // Duration = as configured\n        $GLOBALS['PMA_Config']->setCookie(\n            'pmaPass-' . $GLOBALS['server'],\n            $this->blowfishEncrypt(\n                ! empty($cfg['Server']['password'])\n                ? $cfg['Server']['password'] : \"\\xff(blank)\",\n                $this->_getBlowfishSecret()\n            ),\n            null,\n            $GLOBALS['cfg']['LoginCookieStore']\n        );\n\n        // Set server cookies if required (once per session) and, in this case,\n        // force reload to ensure the client accepts cookies\n        if (! $GLOBALS['from_cookie']) {\n            if ($GLOBALS['cfg']['AllowArbitraryServer']) {\n                if (! empty($GLOBALS['pma_auth_server'])) {\n                    // Duration = one month for servername\n                    $GLOBALS['PMA_Config']->setCookie(\n                        'pmaServer-' . $GLOBALS['server'],\n                        $cfg['Server']['host']\n                    );\n                } else {\n                    // Delete servername cookie\n                    $GLOBALS['PMA_Config']->removeCookie(\n                        'pmaServer-' . $GLOBALS['server']\n                    );\n                }\n            }\n\n            // URL where to go:\n            $redirect_url = $cfg['PmaAbsoluteUri'] . 'index.php';\n\n            // any parameters to pass?\n            $url_params = array();\n            if (strlen($GLOBALS['db'])) {\n                $url_params['db'] = $GLOBALS['db'];\n            }\n            if (strlen($GLOBALS['table'])) {\n                $url_params['table'] = $GLOBALS['table'];\n            }\n            // any target to pass?\n            if (! empty($GLOBALS['target'])\n                && $GLOBALS['target'] != 'index.php'\n            ) {\n                $url_params['target'] = $GLOBALS['target'];\n            }\n\n            /**\n             * Clear user cache.\n             */\n            PMA_Util::clearUserCache();\n\n            PMA_Response::getInstance()->disable();\n\n            PMA_sendHeaderLocation(\n                $redirect_url . PMA_URL_getCommon($url_params, '&'),\n                true\n            );\n            if (! defined('TESTSUITE')) {\n                exit;\n            } else {\n                return false;\n            }\n        } // end if\n\n        return true;\n\n    }","idx":4949,"name":"storeUserCredentials","project":"88947294232945","target":"Privacy"}
{"commit_id":"238924082212983","func":"    public function authSetUser()\n    {\n        global $cfg;\n\n        // Ensures valid authentication mode, 'only_db', bookmark database and\n        // table names and relation table name are used\n        if ($cfg['Server']['user'] != $GLOBALS['PHP_AUTH_USER']) {\n            foreach ($cfg['Servers'] as $idx => $current) {\n                if ($current['host'] == $cfg['Server']['host']\n                    && $current['port'] == $cfg['Server']['port']\n                    && $current['socket'] == $cfg['Server']['socket']\n                    && $current['ssl'] == $cfg['Server']['ssl']\n                    && $current['connect_type'] == $cfg['Server']['connect_type']\n                    && $current['user'] == $GLOBALS['PHP_AUTH_USER']\n                ) {\n                    $GLOBALS['server'] = $idx;\n                    $cfg['Server']     = $current;\n                    break;\n                }\n            } // end foreach\n        } // end if\n\n        if ($GLOBALS['cfg']['AllowArbitraryServer']\n            && ! empty($GLOBALS['pma_auth_server'])\n        ) {\n            /* Allow to specify 'host port' */\n            $parts = explode(' ', $GLOBALS['pma_auth_server']);\n            if (count($parts) == 2) {\n                $tmp_host = $parts[0];\n                $tmp_port = $parts[1];\n            } else {\n                $tmp_host = $GLOBALS['pma_auth_server'];\n                $tmp_port = '';\n            }\n            if ($cfg['Server']['host'] != $GLOBALS['pma_auth_server']) {\n                $cfg['Server']['host'] = $tmp_host;\n                if (! empty($tmp_port)) {\n                    $cfg['Server']['port'] = $tmp_port;\n                }\n            }\n            unset($tmp_host, $tmp_port, $parts);\n        }\n        $cfg['Server']['user']     = $GLOBALS['PHP_AUTH_USER'];\n        $cfg['Server']['password'] = $GLOBALS['PHP_AUTH_PW'];\n\n        // Avoid showing the password in phpinfo()'s output\n        unset($GLOBALS['PHP_AUTH_PW']);\n        unset($_SERVER['PHP_AUTH_PW']);\n\n        $_SESSION['last_access_time'] = time();\n    }","idx":4950,"name":"authSetUser","project":"88947294232945","target":"Privacy"}
{"commit_id":"17806602661654","func":"    public function testAuthCheckDecryptUser()\n    {\n        $GLOBALS['cfg']['Server']['auth_swekey_config'] = 'testConfigSwekey';\n        $GLOBALS['server'] = 1;\n        $_REQUEST['old_usr'] = '';\n        $_REQUEST['pma_username'] = '';\n        $_COOKIE['pmaServer-1'] = 'pmaServ1';\n        $_COOKIE['pmaUser-1'] = 'pmaUser1';\n        $_COOKIE['pma_iv-1'] = base64_encode('testiv09testiv09');\n        $GLOBALS['cfg']['blowfish_secret'] = 'secret';\n        $_SESSION['last_access_time'] = '';\n        $_SESSION['last_valid_captcha'] = true;\n\n        // mock for blowfish function\n        $this->object = $this->getMockBuilder('AuthenticationCookie')\n            ->disableOriginalConstructor()\n            ->setMethods(array('cookieDecrypt'))\n            ->getMock();\n\n        $this->object->expects($this->once())\n            ->method('cookieDecrypt')\n            ->will($this->returnValue('testBF'));\n\n        $this->assertFalse(\n            $this->object->authCheck()\n        );\n\n        $this->assertEquals(\n            'testBF',\n            $GLOBALS['PHP_AUTH_USER']\n        );\n    }","idx":4956,"name":"testAuthCheckDecryptUser","project":"120507782096657","target":"Privacy"}
{"commit_id":"84951330622246","func":"    public function testAuthCheckDecryptUser()\n    {\n        $GLOBALS['cfg']['Server']['auth_swekey_config'] = 'testConfigSwekey';\n        $GLOBALS['server'] = 1;\n        $_REQUEST['old_usr'] = '';\n        $_REQUEST['pma_username'] = '';\n        $_COOKIE['pmaServer-1'] = 'pmaServ1';\n        $_COOKIE['pmaUser-1'] = 'pmaUser1';\n        $_COOKIE['pma_iv-1'] = base64_encode('testiv09testiv09');\n        $GLOBALS['cfg']['blowfish_secret'] = 'secret';\n        $_SESSION['last_access_time'] = '';\n        $GLOBALS['cfg']['CaptchaLoginPrivateKey'] = '';\n        $GLOBALS['cfg']['CaptchaLoginPublicKey'] = '';\n\n        // mock for blowfish function\n        $this->object = $this->getMockBuilder('AuthenticationCookie')\n            ->disableOriginalConstructor()\n            ->setMethods(array('cookieDecrypt'))\n            ->getMock();\n\n        $this->object->expects($this->once())\n            ->method('cookieDecrypt')\n            ->will($this->returnValue('testBF'));\n\n        $this->assertFalse(\n            $this->object->authCheck()\n        );\n\n        $this->assertEquals(\n            'testBF',\n            $GLOBALS['PHP_AUTH_USER']\n        );\n    }","idx":4961,"name":"testAuthCheckDecryptUser","project":"120507782096657","target":"Privacy"}
{"commit_id":"263347038109609","func":"    def test_quotas_update_as_user(self):\n        body = {'quota_class_set': {'instances': 50, 'cores': 50,\n                                    'ram': 51200, 'volumes': 10,\n                                    'gigabytes': 1000, 'floating_ips': 10,\n                                    'metadata_items': 128, 'injected_files': 5,\n                                    'injected_file_content_bytes': 10240}}\n\n        req = fakes.HTTPRequest.blank(\n            '/v2/fake4/os-quota-class-sets/test_class')\n        self.assertRaises(webob.exc.HTTPForbidden, self.controller.update,\n                          req, 'test_class', body)","idx":5209,"name":"test_quotas_update_as_user","project":"110167319619007","target":"Privacy"}
{"commit_id":"143942036299893","func":"    def test_quotas_update_as_user(self):\n        body = {'quota_class_set': {'instances': 50, 'cores': 50,\n                                    'ram': 51200, 'volumes': 10,\n                                    'gigabytes': 1000, 'floating_ips': 10,\n                                    'metadata_items': 128, 'injected_files': 5,\n                                    'injected_file_content_bytes': 10240,\n                                    'security_groups': 10,\n                                    'security_group_rules': 20,\n                                    }}\n\n        req = fakes.HTTPRequest.blank(\n            '/v2/fake4/os-quota-class-sets/test_class')\n        self.assertRaises(webob.exc.HTTPForbidden, self.controller.update,\n                          req, 'test_class', body)","idx":5217,"name":"test_quotas_update_as_user","project":"110167319619007","target":"Privacy"}
{"commit_id":"221552900086205","func":"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}","idx":89,"name":"spnego_gss_get_mic_iov","project":"180227160492611","target":"True"}
{"commit_id":"239619458044053","func":"spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}","idx":90,"name":"spnego_gss_unwrap_iov","project":"180227160492611","target":"True"}
{"commit_id":"240344679431083","func":"init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t */\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}","idx":91,"name":"init_ctx_new","project":"180227160492611","target":"True"}
{"commit_id":"75057584436435","func":"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}","idx":92,"name":"spnego_gss_wrap_iov_length","project":"180227160492611","target":"True"}
{"commit_id":"201862645003136","func":"create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}","idx":93,"name":"create_spnego_ctx","project":"180227160492611","target":"True"}
{"commit_id":"113572752476976","func":"spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}","idx":94,"name":"spnego_gss_unwrap","project":"180227160492611","target":"True"}
{"commit_id":"115818459839016","func":"spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}","idx":95,"name":"spnego_gss_get_mic","project":"180227160492611","target":"True"}
{"commit_id":"80671953790826","func":"acc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &der_mechTypes,\n\t\t\t       &mechTypes, &req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n\t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n\t\tassert(mech_wanted != GSS_C_NO_OID);\n\t} else\n\t\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc->mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc->internal_mech = mech_wanted;\n\tsc->DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc->mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mechTypes);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&tmpmin, &der_mechTypes);\n\n\treturn ret;\n}","idx":96,"name":"acc_ctx_new","project":"180227160492611","target":"True"}
{"commit_id":"214721738652588","func":"spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}","idx":97,"name":"spnego_gss_complete_auth_token","project":"180227160492611","target":"True"}
{"commit_id":"16520758101735","func":"spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}","idx":98,"name":"spnego_gss_context_time","project":"180227160492611","target":"True"}
{"commit_id":"159215290513350","func":"static int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n    struct gss_config iakerb_mechanism = krb5_mechanism;\n\n    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n    iakerb_mechanism.gssspi_acquire_cred_with_password\n                                    = iakerb_gss_acquire_cred_with_password;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}","idx":128,"name":"gss_iakerbmechglue_init","project":"227904753814221","target":"True"}
{"commit_id":"148152904579206","func":"iakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = NULL;\n            iakerb_release_context(ctx);\n        }\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}","idx":129,"name":"iakerb_gss_accept_sec_context","project":"101493015699813","target":"True"}
{"commit_id":"268041287962518","func":"iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}","idx":130,"name":"iakerb_alloc_context","project":"101493015699813","target":"True"}
{"commit_id":"174338407822691","func":"iakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = GSS_C_NO_CONTEXT;\n            iakerb_release_context(ctx);\n        }\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}","idx":131,"name":"iakerb_gss_init_sec_context","project":"101493015699813","target":"True"}
{"commit_id":"257437786881384","func":"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}","idx":132,"name":"iakerb_gss_delete_sec_context","project":"101493015699813","target":"True"}
{"commit_id":"30593300715583","func":"build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  /* initial guess at needed space */\n    char *component = NULL;\n\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    /* take ownership */\n        data = NULL; /* take ownership */\n    }\n\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n\n    return retval;\n}","idx":155,"name":"build_principal_va","project":"218972346495359","target":"True"}
{"commit_id":"262831210762726","func":"iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}","idx":157,"name":"iakerb_gss_export_sec_context","project":"13018839216854","target":"True"}
{"commit_id":"63129196810772","func":"bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}","idx":160,"name":"xdr_nullstring","project":"272118200307017","target":"True"}
{"commit_id":"404873218874","func":"kadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_int32                  now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(kdb, 0, sizeof(*kdb));\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = now + polent.pw_max_life;\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    if ((ret = kadm5_copy_principal(handle->context,\n                                    entry->principal, &(kdb->princ))))\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}","idx":162,"name":"kadm5_create_principal_3","project":"75712459139979","target":"True"}
{"commit_id":"257984483180346","func":"kadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += pol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}","idx":163,"name":"kadm5_modify_principal","project":"75712459139979","target":"True"}
{"commit_id":"77135963843697","func":"set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":166,"name":"set_string_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"109860157547749","func":"setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":167,"name":"setv4key_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"273088814355404","func":"delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":168,"name":"delete_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"1440478050381","func":"rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg1,\n        *prime_arg2;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    size_t                      tlen1, tlen2, clen, slen;\n    char                        *tdots1, *tdots2, *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||\n        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    tlen1 = strlen(prime_arg1);\n    trunc_name(&tlen1, &tdots1);\n    tlen2 = strlen(prime_arg2);\n    trunc_name(&tlen2, &tdots2);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n\n    ret.code = KADM5_OK;\n    if (! CHANGEPW_SERVICE(rqstp)) {\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_DELETE, arg->src, NULL))\n            ret.code = KADM5_AUTH_DELETE;\n        /* any restrictions at all on the ADD kills the RENAME */\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_ADD, arg->dest, &rp) || rp) {\n            if (ret.code == KADM5_AUTH_DELETE)\n                ret.code = KADM5_AUTH_INSUFFICIENT;\n            else\n                ret.code = KADM5_AUTH_ADD;\n        }\n    } else\n        ret.code = KADM5_AUTH_INSUFFICIENT;\n    if (ret.code != KADM5_OK) {\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Unauthorized request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n    } else {\n        ret.code = kadm5_rename_principal((void *)handle, arg->src,\n                                          arg->dest);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, %s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         errmsg ? errmsg : _(\"success\"),\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    free(prime_arg1);\n    free(prime_arg2);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":169,"name":"rename_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"263949704581374","func":"purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_purgekeys\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":170,"name":"purgekeys_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"166541441086389","func":"get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)\n{\n    static gpol_ret             ret;\n    kadm5_ret_t         ret2;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_principal_ent_rec     caller_ent;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_gpol_ret,  &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_policy\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    ret.code = KADM5_AUTH_GET;\n    if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_INQUIRE, NULL, NULL))\n        ret.code = KADM5_OK;\n    else {\n        ret.code = kadm5_get_principal(handle->lhandle,\n                                       handle->current_caller,\n                                       &caller_ent,\n                                       KADM5_PRINCIPAL_NORMAL_MASK);\n        if (ret.code == KADM5_OK) {\n            if (caller_ent.aux_attributes & KADM5_POLICY &&\n                strcmp(caller_ent.policy, arg->name) == 0) {\n                ret.code = KADM5_OK;\n            } else ret.code = KADM5_AUTH_GET;\n            ret2 = kadm5_free_principal_ent(handle->lhandle,\n                                            &caller_ent);\n            ret.code = ret.code ? ret.code : ret2;\n        }\n    }\n\n    if (ret.code == KADM5_OK) {\n        ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname,\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n\n}","idx":171,"name":"get_policy_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"7294899181377","func":"chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               arg->keepold,\n                                               arg->n_ks_tuple,\n                                               arg->ks_tuple,\n                                               &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal_3((void *)handle, arg->princ,\n                                             arg->keepold,\n                                             arg->n_ks_tuple,\n                                             arg->ks_tuple,\n                                             &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":172,"name":"chrand_principal3_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"250367950039649","func":"delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":173,"name":"delete_policy_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"251148067298651","func":"create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":174,"name":"create_principal3_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"268300896277644","func":"setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":175,"name":"setkey_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"190556814365607","func":"chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":176,"name":"chpass_principal3_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"176235238014631","func":"generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n\n    free_server_handle(handle);\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    /* okay to cast lengths to int because trunc_name limits max value */\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    return(&ret);\n}","idx":177,"name":"init_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"24237645024794","func":"modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":178,"name":"modify_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"53718409517367","func":"create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":179,"name":"create_policy_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"122527135018825","func":"get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprinc_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_get_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":180,"name":"get_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"237449909000223","func":"setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":181,"name":"setkey_principal3_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"55962315347416","func":"get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":182,"name":"get_strings_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"152345936286424","func":"chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":183,"name":"chpass_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"168827921804223","func":"create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":184,"name":"create_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"161497102655066","func":"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n\n    xdr_free(xdr_getprivs_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":185,"name":"get_privs_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"243031916068247","func":"modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":186,"name":"modify_policy_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"162761289313989","func":"chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":187,"name":"chrand_principal_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"59443563017450","func":"get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gpols_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":188,"name":"get_pols_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"185506408107602","func":"get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","idx":189,"name":"get_princs_2_svc","project":"65452599034640","target":"True"}
{"commit_id":"210631130841592","func":"validate_as_request(kdc_realm_t *kdc_active_realm,\n                    register krb5_kdc_req *request, krb5_db_entry client,\n                    krb5_db_entry server, krb5_timestamp kdc_time,\n                    const char **status, krb5_pa_data ***e_data)\n{\n    int errcode;\n    krb5_error_code ret;\n\n    /*\n     * If an option is set that is only allowed in TGS requests, complain.\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KDC_ERR_BADOPTION;\n    }\n\n    /* The client must not be expired */\n    if (client.expiration && client.expiration < kdc_time) {\n        *status = \"CLIENT EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_NAME_EXP);\n    }\n\n    /* The client's password must not be expired, unless the server is\n       a KRB5_KDC_PWCHANGE_SERVICE. */\n    if (client.pw_expiration && client.pw_expiration < kdc_time &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"CLIENT KEY EXPIRED\";\n        if (vague_errors)\n            return(KRB_ERR_GENERIC);\n        else\n            return(KDC_ERR_KEY_EXP);\n    }\n\n    /* The server must not be expired */\n    if (server.expiration && server.expiration < kdc_time) {\n        *status = \"SERVICE EXPIRED\";\n        return(KDC_ERR_SERVICE_EXP);\n    }\n\n    /*\n     * If the client requires password changing, then only allow the\n     * pwchange service.\n     */\n    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&\n        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {\n        *status = \"REQUIRED PWCHANGE\";\n        return(KDC_ERR_KEY_EXP);\n    }\n\n    /* Client and server must allow postdating tickets */\n    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||\n         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {\n        *status = \"POSTDATE NOT ALLOWED\";\n        return(KDC_ERR_CANNOT_POSTDATE);\n    }\n\n    /*\n     * A Windows KDC will return KDC_ERR_PREAUTH_REQUIRED instead of\n     * KDC_ERR_POLICY in the following case:\n     *\n     *   - KDC_OPT_FORWARDABLE is set in KDCOptions but local\n     *     policy has KRB5_KDB_DISALLOW_FORWARDABLE set for the\n     *     client, and;\n     *   - KRB5_KDB_REQUIRES_PRE_AUTH is set for the client but\n     *     preauthentication data is absent in the request.\n     *\n     * Hence, this check most be done after the check for preauth\n     * data, and is now performed by validate_forwardable() (the\n     * contents of which were previously below).\n     */\n\n    /* Client and server must allow proxiable tickets */\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&\n        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||\n         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {\n        *status = \"PROXIABLE NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Check to see if client is locked out */\n    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"CLIENT LOCKED OUT\";\n        return(KDC_ERR_CLIENT_REVOKED);\n    }\n\n    /* Check to see if server is locked out */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {\n        *status = \"SERVICE LOCKED OUT\";\n        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n    }\n\n    /* Check to see if server is allowed to be a service */\n    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {\n        *status = \"SERVICE NOT ALLOWED\";\n        return(KDC_ERR_MUST_USE_USER2USER);\n    }\n\n    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n        *status = \"ANONYMOUS NOT ALLOWED\";\n        return(KDC_ERR_POLICY);\n    }\n\n    /* Perform KDB module policy checks. */\n    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,\n                                  kdc_time, status, e_data);\n    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)\n        return errcode_to_protocol(ret);\n\n    /* Check against local policy. */\n    errcode = against_local_policy_as(request, client, server,\n                                      kdc_time, status, e_data);\n    if (errcode)\n        return errcode;\n\n    return 0;\n}","idx":215,"name":"validate_as_request","project":"9681320992537","target":"True"}
{"commit_id":"20166960988203","func":"finish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n{\n    krb5_key_data *server_key;\n    krb5_keyblock *as_encrypting_key = NULL;\n    krb5_data *response = NULL;\n    const char *emsg = 0;\n    int did_log = 0;\n    loop_respond_fn oldrespond;\n    void *oldarg;\n    kdc_realm_t *kdc_active_realm = state->active_realm;\n    krb5_audit_state *au_state = state->au_state;\n\n    assert(state);\n    oldrespond = state->respond;\n    oldarg = state->arg;\n\n    if (errcode)\n        goto egress;\n\n    au_state->stage = ENCR_REP;\n\n    if ((errcode = validate_forwardable(state->request, *state->client,\n                                        *state->server, state->kdc_time,\n                                        &state->status))) {\n        errcode += ERROR_TABLE_BASE_krb5;\n        goto egress;\n    }\n\n    errcode = check_indicators(kdc_context, state->server,\n                               state->auth_indicators);\n    if (errcode) {\n        state->status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part2 = &state->enc_tkt_reply;\n\n    /*\n     * Find the server key\n     */\n    if ((errcode = krb5_dbe_find_enctype(kdc_context, state->server,\n                                         -1, /* ignore keytype   */\n                                         -1, /* Ignore salttype  */\n                                         0,  /* Get highest kvno */\n                                         &server_key))) {\n        state->status = \"FINDING_SERVER_KEY\";\n        goto egress;\n    }\n\n    /*\n     * Convert server->key into a real key\n     * (it may be encrypted in the database)\n     *\n     *  server_keyblock is later used to generate auth data signatures\n     */\n    if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                             server_key,\n                                             &state->server_keyblock,\n                                             NULL))) {\n        state->status = \"DECRYPT_SERVER_KEY\";\n        goto egress;\n    }\n\n    /* Start assembling the response */\n    state->reply.msg_type = KRB5_AS_REP;\n    state->reply.client = state->enc_tkt_reply.client; /* post canonization */\n    state->reply.ticket = &state->ticket_reply;\n    state->reply_encpart.session = &state->session_key;\n    if ((errcode = fetch_last_req_info(state->client,\n                                       &state->reply_encpart.last_req))) {\n        state->status = \"FETCH_LAST_REQ\";\n        goto egress;\n    }\n    state->reply_encpart.nonce = state->request->nonce;\n    state->reply_encpart.key_exp = get_key_exp(state->client);\n    state->reply_encpart.flags = state->enc_tkt_reply.flags;\n    state->reply_encpart.server = state->ticket_reply.server;\n\n    /* copy the time fields EXCEPT for authtime; it's location\n     *  is used for ktime\n     */\n    state->reply_encpart.times = state->enc_tkt_reply.times;\n    state->reply_encpart.times.authtime = state->authtime = state->kdc_time;\n\n    state->reply_encpart.caddrs = state->enc_tkt_reply.caddrs;\n    state->reply_encpart.enc_padata = NULL;\n\n    /* Fetch the padata info to be returned (do this before\n     *  authdata to handle possible replacement of reply key\n     */\n    errcode = return_padata(kdc_context, &state->rock, state->req_pkt,\n                            state->request, &state->reply,\n                            &state->client_keyblock, &state->pa_context);\n    if (errcode) {\n        state->status = \"KDC_RETURN_PADATA\";\n        goto egress;\n    }\n\n    /* If we didn't find a client long-term key and no preauth mechanism\n     * replaced the reply key, error out now. */\n    if (state->client_keyblock.enctype == ENCTYPE_NULL) {\n        state->status = \"CANT_FIND_CLIENT_KEY\";\n        errcode = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto egress;\n    }\n\n    errcode = handle_authdata(kdc_context,\n                              state->c_flags,\n                              state->client,\n                              state->server,\n                              NULL,\n                              state->local_tgt,\n                              &state->client_keyblock,\n                              &state->server_keyblock,\n                              NULL,\n                              state->req_pkt,\n                              state->request,\n                              NULL, /* for_user_princ */\n                              NULL, /* enc_tkt_request */\n                              state->auth_indicators,\n                              &state->enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"AS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        state->status = \"HANDLE_AUTHDATA\";\n        goto egress;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &state->server_keyblock,\n                                    &state->ticket_reply);\n    if (errcode) {\n        state->status = \"ENCRYPT_TICKET\";\n        goto egress;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &state->ticket_reply,\n                              &au_state->tkt_out_id);\n    if (errcode) {\n        state->status = \"GENERATE_TICKET_ID\";\n        goto egress;\n    }\n\n    state->ticket_reply.enc_part.kvno = server_key->key_data_kvno;\n    errcode = kdc_fast_response_handle_padata(state->rstate,\n                                              state->request,\n                                              &state->reply,\n                                              state->client_keyblock.enctype);\n    if (errcode) {\n        state->status = \"MAKE_FAST_RESPONSE\";\n        goto egress;\n    }\n\n    /* now encode/encrypt the response */\n\n    state->reply.enc_part.enctype = state->client_keyblock.enctype;\n\n    errcode = kdc_fast_handle_reply_key(state->rstate, &state->client_keyblock,\n                                        &as_encrypting_key);\n    if (errcode) {\n        state->status = \"MAKE_FAST_REPLY_KEY\";\n        goto egress;\n    }\n    errcode = return_enc_padata(kdc_context, state->req_pkt, state->request,\n                                as_encrypting_key, state->server,\n                                &state->reply_encpart, FALSE);\n    if (errcode) {\n        state->status = \"KDC_RETURN_ENC_PADATA\";\n        goto egress;\n    }\n\n    if (kdc_fast_hide_client(state->rstate))\n        state->reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_AS_REP,\n                                  &state->reply_encpart, 0,\n                                  as_encrypting_key,\n                                  &state->reply, &response);\n    if (state->client_key != NULL)\n        state->reply.enc_part.kvno = state->client_key->key_data_kvno;\n    if (errcode) {\n        state->status = \"ENCODE_KDC_REP\";\n        goto egress;\n    }\n\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(state->reply.enc_part.ciphertext.data, 0,\n           state->reply.enc_part.ciphertext.length);\n    free(state->reply.enc_part.ciphertext.data);\n\n    log_as_req(kdc_context, state->local_addr, state->remote_addr,\n               state->request, &state->reply, state->client, state->cname,\n               state->server, state->sname, state->authtime, 0, 0, 0);\n    did_log = 1;\n\negress:\n    if (errcode != 0)\n        assert (state->status != 0);\n\n    au_state->status = state->status;\n    au_state->reply = &state->reply;\n    kau_as_req(kdc_context,\n              (errcode || state->preauth_err) ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    free_padata_context(kdc_context, state->pa_context);\n    if (as_encrypting_key)\n        krb5_free_keyblock(kdc_context, as_encrypting_key);\n    if (errcode)\n        emsg = krb5_get_error_message(kdc_context, errcode);\n\n    if (state->status) {\n        log_as_req(kdc_context, state->local_addr, state->remote_addr,\n                   state->request, &state->reply, state->client,\n                   state->cname, state->server, state->sname, state->authtime,\n                   state->status, errcode, emsg);\n        did_log = 1;\n    }\n    if (errcode) {\n        if (state->status == 0) {\n            state->status = emsg;\n        }\n        if (errcode != KRB5KDC_ERR_DISCARD) {\n            errcode -= ERROR_TABLE_BASE_krb5;\n            if (errcode < 0 || errcode > KRB_ERR_MAX)\n                errcode = KRB_ERR_GENERIC;\n\n            errcode = prepare_error_as(state->rstate, state->request,\n                                       state->local_tgt, errcode,\n                                       state->e_data, state->typed_e_data,\n                                       ((state->client != NULL) ?\n                                        state->client->princ : NULL),\n                                       &response, state->status);\n            state->status = 0;\n        }\n    }\n\n    if (emsg)\n        krb5_free_error_message(kdc_context, emsg);\n    if (state->enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context,\n                           state->enc_tkt_reply.authorization_data);\n    if (state->server_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->server_keyblock);\n    if (state->client_keyblock.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->client_keyblock);\n    if (state->reply.padata != NULL)\n        krb5_free_pa_data(kdc_context, state->reply.padata);\n    if (state->reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, state->reply_encpart.enc_padata);\n\n    if (state->cname != NULL)\n        free(state->cname);\n    if (state->sname != NULL)\n        free(state->sname);\n    krb5_db_free_principal(kdc_context, state->client);\n    krb5_db_free_principal(kdc_context, state->server);\n    krb5_db_free_principal(kdc_context, state->local_tgt_storage);\n    if (state->session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &state->session_key);\n    if (state->ticket_reply.enc_part.ciphertext.data != NULL) {\n        memset(state->ticket_reply.enc_part.ciphertext.data , 0,\n               state->ticket_reply.enc_part.ciphertext.length);\n        free(state->ticket_reply.enc_part.ciphertext.data);\n    }\n\n    krb5_free_pa_data(kdc_context, state->e_data);\n    krb5_free_data(kdc_context, state->inner_body);\n    kdc_free_rstate(state->rstate);\n    krb5_free_kdc_req(kdc_context, state->request);\n    k5_free_data_ptr_list(state->auth_indicators);\n    assert(did_log != 0);\n\n    free(state);\n    (*oldrespond)(oldarg, errcode, response);\n}","idx":217,"name":"finish_process_as_req","project":"17097258194479","target":"True"}
{"commit_id":"89611665598320","func":"process_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL) {\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        if (is_referral) {\n            /* The requesting server appears to no longer exist, and we found\n             * a referral instead.  Treat this as a server lookup failure. */\n            errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n            status = \"LOOKING_UP_SERVER\";\n            goto cleanup;\n        }\n    }\n\n    /* Deal with user-to-user and constrained delegation */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, request->second_ticket[st_idx],\n                                  &au_state->evid_tkt_id);\n        if (retval) {\n            status = \"GENERATE_TICKET_ID\";\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract auth indicators from the subject ticket, except for S4U2Proxy\n     * requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n    }\n\n    errcode = check_indicators(kdc_context, server, auth_indicators);\n    if (errcode) {\n        status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n        goto cleanup;\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = OPTS2FLAGS(request->kdc_options);\n    enc_tkt_reply.flags |= COPY_TKT_FLAGS(header_enc_tkt->flags);\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /* Indicate support for encrypted padata (RFC 6806). */\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    /* We don't currently handle issuing anonymous tickets based on\n     * non-anonymous ones, so just ignore the option. */\n    if (isflagset(request->kdc_options, KDC_OPT_REQUEST_ANONYMOUS) &&\n        !isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        clear(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, header_server);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              header_server, local_tgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              header_key,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              auth_indicators,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            au_state->status = status;\n            kau_u2u(kdc_context, FALSE, au_state);\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"ENCRYPT_TICKET\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"MAKE_S4U2SELF_PADATA\";\n            au_state->status = status;\n        }\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"MAKE_FAST_RESPONSE\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"MAKE_FAST_REPLY_KEY\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode) {\n        status = \"GENERATE_TICKET_ID\";\n        goto cleanup;\n    }\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n\n    return retval;\n}","idx":219,"name":"process_tgs_req","project":"148064544610761","target":"True"}
{"commit_id":"250681328513023","func":"gss_accept_sec_context (minor_status,\n                        context_handle,\n                        verifier_cred_handle,\n                        input_token_buffer,\n                        input_chan_bindings,\n                        src_name,\n                        mech_type,\n                        output_token,\n                        ret_flags,\n                        time_rec,\n                        d_cred)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n\n{\n    OM_uint32\t\tstatus, temp_status, temp_minor_status;\n    OM_uint32\t\ttemp_ret_flags = 0;\n    gss_union_ctx_id_t\tunion_ctx_id = NULL;\n    gss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\n    gss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\n    gss_name_t\t\tinternal_name = GSS_C_NO_NAME;\n    gss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\n    gss_OID_desc\ttoken_mech_type_desc;\n    gss_OID\t\ttoken_mech_type = &token_mech_type_desc;\n    gss_OID\t\tactual_mech = GSS_C_NO_OID;\n    gss_OID\t\tselected_mech = GSS_C_NO_OID;\n    gss_OID\t\tpublic_mech;\n    gss_mechanism\tmech = NULL;\n    gss_union_cred_t\tuc;\n    int\t\t\ti;\n\n    status = val_acc_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  verifier_cred_handle,\n\t\t\t\t  input_token_buffer,\n\t\t\t\t  input_chan_bindings,\n\t\t\t\t  src_name,\n\t\t\t\t  mech_type,\n\t\t\t\t  output_token,\n\t\t\t\t  ret_flags,\n\t\t\t\t  time_rec,\n\t\t\t\t  d_cred);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\n\tif (input_token_buffer == GSS_C_NO_BUFFER)\n\t    return (GSS_S_CALL_INACCESSIBLE_READ);\n\n\t/* Get the token mech type */\n\tstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\n\tif (status)\n\t    return status;\n\n\t/*\n\t * An interposer calling back into the mechglue can't pass in a special\n\t * mech, so we have to recognize it using verifier_cred_handle.  Use\n\t * the mechanism for which we have matching creds, if available.\n\t */\n\tif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\t    uc = (gss_union_cred_t)verifier_cred_handle;\n\t    for (i = 0; i < uc->count; i++) {\n\t\tpublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\n\t\tif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\n\t\t    selected_mech = &uc->mechs_array[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\tif (selected_mech == GSS_C_NO_OID) {\n\t    status = gssint_select_mech_type(minor_status, token_mech_type,\n\t\t\t\t\t     &selected_mech);\n\t    if (status)\n\t\treturn status;\n\t}\n\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tselected_mech = union_ctx_id->mech_type;\n    }\n\n    /* Now create a new context if we didn't get one. */\n    if (*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (!union_ctx_id)\n\t    return (GSS_S_FAILURE);\n\n\tunion_ctx_id->loopback = union_ctx_id;\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n\tstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t      &union_ctx_id->mech_type);\n\tif (status != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    return (status);\n\t}\n\n\t/* set the new context handle to caller's data */\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     */\n    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\tinput_cred_handle =\n\t    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\n\t\t\t\t      selected_mech);\n\tif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\n\t    /* verifier credential specified but no acceptor credential found */\n\t    status = GSS_S_NO_CRED;\n\t    goto error_out;\n\t}\n    } else if (!allow_mech_by_default(selected_mech)) {\n\tstatus = GSS_S_NO_CRED;\n\tgoto error_out;\n    }\n\n    /*\n     * now select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech && mech->gss_accept_sec_context) {\n\n\t    status = mech->gss_accept_sec_context(minor_status,\n\t\t\t\t\t\t  &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t\t  input_cred_handle,\n\t\t\t\t\t\t  input_token_buffer,\n\t\t\t\t\t\t  input_chan_bindings,\n\t\t\t\t\t\t  src_name ? &internal_name : NULL,\n\t\t\t\t\t\t  &actual_mech,\n\t\t\t\t\t\t  output_token,\n\t\t\t\t\t\t  &temp_ret_flags,\n\t\t\t\t\t\t  time_rec,\n\t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n\n\t    /* If there's more work to do, keep going... */\n\t    if (status == GSS_S_CONTINUE_NEEDED)\n\t\treturn GSS_S_CONTINUE_NEEDED;\n\n\t    /* if the call failed, return with failure */\n\t    if (status != GSS_S_COMPLETE) {\n\t\tmap_error(minor_status, mech);\n\t\tgoto error_out;\n\t    }\n\n\t    /*\n\t     * if src_name is non-NULL,\n\t     * convert internal_name into a union name equivalent\n\t     * First call the mechanism specific display_name()\n\t     * then call gss_import_name() to create\n\t     * the union name struct cast to src_name\n\t     */\n\t    if (src_name != NULL) {\n\t\tif (internal_name != GSS_C_NO_NAME) {\n\t\t    /* consumes internal_name regardless of success */\n\t\t    temp_status = gssint_convert_name_to_union_name(\n\t\t\t    &temp_minor_status, mech,\n\t\t\t    internal_name, &tmp_src_name);\n\t\t    if (temp_status != GSS_S_COMPLETE) {\n\t\t\tstatus = temp_status;\n\t\t\t*minor_status = temp_minor_status;\n\t\t\tmap_error(minor_status, mech);\n\t\t\tif (output_token->length)\n\t\t\t    (void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t\t\t      output_token);\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    *src_name = tmp_src_name;\n\t\t} else\n\t\t    *src_name = GSS_C_NO_NAME;\n\t    }\n\n#define g_OID_prefix_equal(o1, o2) \\\n        (((o1)->length >= (o2)->length) && \\\n        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n\t    /* Ensure we're returning correct creds format */\n\t    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\n\t\ttmp_d_cred != GSS_C_NO_CREDENTIAL) {\n\t\tpublic_mech = gssint_get_public_oid(selected_mech);\n\t\tif (actual_mech != GSS_C_NO_OID &&\n\t\t    public_mech != GSS_C_NO_OID &&\n\t\t    !g_OID_prefix_equal(actual_mech, public_mech)) {\n\t\t    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */\n\t\t} else {\n\t\t    gss_union_cred_t d_u_cred = NULL;\n\n\t\t    d_u_cred = malloc(sizeof (gss_union_cred_desc));\n\t\t    if (d_u_cred == NULL) {\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\n\n\t\t    d_u_cred->count = 1;\n\n\t\t    status = generic_gss_copy_oid(&temp_minor_status,\n\t\t\t\t\t\t  selected_mech,\n\t\t\t\t\t\t  &d_u_cred->mechs_array);\n\n\t\t    if (status != GSS_S_COMPLETE) {\n\t\t\tfree(d_u_cred);\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\n\t\t    if (d_u_cred->cred_array != NULL) {\n\t\t\td_u_cred->cred_array[0] = tmp_d_cred;\n\t\t    } else {\n\t\t\tfree(d_u_cred);\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->loopback = d_u_cred;\n\t\t    *d_cred = (gss_cred_id_t)d_u_cred;\n\t\t}\n\t    }\n\n\t    if (mech_type != NULL)\n\t\t*mech_type = gssint_get_public_oid(actual_mech);\n\t    if (ret_flags != NULL)\n\t\t*ret_flags = temp_ret_flags;\n\t    return\t(status);\n    } else {\n\n\tstatus = GSS_S_BAD_MECH;\n    }\n\nerror_out:\n    if (union_ctx_id) {\n\tif (union_ctx_id->mech_type) {\n\t    if (union_ctx_id->mech_type->elements)\n\t\tfree(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t}\n\tif (union_ctx_id->internal_ctx_id && mech &&\n\t    mech->gss_delete_sec_context) {\n\t    mech->gss_delete_sec_context(&temp_minor_status,\n\t\t\t\t\t &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t GSS_C_NO_BUFFER);\n\t}\n\tfree(union_ctx_id);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    if (src_name)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (tmp_src_name != GSS_C_NO_NAME)\n\t(void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t  (gss_buffer_t)tmp_src_name);\n\n    return (status);\n}","idx":226,"name":"gss_accept_sec_context","project":"110511205440666","target":"True"}
{"commit_id":"261017990409577","func":"gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}","idx":230,"name":"gss_delete_sec_context","project":"126719386548325","target":"True"}
{"commit_id":"129347534425141","func":"gss_init_sec_context (minor_status,\n                      claimant_cred_handle,\n                      context_handle,\n                      target_name,\n                      req_mech_type,\n                      req_flags,\n                      time_req,\n                      input_chan_bindings,\n                      input_token,\n                      actual_mech_type,\n                      output_token,\n                      ret_flags,\n                      time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_cred_id_t\t\tclaimant_cred_handle;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_name_t\t\ttarget_name;\ngss_OID\t\t\treq_mech_type;\nOM_uint32\t\treq_flags;\nOM_uint32\t\ttime_req;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_buffer_t\t\tinput_token;\ngss_OID *\t\tactual_mech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus, temp_minor_status;\n    gss_union_name_t\tunion_name;\n    gss_union_cred_t\tunion_cred;\n    gss_name_t\t\tinternal_name;\n    gss_union_ctx_id_t\tunion_ctx_id;\n    gss_OID\t\tselected_mech;\n    gss_mechanism\tmech;\n    gss_cred_id_t\tinput_cred_handle;\n\n    status = val_init_sec_ctx_args(minor_status,\n\t\t\t\t   claimant_cred_handle,\n\t\t\t\t   context_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   req_mech_type,\n\t\t\t\t   req_flags,\n\t\t\t\t   time_req,\n\t\t\t\t   input_chan_bindings,\n\t\t\t\t   input_token,\n\t\t\t\t   actual_mech_type,\n\t\t\t\t   output_token,\n\t\t\t\t   ret_flags,\n\t\t\t\t   time_rec);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    status = gssint_select_mech_type(minor_status, req_mech_type,\n\t\t\t\t     &selected_mech);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    union_name = (gss_union_name_t)target_name;\n\n    /*\n     * obtain the gss mechanism information for the requested\n     * mechanism.  If mech_type is NULL, set it to the resultant\n     * mechanism\n     */\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech == NULL)\n\treturn (GSS_S_BAD_MECH);\n\n    if (mech->gss_init_sec_context == NULL)\n\treturn (GSS_S_UNAVAILABLE);\n\n    /*\n     * If target_name is mechanism_specific, then it must match the\n     * mech_type that we're about to use.  Otherwise, do an import on\n     * the external_name form of the target name.\n     */\n    if (union_name->mech_type &&\n\tg_OID_equal(union_name->mech_type, selected_mech)) {\n\tinternal_name = union_name->mech_name;\n    } else {\n\tif ((status = gssint_import_internal_name(minor_status, selected_mech,\n\t\t\t\t\t\t union_name,\n\t\t\t\t\t\t &internal_name)) != GSS_S_COMPLETE)\n\t    return (status);\n    }\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (union_ctx_id == NULL)\n\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n     * now call the approprate underlying mechanism routine\n     */\n\n    status = mech->gss_init_sec_context(\n\tminor_status,\n\tinput_cred_handle,\n\t&union_ctx_id->internal_ctx_id,\n\tinternal_name,\n\tgssint_get_public_oid(selected_mech),\n\treq_flags,\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * The spec says the preferred method is to delete all context info on\n\t * the first call to init, and on all subsequent calls make the caller\n\t * responsible for calling gss_delete_sec_context.  However, if the\n\t * mechanism decided to delete the internal context, we should also\n\t * delete the union context.\n\t */\n\tmap_error(minor_status, mech);\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    *context_handle = GSS_C_NO_CONTEXT;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\nend:\n    if (union_name->mech_name == NULL ||\n\tunion_name->mech_name != internal_name) {\n\t(void) gssint_release_internal_name(&temp_minor_status,\n\t\t\t\t\t    selected_mech, &internal_name);\n    }\n\n    return(status);\n}","idx":233,"name":"gss_init_sec_context","project":"138245821810109","target":"True"}
